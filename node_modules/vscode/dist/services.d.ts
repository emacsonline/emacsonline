import * as vscode from 'vscode';

declare enum Severity {
    Ignore = 0,
    Info = 1,
    Warning = 2,
    Error = 3
}
declare namespace Severity {
    /**
     * Parses 'error', 'warning', 'warn', 'info' in call casings
     * and falls back to ignore.
     */
    function fromValue(value: string): Severity;
    function toString(severity: Severity): string;
}

interface IDisposable {
    dispose(): void;
}
declare class DisposableStore implements IDisposable {
    static DISABLE_DISPOSED_WARNING: boolean;
    private _toDispose;
    private _isDisposed;
    constructor();
    /**
     * Dispose of all registered disposables and mark this object as disposed.
     *
     * Any future disposables added to this object will be disposed of on `add`.
     */
    dispose(): void;
    /**
     * Returns `true` if this object has been disposed
     */
    get isDisposed(): boolean;
    /**
     * Dispose of all registered disposables but do not mark this object as disposed.
     */
    clear(): void;
    add<T extends IDisposable>(o: T): T;
}

interface CancellationToken {
    /**
     * A flag signalling is cancellation has been requested.
     */
    readonly isCancellationRequested: boolean;
    /**
     * An event which fires when cancellation is requested. This event
     * only ever fires `once` as cancellation can only happen once. Listeners
     * that are registered after cancellation will be called (next event loop run),
     * but also only once.
     *
     * @event
     */
    readonly onCancellationRequested: (listener: (e: any) => any, thisArgs?: any, disposables?: IDisposable[]) => IDisposable;
}
declare namespace CancellationToken {
    function isCancellationToken(thing: unknown): thing is CancellationToken;
    const None: Readonly<CancellationToken>;
    const Cancelled: Readonly<CancellationToken>;
}

/**
 * To an event a function with one or zero parameters
 * can be subscribed. The event is the subscriber function itself.
 */
interface Event<T> {
    (listener: (e: T) => any, thisArgs?: any, disposables?: IDisposable[] | DisposableStore): IDisposable;
}
declare namespace Event {
    const None: Event<any>;
    /**
     * Given an event, returns another event which only fires once.
     */
    function once<T>(event: Event<T>): Event<T>;
    /**
     * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned
     * event is accessible to "third parties", e.g the event is a public property. Otherwise a leaked listener on the
     * returned event causes this utility to leak a listener on the original event.
     */
    function map<I, O>(event: Event<I>, map: (i: I) => O, disposable?: DisposableStore): Event<O>;
    /**
     * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned
     * event is accessible to "third parties", e.g the event is a public property. Otherwise a leaked listener on the
     * returned event causes this utility to leak a listener on the original event.
     */
    function forEach<I>(event: Event<I>, each: (i: I) => void, disposable?: DisposableStore): Event<I>;
    /**
     * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned
     * event is accessible to "third parties", e.g the event is a public property. Otherwise a leaked listener on the
     * returned event causes this utility to leak a listener on the original event.
     */
    function filter<T, U>(event: Event<T | U>, filter: (e: T | U) => e is T, disposable?: DisposableStore): Event<T>;
    function filter<T>(event: Event<T>, filter: (e: T) => boolean, disposable?: DisposableStore): Event<T>;
    function filter<T, R>(event: Event<T | R>, filter: (e: T | R) => e is R, disposable?: DisposableStore): Event<R>;
    /**
     * Given an event, returns the same event but typed as `Event<void>`.
     */
    function signal<T>(event: Event<T>): Event<void>;
    /**
     * Given a collection of events, returns a single event which emits
     * whenever any of the provided events emit.
     */
    function any<T>(...events: Event<T>[]): Event<T>;
    function any(...events: Event<any>[]): Event<void>;
    /**
     * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned
     * event is accessible to "third parties", e.g the event is a public property. Otherwise a leaked listener on the
     * returned event causes this utility to leak a listener on the original event.
     */
    function reduce<I, O>(event: Event<I>, merge: (last: O | undefined, event: I) => O, initial?: O, disposable?: DisposableStore): Event<O>;
    /**
     * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned
     * event is accessible to "third parties", e.g the event is a public property. Otherwise a leaked listener on the
     * returned event causes this utility to leak a listener on the original event.
     */
    function debounce<T>(event: Event<T>, merge: (last: T | undefined, event: T) => T, delay?: number, leading?: boolean, leakWarningThreshold?: number, disposable?: DisposableStore): Event<T>;
    /**
     * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned
     * event is accessible to "third parties", e.g the event is a public property. Otherwise a leaked listener on the
     * returned event causes this utility to leak a listener on the original event.
     */
    function debounce<I, O>(event: Event<I>, merge: (last: O | undefined, event: I) => O, delay?: number, leading?: boolean, leakWarningThreshold?: number, disposable?: DisposableStore): Event<O>;
    /**
     * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned
     * event is accessible to "third parties", e.g the event is a public property. Otherwise a leaked listener on the
     * returned event causes this utility to leak a listener on the original event.
     */
    function latch<T>(event: Event<T>, equals?: (a: T, b: T) => boolean, disposable?: DisposableStore): Event<T>;
    /**
     * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned
     * event is accessible to "third parties", e.g the event is a public property. Otherwise a leaked listener on the
     * returned event causes this utility to leak a listener on the original event.
     */
    function split<T, U>(event: Event<T | U>, isT: (e: T | U) => e is T, disposable?: DisposableStore): [Event<T>, Event<U>];
    /**
     * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned
     * event is accessible to "third parties", e.g the event is a public property. Otherwise a leaked listener on the
     * returned event causes this utility to leak a listener on the original event.
     */
    function buffer<T>(event: Event<T>, flushAfterTimeout?: boolean, _buffer?: T[]): Event<T>;
    interface IChainableEvent<T> {
        event: Event<T>;
        map<O>(fn: (i: T) => O): IChainableEvent<O>;
        forEach(fn: (i: T) => void): IChainableEvent<T>;
        filter(fn: (e: T) => boolean): IChainableEvent<T>;
        filter<R>(fn: (e: T | R) => e is R): IChainableEvent<R>;
        reduce<R>(merge: (last: R | undefined, event: T) => R, initial?: R): IChainableEvent<R>;
        latch(): IChainableEvent<T>;
        debounce(merge: (last: T | undefined, event: T) => T, delay?: number, leading?: boolean, leakWarningThreshold?: number): IChainableEvent<T>;
        debounce<R>(merge: (last: R | undefined, event: T) => R, delay?: number, leading?: boolean, leakWarningThreshold?: number): IChainableEvent<R>;
        on(listener: (e: T) => any, thisArgs?: any, disposables?: IDisposable[] | DisposableStore): IDisposable;
        once(listener: (e: T) => any, thisArgs?: any, disposables?: IDisposable[]): IDisposable;
    }
    /**
     * @deprecated DO NOT use, this leaks memory
     */
    function chain<T>(event: Event<T>): IChainableEvent<T>;
    interface NodeEventEmitter {
        on(event: string | symbol, listener: Function): unknown;
        removeListener(event: string | symbol, listener: Function): unknown;
    }
    function fromNodeEventEmitter<T>(emitter: NodeEventEmitter, eventName: string, map?: (...args: any[]) => T): Event<T>;
    interface DOMEventEmitter {
        addEventListener(event: string | symbol, listener: Function): void;
        removeEventListener(event: string | symbol, listener: Function): void;
    }
    function fromDOMEventEmitter<T>(emitter: DOMEventEmitter, eventName: string, map?: (...args: any[]) => T): Event<T>;
    function toPromise<T>(event: Event<T>): Promise<T>;
    function runAndSubscribe<T>(event: Event<T>, handler: (e: T | undefined) => any): IDisposable;
    function runAndSubscribeWithStore<T>(event: Event<T>, handler: (e: T | undefined, disposableStore: DisposableStore) => any): IDisposable;
}

/**
 * Uniform Resource Identifier (URI) http://tools.ietf.org/html/rfc3986.
 * This class is a simple parser which creates the basic component parts
 * (http://tools.ietf.org/html/rfc3986#section-3) with minimal validation
 * and encoding.
 *
 * ```txt
 *       foo://example.com:8042/over/there?name=ferret#nose
 *       \_/   \______________/\_________/ \_________/ \__/
 *        |           |            |            |        |
 *     scheme     authority       path        query   fragment
 *        |   _____________________|__
 *       / \ /                        \
 *       urn:example:animal:ferret:nose
 * ```
 */
declare class URI implements UriComponents {
    static isUri(thing: any): thing is URI;
    /**
     * scheme is the 'http' part of 'http://www.example.com/some/path?query#fragment'.
     * The part before the first colon.
     */
    readonly scheme: string;
    /**
     * authority is the 'www.example.com' part of 'http://www.example.com/some/path?query#fragment'.
     * The part between the first double slashes and the next slash.
     */
    readonly authority: string;
    /**
     * path is the '/some/path' part of 'http://www.example.com/some/path?query#fragment'.
     */
    readonly path: string;
    /**
     * query is the 'query' part of 'http://www.example.com/some/path?query#fragment'.
     */
    readonly query: string;
    /**
     * fragment is the 'fragment' part of 'http://www.example.com/some/path?query#fragment'.
     */
    readonly fragment: string;
    /**
     * @internal
     */
    protected constructor(scheme: string, authority?: string, path?: string, query?: string, fragment?: string, _strict?: boolean);
    /**
     * @internal
     */
    protected constructor(components: UriComponents);
    /**
     * Returns a string representing the corresponding file system path of this URI.
     * Will handle UNC paths, normalizes windows drive letters to lower-case, and uses the
     * platform specific path separator.
     *
     * * Will *not* validate the path for invalid characters and semantics.
     * * Will *not* look at the scheme of this URI.
     * * The result shall *not* be used for display purposes but for accessing a file on disk.
     *
     *
     * The *difference* to `URI#path` is the use of the platform specific separator and the handling
     * of UNC paths. See the below sample of a file-uri with an authority (UNC path).
     *
     * ```ts
        const u = URI.parse('file://server/c$/folder/file.txt')
        u.authority === 'server'
        u.path === '/shares/c$/file.txt'
        u.fsPath === '\\server\c$\folder\file.txt'
    ```
     *
     * Using `URI#path` to read a file (using fs-apis) would not be enough because parts of the path,
     * namely the server name, would be missing. Therefore `URI#fsPath` exists - it's sugar to ease working
     * with URIs that represent files on disk (`file` scheme).
     */
    get fsPath(): string;
    with(change: {
        scheme?: string;
        authority?: string | null;
        path?: string | null;
        query?: string | null;
        fragment?: string | null;
    }): URI;
    /**
     * Creates a new URI from a string, e.g. `http://www.example.com/some/path`,
     * `file:///usr/home`, or `scheme:with/path`.
     *
     * @param value A string which represents an URI (see `URI#toString`).
     */
    static parse(value: string, _strict?: boolean): URI;
    /**
     * Creates a new URI from a file system path, e.g. `c:\my\files`,
     * `/usr/home`, or `\\server\share\some\path`.
     *
     * The *difference* between `URI#parse` and `URI#file` is that the latter treats the argument
     * as path, not as stringified-uri. E.g. `URI.file(path)` is **not the same as**
     * `URI.parse('file://' + path)` because the path might contain characters that are
     * interpreted (# and ?). See the following sample:
     * ```ts
    const good = URI.file('/coding/c#/project1');
    good.scheme === 'file';
    good.path === '/coding/c#/project1';
    good.fragment === '';
    const bad = URI.parse('file://' + '/coding/c#/project1');
    bad.scheme === 'file';
    bad.path === '/coding/c'; // path is now broken
    bad.fragment === '/project1';
    ```
     *
     * @param path A file system path (see `URI#fsPath`)
     */
    static file(path: string): URI;
    static from(components: {
        scheme: string;
        authority?: string;
        path?: string;
        query?: string;
        fragment?: string;
    }): URI;
    /**
     * Join a URI path with path fragments and normalizes the resulting path.
     *
     * @param uri The input URI.
     * @param pathFragment The path fragment to add to the URI path.
     * @returns The resulting URI.
     */
    static joinPath(uri: URI, ...pathFragment: string[]): URI;
    /**
     * Creates a string representation for this URI. It's guaranteed that calling
     * `URI.parse` with the result of this function creates an URI which is equal
     * to this URI.
     *
     * * The result shall *not* be used for display purposes but for externalization or transport.
     * * The result will be encoded using the percentage encoding and encoding happens mostly
     * ignore the scheme-specific encoding rules.
     *
     * @param skipEncoding Do not encode the result, default is `false`
     */
    toString(skipEncoding?: boolean): string;
    toJSON(): UriComponents;
    static revive(data: UriComponents | URI): URI;
    static revive(data: UriComponents | URI | undefined): URI | undefined;
    static revive(data: UriComponents | URI | null): URI | null;
    static revive(data: UriComponents | URI | undefined | null): URI | undefined | null;
}
interface UriComponents {
    scheme: string;
    authority: string;
    path: string;
    query: string;
    fragment: string;
}

interface IMarkdownString {
    readonly value: string;
    readonly isTrusted?: boolean;
    readonly supportThemeIcons?: boolean;
    readonly supportHtml?: boolean;
    readonly baseUri?: UriComponents;
    uris?: {
        [href: string]: UriComponents;
    };
}

/**
 * A position in the editor. This interface is suitable for serialization.
 */
interface IPosition {
    /**
     * line number (starts at 1)
     */
    readonly lineNumber: number;
    /**
     * column (the first character in a line is between column 1 and column 2)
     */
    readonly column: number;
}
/**
 * A position in the editor.
 */
declare class Position {
    /**
     * line number (starts at 1)
     */
    readonly lineNumber: number;
    /**
     * column (the first character in a line is between column 1 and column 2)
     */
    readonly column: number;
    constructor(lineNumber: number, column: number);
    /**
     * Create a new position from this position.
     *
     * @param newLineNumber new line number
     * @param newColumn new column
     */
    with(newLineNumber?: number, newColumn?: number): Position;
    /**
     * Derive a new position from this position.
     *
     * @param deltaLineNumber line number delta
     * @param deltaColumn column delta
     */
    delta(deltaLineNumber?: number, deltaColumn?: number): Position;
    /**
     * Test if this position equals other position
     */
    equals(other: IPosition): boolean;
    /**
     * Test if position `a` equals position `b`
     */
    static equals(a: IPosition | null, b: IPosition | null): boolean;
    /**
     * Test if this position is before other position.
     * If the two positions are equal, the result will be false.
     */
    isBefore(other: IPosition): boolean;
    /**
     * Test if position `a` is before position `b`.
     * If the two positions are equal, the result will be false.
     */
    static isBefore(a: IPosition, b: IPosition): boolean;
    /**
     * Test if this position is before other position.
     * If the two positions are equal, the result will be true.
     */
    isBeforeOrEqual(other: IPosition): boolean;
    /**
     * Test if position `a` is before position `b`.
     * If the two positions are equal, the result will be true.
     */
    static isBeforeOrEqual(a: IPosition, b: IPosition): boolean;
    /**
     * A function that compares positions, useful for sorting
     */
    static compare(a: IPosition, b: IPosition): number;
    /**
     * Clone this position.
     */
    clone(): Position;
    /**
     * Convert to a human-readable representation.
     */
    toString(): string;
    /**
     * Create a `Position` from an `IPosition`.
     */
    static lift(pos: IPosition): Position;
    /**
     * Test if `obj` is an `IPosition`.
     */
    static isIPosition(obj: any): obj is IPosition;
}

/**
 * A range in the editor. This interface is suitable for serialization.
 */
interface IRange {
    /**
     * Line number on which the range starts (starts at 1).
     */
    readonly startLineNumber: number;
    /**
     * Column on which the range starts in line `startLineNumber` (starts at 1).
     */
    readonly startColumn: number;
    /**
     * Line number on which the range ends.
     */
    readonly endLineNumber: number;
    /**
     * Column on which the range ends in line `endLineNumber`.
     */
    readonly endColumn: number;
}
/**
 * A range in the editor. (startLineNumber,startColumn) is <= (endLineNumber,endColumn)
 */
declare class Range {
    /**
     * Line number on which the range starts (starts at 1).
     */
    readonly startLineNumber: number;
    /**
     * Column on which the range starts in line `startLineNumber` (starts at 1).
     */
    readonly startColumn: number;
    /**
     * Line number on which the range ends.
     */
    readonly endLineNumber: number;
    /**
     * Column on which the range ends in line `endLineNumber`.
     */
    readonly endColumn: number;
    constructor(startLineNumber: number, startColumn: number, endLineNumber: number, endColumn: number);
    /**
     * Test if this range is empty.
     */
    isEmpty(): boolean;
    /**
     * Test if `range` is empty.
     */
    static isEmpty(range: IRange): boolean;
    /**
     * Test if position is in this range. If the position is at the edges, will return true.
     */
    containsPosition(position: IPosition): boolean;
    /**
     * Test if `position` is in `range`. If the position is at the edges, will return true.
     */
    static containsPosition(range: IRange, position: IPosition): boolean;
    /**
     * Test if `position` is in `range`. If the position is at the edges, will return false.
     * @internal
     */
    static strictContainsPosition(range: IRange, position: IPosition): boolean;
    /**
     * Test if range is in this range. If the range is equal to this range, will return true.
     */
    containsRange(range: IRange): boolean;
    /**
     * Test if `otherRange` is in `range`. If the ranges are equal, will return true.
     */
    static containsRange(range: IRange, otherRange: IRange): boolean;
    /**
     * Test if `range` is strictly in this range. `range` must start after and end before this range for the result to be true.
     */
    strictContainsRange(range: IRange): boolean;
    /**
     * Test if `otherRange` is strictly in `range` (must start after, and end before). If the ranges are equal, will return false.
     */
    static strictContainsRange(range: IRange, otherRange: IRange): boolean;
    /**
     * A reunion of the two ranges.
     * The smallest position will be used as the start point, and the largest one as the end point.
     */
    plusRange(range: IRange): Range;
    /**
     * A reunion of the two ranges.
     * The smallest position will be used as the start point, and the largest one as the end point.
     */
    static plusRange(a: IRange, b: IRange): Range;
    /**
     * A intersection of the two ranges.
     */
    intersectRanges(range: IRange): Range | null;
    /**
     * A intersection of the two ranges.
     */
    static intersectRanges(a: IRange, b: IRange): Range | null;
    /**
     * Test if this range equals other.
     */
    equalsRange(other: IRange | null): boolean;
    /**
     * Test if range `a` equals `b`.
     */
    static equalsRange(a: IRange | null, b: IRange | null): boolean;
    /**
     * Return the end position (which will be after or equal to the start position)
     */
    getEndPosition(): Position;
    /**
     * Return the end position (which will be after or equal to the start position)
     */
    static getEndPosition(range: IRange): Position;
    /**
     * Return the start position (which will be before or equal to the end position)
     */
    getStartPosition(): Position;
    /**
     * Return the start position (which will be before or equal to the end position)
     */
    static getStartPosition(range: IRange): Position;
    /**
     * Transform to a user presentable string representation.
     */
    toString(): string;
    /**
     * Create a new range using this range's start position, and using endLineNumber and endColumn as the end position.
     */
    setEndPosition(endLineNumber: number, endColumn: number): Range;
    /**
     * Create a new range using this range's end position, and using startLineNumber and startColumn as the start position.
     */
    setStartPosition(startLineNumber: number, startColumn: number): Range;
    /**
     * Create a new empty range using this range's start position.
     */
    collapseToStart(): Range;
    /**
     * Create a new empty range using this range's start position.
     */
    static collapseToStart(range: IRange): Range;
    static fromPositions(start: IPosition, end?: IPosition): Range;
    /**
     * Create a `Range` from an `IRange`.
     */
    static lift(range: undefined | null): null;
    static lift(range: IRange): Range;
    static lift(range: IRange | undefined | null): Range | null;
    /**
     * Test if `obj` is an `IRange`.
     */
    static isIRange(obj: any): obj is IRange;
    /**
     * Test if the two ranges are touching in any way.
     */
    static areIntersectingOrTouching(a: IRange, b: IRange): boolean;
    /**
     * Test if the two ranges are intersecting. If the ranges are touching it returns true.
     */
    static areIntersecting(a: IRange, b: IRange): boolean;
    /**
     * A function that compares ranges, useful for sorting ranges
     * It will first compare ranges on the startPosition and then on the endPosition
     */
    static compareRangesUsingStarts(a: IRange | null | undefined, b: IRange | null | undefined): number;
    /**
     * A function that compares ranges, useful for sorting ranges
     * It will first compare ranges on the endPosition and then on the startPosition
     */
    static compareRangesUsingEnds(a: IRange, b: IRange): number;
    /**
     * Test if the range spans multiple lines.
     */
    static spansMultipleLines(range: IRange): boolean;
    toJSON(): IRange;
}

/**
 * A single edit operation, that acts as a simple replace.
 * i.e. Replace text at `range` with `text` in model.
 */
interface ISingleEditOperation {
    /**
     * The range to replace. This can be empty to emulate a simple insert.
     */
    range: IRange;
    /**
     * The text to replace with. This can be null to emulate a simple delete.
     */
    text: string | null;
    /**
     * This indicates that this operation has "insert" semantics.
     * i.e. forceMoveMarkers = true => if `range` is collapsed, all markers at the position will be moved.
     */
    forceMoveMarkers?: boolean;
}

/**
 * A selection in the editor.
 * The selection is a range that has an orientation.
 */
interface ISelection {
    /**
     * The line number on which the selection has started.
     */
    readonly selectionStartLineNumber: number;
    /**
     * The column on `selectionStartLineNumber` where the selection has started.
     */
    readonly selectionStartColumn: number;
    /**
     * The line number on which the selection has ended.
     */
    readonly positionLineNumber: number;
    /**
     * The column on `positionLineNumber` where the selection has ended.
     */
    readonly positionColumn: number;
}
/**
 * The direction of a selection.
 */
declare const enum SelectionDirection {
    /**
     * The selection starts above where it ends.
     */
    LTR = 0,
    /**
     * The selection starts below where it ends.
     */
    RTL = 1
}
/**
 * A selection in the editor.
 * The selection is a range that has an orientation.
 */
declare class Selection extends Range {
    /**
     * The line number on which the selection has started.
     */
    readonly selectionStartLineNumber: number;
    /**
     * The column on `selectionStartLineNumber` where the selection has started.
     */
    readonly selectionStartColumn: number;
    /**
     * The line number on which the selection has ended.
     */
    readonly positionLineNumber: number;
    /**
     * The column on `positionLineNumber` where the selection has ended.
     */
    readonly positionColumn: number;
    constructor(selectionStartLineNumber: number, selectionStartColumn: number, positionLineNumber: number, positionColumn: number);
    /**
     * Transform to a human-readable representation.
     */
    toString(): string;
    /**
     * Test if equals other selection.
     */
    equalsSelection(other: ISelection): boolean;
    /**
     * Test if the two selections are equal.
     */
    static selectionsEqual(a: ISelection, b: ISelection): boolean;
    /**
     * Get directions (LTR or RTL).
     */
    getDirection(): SelectionDirection;
    /**
     * Create a new selection with a different `positionLineNumber` and `positionColumn`.
     */
    setEndPosition(endLineNumber: number, endColumn: number): Selection;
    /**
     * Get the position at `positionLineNumber` and `positionColumn`.
     */
    getPosition(): Position;
    /**
     * Get the position at the start of the selection.
    */
    getSelectionStart(): Position;
    /**
     * Create a new selection with a different `selectionStartLineNumber` and `selectionStartColumn`.
     */
    setStartPosition(startLineNumber: number, startColumn: number): Selection;
    /**
     * Create a `Selection` from one or two positions
     */
    static fromPositions(start: IPosition, end?: IPosition): Selection;
    /**
     * Creates a `Selection` from a range, given a direction.
     */
    static fromRange(range: Range, direction: SelectionDirection): Selection;
    /**
     * Create a `Selection` from an `ISelection`.
     */
    static liftSelection(sel: ISelection): Selection;
    /**
     * `a` equals `b`.
     */
    static selectionsArrEqual(a: ISelection[], b: ISelection[]): boolean;
    /**
     * Test if `obj` is an `ISelection`.
     */
    static isISelection(obj: any): obj is ISelection;
    /**
     * Create with a direction.
     */
    static createWithDirection(startLineNumber: number, startColumn: number, endLineNumber: number, endColumn: number, direction: SelectionDirection): Selection;
}

/**
 * Open ended enum at runtime
 */
declare const enum LanguageId {
    Null = 0,
    PlainText = 1
}
/**
 * Open ended enum at runtime
 */
declare const enum ColorId {
    None = 0,
    DefaultForeground = 1,
    DefaultBackground = 2
}
/**
 * A standard token type.
 */
declare const enum StandardTokenType {
    Other = 0,
    Comment = 1,
    String = 2,
    RegEx = 3
}
/**
 */
interface ITokenPresentation {
    foreground: ColorId;
    italic: boolean;
    bold: boolean;
    underline: boolean;
    strikethrough: boolean;
}

declare class TextChange {
    readonly oldPosition: number;
    readonly oldText: string;
    readonly newPosition: number;
    readonly newText: string;
    get oldLength(): number;
    get oldEnd(): number;
    get newLength(): number;
    get newEnd(): number;
    constructor(oldPosition: number, oldText: string, newPosition: number, newText: string);
    toString(): string;
    private static _writeStringSize;
    private static _writeString;
    private static _readString;
    writeSize(): number;
    write(b: Uint8Array, offset: number): number;
    static read(b: Uint8Array, offset: number, dest: TextChange[]): number;
}

/**
 * A fast character classifier that uses a compact array for ASCII values.
 */
declare class CharacterClassifier<T extends number> {
    /**
     * Maintain a compact (fully initialized ASCII map for quickly classifying ASCII characters - used more often in code).
     */
    protected _asciiMap: Uint8Array;
    /**
     * The entire map (sparse array).
     */
    protected _map: Map<number, number>;
    protected _defaultValue: number;
    constructor(_defaultValue: T);
    private static _createAsciiMap;
    set(charCode: number, _value: T): void;
    get(charCode: number): T;
}

declare const enum WordCharacterClass {
    Regular = 0,
    Whitespace = 1,
    WordSeparator = 2
}
declare class WordCharacterClassifier extends CharacterClassifier<WordCharacterClass> {
    constructor(wordSeparators: string);
}

/**
 * Word inside a model.
 */
interface IWordAtPosition {
    /**
     * The word.
     */
    readonly word: string;
    /**
     * The column where the word starts.
     */
    readonly startColumn: number;
    /**
     * The column where the word ends.
     */
    readonly endColumn: number;
}

interface IViewLineTokens {
    equals(other: IViewLineTokens): boolean;
    getCount(): number;
    getForeground(tokenIndex: number): ColorId;
    getEndOffset(tokenIndex: number): number;
    getClassName(tokenIndex: number): string;
    getInlineStyle(tokenIndex: number, colorMap: string[]): string;
    getPresentation(tokenIndex: number): ITokenPresentation;
    findTokenIndexAtOffset(offset: number): number;
    getLineContent(): string;
    getMetadata(tokenIndex: number): number;
    getLanguageId(tokenIndex: number): string;
}
declare class LineTokens implements IViewLineTokens {
    _lineTokensBrand: void;
    private readonly _tokens;
    private readonly _tokensCount;
    private readonly _text;
    private readonly _languageIdCodec;
    static defaultTokenMetadata: number;
    static createEmpty(lineContent: string, decoder: ILanguageIdCodec): LineTokens;
    constructor(tokens: Uint32Array, text: string, decoder: ILanguageIdCodec);
    equals(other: IViewLineTokens): boolean;
    slicedEquals(other: LineTokens, sliceFromTokenIndex: number, sliceTokenCount: number): boolean;
    getLineContent(): string;
    getCount(): number;
    getStartOffset(tokenIndex: number): number;
    getMetadata(tokenIndex: number): number;
    getLanguageId(tokenIndex: number): string;
    getStandardTokenType(tokenIndex: number): StandardTokenType;
    getForeground(tokenIndex: number): ColorId;
    getClassName(tokenIndex: number): string;
    getInlineStyle(tokenIndex: number, colorMap: string[]): string;
    getPresentation(tokenIndex: number): ITokenPresentation;
    getEndOffset(tokenIndex: number): number;
    /**
     * Find the token containing offset `offset`.
     * @param offset The search offset
     * @return The index of the token containing the offset.
     */
    findTokenIndexAtOffset(offset: number): number;
    inflate(): IViewLineTokens;
    sliceAndInflate(startOffset: number, endOffset: number, deltaOffset: number): IViewLineTokens;
    static convertToEndOffset(tokens: Uint32Array, lineTextLength: number): void;
    static findIndexInTokensArray(tokens: Uint32Array, desiredIndex: number): number;
    /**
     * @pure
     * @param insertTokens Must be sorted by offset.
    */
    withInserted(insertTokens: {
        offset: number;
        text: string;
        tokenMetadata: number;
    }[]): LineTokens;
}

/**
 * Describes how comments for a language work.
 */
interface CommentRule {
    /**
     * The line comment token, like `// this is a comment`
     */
    lineComment?: string | null;
    /**
     * The block comment character pair, like `/* block comment *&#47;`
     */
    blockComment?: CharacterPair | null;
}
/**
 * The language configuration interface defines the contract between extensions and
 * various editor features, like automatic bracket insertion, automatic indentation etc.
 */
interface LanguageConfiguration {
    /**
     * The language's comment settings.
     */
    comments?: CommentRule;
    /**
     * The language's brackets.
     * This configuration implicitly affects pressing Enter around these brackets.
     */
    brackets?: CharacterPair[];
    /**
     * The language's word definition.
     * If the language supports Unicode identifiers (e.g. JavaScript), it is preferable
     * to provide a word definition that uses exclusion of known separators.
     * e.g.: A regex that matches anything except known separators (and dot is allowed to occur in a floating point number):
     *   /(-?\d*\.\d\w*)|([^\`\~\!\@\#\%\^\&\*\(\)\-\=\+\[\{\]\}\\\|\;\:\'\"\,\.\<\>\/\?\s]+)/g
     */
    wordPattern?: RegExp;
    /**
     * The language's indentation settings.
     */
    indentationRules?: IndentationRule;
    /**
     * The language's rules to be evaluated when pressing Enter.
     */
    onEnterRules?: OnEnterRule[];
    /**
     * The language's auto closing pairs. The 'close' character is automatically inserted with the
     * 'open' character is typed. If not set, the configured brackets will be used.
     */
    autoClosingPairs?: IAutoClosingPairConditional[];
    /**
     * The language's surrounding pairs. When the 'open' character is typed on a selection, the
     * selected string is surrounded by the open and close characters. If not set, the autoclosing pairs
     * settings will be used.
     */
    surroundingPairs?: IAutoClosingPair[];
    /**
     * Defines a list of bracket pairs that are colorized depending on their nesting level.
     * If not set, the configured brackets will be used.
    */
    colorizedBracketPairs?: CharacterPair[];
    /**
     * Defines what characters must be after the cursor for bracket or quote autoclosing to occur when using the \'languageDefined\' autoclosing setting.
     *
     * This is typically the set of characters which can not start an expression, such as whitespace, closing brackets, non-unary operators, etc.
     */
    autoCloseBefore?: string;
    /**
     * The language's folding rules.
     */
    folding?: FoldingRules;
    /**
     * **Deprecated** Do not use.
     *
     * @deprecated Will be replaced by a better API soon.
     */
    __electricCharacterSupport?: {
        docComment?: IDocComment;
    };
}
/**
 * Describes indentation rules for a language.
 */
interface IndentationRule {
    /**
     * If a line matches this pattern, then all the lines after it should be unindented once (until another rule matches).
     */
    decreaseIndentPattern: RegExp;
    /**
     * If a line matches this pattern, then all the lines after it should be indented once (until another rule matches).
     */
    increaseIndentPattern: RegExp;
    /**
     * If a line matches this pattern, then **only the next line** after it should be indented once.
     */
    indentNextLinePattern?: RegExp | null;
    /**
     * If a line matches this pattern, then its indentation should not be changed and it should not be evaluated against the other rules.
     */
    unIndentedLinePattern?: RegExp | null;
}
/**
 * Describes language specific folding markers such as '#region' and '#endregion'.
 * The start and end regexes will be tested against the contents of all lines and must be designed efficiently:
 * - the regex should start with '^'
 * - regexp flags (i, g) are ignored
 */
interface FoldingMarkers {
    start: RegExp;
    end: RegExp;
}
/**
 * Describes folding rules for a language.
 */
interface FoldingRules {
    /**
     * Used by the indentation based strategy to decide whether empty lines belong to the previous or the next block.
     * A language adheres to the off-side rule if blocks in that language are expressed by their indentation.
     * See [wikipedia](https://en.wikipedia.org/wiki/Off-side_rule) for more information.
     * If not set, `false` is used and empty lines belong to the previous block.
     */
    offSide?: boolean;
    /**
     * Region markers used by the language.
     */
    markers?: FoldingMarkers;
}
/**
 * Describes a rule to be evaluated when pressing Enter.
 */
interface OnEnterRule {
    /**
     * This rule will only execute if the text before the cursor matches this regular expression.
     */
    beforeText: RegExp;
    /**
     * This rule will only execute if the text after the cursor matches this regular expression.
     */
    afterText?: RegExp;
    /**
     * This rule will only execute if the text above the this line matches this regular expression.
     */
    previousLineText?: RegExp;
    /**
     * The action to execute.
     */
    action: EnterAction;
}
/**
 * Definition of documentation comments (e.g. Javadoc/JSdoc)
 */
interface IDocComment {
    /**
     * The string that starts a doc comment (e.g. '/**')
     */
    open: string;
    /**
     * The string that appears on the last line and closes the doc comment (e.g. ' * /').
     */
    close?: string;
}
/**
 * A tuple of two characters, like a pair of
 * opening and closing brackets.
 */
declare type CharacterPair = [string, string];
interface IAutoClosingPair {
    open: string;
    close: string;
}
interface IAutoClosingPairConditional extends IAutoClosingPair {
    notIn?: string[];
}
/**
 * Describes what to do with the indentation when pressing Enter.
 */
declare enum IndentAction {
    /**
     * Insert new line and copy the previous line's indentation.
     */
    None = 0,
    /**
     * Insert new line and indent once (relative to the previous line's indentation).
     */
    Indent = 1,
    /**
     * Insert two new lines:
     *  - the first one indented which will hold the cursor
     *  - the second one at the same indentation level
     */
    IndentOutdent = 2,
    /**
     * Insert new line and outdent once (relative to the previous line's indentation).
     */
    Outdent = 3
}
/**
 * Describes what to do when pressing Enter.
 */
interface EnterAction {
    /**
     * Describe what to do with the indentation.
     */
    indentAction: IndentAction;
    /**
     * Describes text to be appended after the new line and after the indentation.
     */
    appendText?: string;
    /**
     * Describes the number of characters to remove from the new line's indentation.
     */
    removeText?: number;
}

/**
 * Captures all bracket related configurations for a single language.
 * Immutable.
*/
declare class LanguageBracketsConfiguration {
    readonly languageId: string;
    private readonly _openingBrackets;
    private readonly _closingBrackets;
    constructor(languageId: string, config: LanguageConfiguration);
    /**
     * No two brackets have the same bracket text.
    */
    get openingBrackets(): readonly OpeningBracketKind[];
    /**
     * No two brackets have the same bracket text.
    */
    get closingBrackets(): readonly ClosingBracketKind[];
    getOpeningBracketInfo(bracketText: string): OpeningBracketKind | undefined;
    getClosingBracketInfo(bracketText: string): ClosingBracketKind | undefined;
    getBracketInfo(bracketText: string): BracketKind | undefined;
}
declare type BracketKind = OpeningBracketKind | ClosingBracketKind;
declare class BracketKindBase {
    protected readonly config: LanguageBracketsConfiguration;
    readonly bracketText: string;
    constructor(config: LanguageBracketsConfiguration, bracketText: string);
    get languageId(): string;
}
declare class OpeningBracketKind extends BracketKindBase {
    readonly openedBrackets: ReadonlySet<ClosingBracketKind>;
    readonly isOpeningBracket = true;
    constructor(config: LanguageBracketsConfiguration, bracketText: string, openedBrackets: ReadonlySet<ClosingBracketKind>);
}
declare class ClosingBracketKind extends BracketKindBase {
    /**
     * Non empty array of all opening brackets this bracket closes.
    */
    readonly closedBrackets: ReadonlySet<OpeningBracketKind>;
    readonly isOpeningBracket = false;
    constructor(config: LanguageBracketsConfiguration, bracketText: string, 
    /**
     * Non empty array of all opening brackets this bracket closes.
    */
    closedBrackets: ReadonlySet<OpeningBracketKind>);
    /**
     * Checks if this bracket closes the given other bracket.
     * Brackets from other language configuration can be used (they will always return false).
     * If other is a bracket with the same language id, they have to be from the same configuration.
    */
    closes(other: OpeningBracketKind): boolean;
    getClosedBrackets(): readonly OpeningBracketKind[];
}

/**
 * Represents a non-negative length in terms of line and column count.
 * Does not allocate.
*/
declare type Length = {
    _brand: 'Length';
};

/**
 * Represents an immutable set that works best for a small number of elements (less than 32).
 * It uses bits to encode element membership efficiently.
*/
declare class SmallImmutableSet<T> {
    private readonly items;
    private readonly additionalItems;
    private static cache;
    private static create;
    private static empty;
    static getEmpty<T>(): SmallImmutableSet<T>;
    private constructor();
    add(value: T, keyProvider: IDenseKeyProvider<T>): SmallImmutableSet<T>;
    has(value: T, keyProvider: IDenseKeyProvider<T>): boolean;
    merge(other: SmallImmutableSet<T>): SmallImmutableSet<T>;
    intersects(other: SmallImmutableSet<T>): boolean;
    equals(other: SmallImmutableSet<T>): boolean;
}
interface IDenseKeyProvider<T> {
    getKey(value: T): number;
}

declare type OpeningBracketId = number;

declare const enum AstNodeKind {
    Text = 0,
    Bracket = 1,
    Pair = 2,
    UnexpectedClosingBracket = 3,
    List = 4
}
declare type AstNode = PairAstNode | ListAstNode | BracketAstNode | InvalidBracketAstNode | TextAstNode;
/**
 * The base implementation for all AST nodes.
*/
declare abstract class BaseAstNode {
    abstract readonly kind: AstNodeKind;
    abstract readonly childrenLength: number;
    /**
     * Might return null even if {@link idx} is smaller than {@link BaseAstNode.childrenLength}.
    */
    abstract getChild(idx: number): AstNode | null;
    /**
     * Try to avoid using this property, as implementations might need to allocate the resulting array.
    */
    abstract readonly children: readonly AstNode[];
    /**
     * Represents the set of all (potentially) missing opening bracket ids in this node.
     * E.g. in `{ ] ) }` that set is {`[`, `(` }.
    */
    abstract readonly missingOpeningBracketIds: SmallImmutableSet<OpeningBracketId>;
    /**
     * In case of a list, determines the height of the (2,3) tree.
    */
    abstract readonly listHeight: number;
    protected _length: Length;
    /**
     * The length of the entire node, which should equal the sum of lengths of all children.
    */
    get length(): Length;
    constructor(length: Length);
    /**
     * @param openBracketIds The set of all opening brackets that have not yet been closed.
     */
    abstract canBeReused(openBracketIds: SmallImmutableSet<OpeningBracketId>): boolean;
    /**
     * Flattens all lists in this AST. Only for debugging.
     */
    abstract flattenLists(): AstNode;
    /**
     * Creates a deep clone.
     */
    abstract deepClone(): AstNode;
    abstract computeMinIndentation(offset: Length, textModel: ITextModel): number;
}
/**
 * Represents a bracket pair including its child (e.g. `{ ... }`).
 * Might be unclosed.
 * Immutable, if all children are immutable.
*/
declare class PairAstNode extends BaseAstNode {
    readonly openingBracket: BracketAstNode;
    readonly child: AstNode | null;
    readonly closingBracket: BracketAstNode | null;
    readonly missingOpeningBracketIds: SmallImmutableSet<OpeningBracketId>;
    static create(openingBracket: BracketAstNode, child: AstNode | null, closingBracket: BracketAstNode | null): PairAstNode;
    get kind(): AstNodeKind.Pair;
    get listHeight(): number;
    get childrenLength(): number;
    getChild(idx: number): AstNode | null;
    /**
     * Avoid using this property, it allocates an array!
    */
    get children(): AstNode[];
    private constructor();
    canBeReused(openBracketIds: SmallImmutableSet<OpeningBracketId>): boolean;
    flattenLists(): PairAstNode;
    deepClone(): PairAstNode;
    computeMinIndentation(offset: Length, textModel: ITextModel): number;
}
declare abstract class ListAstNode extends BaseAstNode {
    readonly listHeight: number;
    private _missingOpeningBracketIds;
    /**
     * This method uses more memory-efficient list nodes that can only store 2 or 3 children.
    */
    static create23(item1: AstNode, item2: AstNode, item3: AstNode | null, immutable?: boolean): ListAstNode;
    static create(items: AstNode[], immutable?: boolean): ListAstNode;
    static getEmpty(): ImmutableArrayListAstNode;
    get kind(): AstNodeKind.List;
    get missingOpeningBracketIds(): SmallImmutableSet<OpeningBracketId>;
    private cachedMinIndentation;
    /**
     * Use ListAstNode.create.
    */
    constructor(length: Length, listHeight: number, _missingOpeningBracketIds: SmallImmutableSet<OpeningBracketId>);
    protected throwIfImmutable(): void;
    protected abstract setChild(idx: number, child: AstNode): void;
    makeLastElementMutable(): AstNode | undefined;
    makeFirstElementMutable(): AstNode | undefined;
    canBeReused(openBracketIds: SmallImmutableSet<OpeningBracketId>): boolean;
    handleChildrenChanged(): void;
    flattenLists(): ListAstNode;
    computeMinIndentation(offset: Length, textModel: ITextModel): number;
    /**
     * Creates a shallow clone that is mutable, or itself if it is already mutable.
     */
    abstract toMutable(): ListAstNode;
    abstract appendChildOfSameHeight(node: AstNode): void;
    abstract unappendChild(): AstNode | undefined;
    abstract prependChildOfSameHeight(node: AstNode): void;
    abstract unprependChild(): AstNode | undefined;
}
/**
 * For debugging.
*/
declare class ArrayListAstNode extends ListAstNode {
    private readonly _children;
    get childrenLength(): number;
    getChild(idx: number): AstNode | null;
    setChild(idx: number, child: AstNode): void;
    get children(): readonly AstNode[];
    constructor(length: Length, listHeight: number, _children: AstNode[], missingOpeningBracketIds: SmallImmutableSet<OpeningBracketId>);
    deepClone(): ListAstNode;
    appendChildOfSameHeight(node: AstNode): void;
    unappendChild(): AstNode | undefined;
    prependChildOfSameHeight(node: AstNode): void;
    unprependChild(): AstNode | undefined;
    toMutable(): ListAstNode;
}
/**
 * Immutable, if all children are immutable.
*/
declare class ImmutableArrayListAstNode extends ArrayListAstNode {
    toMutable(): ListAstNode;
    protected throwIfImmutable(): void;
}
declare abstract class ImmutableLeafAstNode extends BaseAstNode {
    get listHeight(): number;
    get childrenLength(): number;
    getChild(idx: number): AstNode | null;
    get children(): readonly AstNode[];
    flattenLists(): this & AstNode;
    deepClone(): this & AstNode;
}
declare class TextAstNode extends ImmutableLeafAstNode {
    get kind(): AstNodeKind.Text;
    get missingOpeningBracketIds(): SmallImmutableSet<OpeningBracketId>;
    canBeReused(_openedBracketIds: SmallImmutableSet<OpeningBracketId>): boolean;
    computeMinIndentation(offset: Length, textModel: ITextModel): number;
}
declare class BracketAstNode extends ImmutableLeafAstNode {
    readonly bracketInfo: BracketKind;
    /**
     * In case of a opening bracket, this is the id of the opening bracket.
     * In case of a closing bracket, this contains the ids of all opening brackets it can close.
    */
    readonly bracketIds: SmallImmutableSet<OpeningBracketId>;
    static create(length: Length, bracketInfo: BracketKind, bracketIds: SmallImmutableSet<OpeningBracketId>): BracketAstNode;
    get kind(): AstNodeKind.Bracket;
    get missingOpeningBracketIds(): SmallImmutableSet<OpeningBracketId>;
    private constructor();
    get text(): string;
    get languageId(): string;
    canBeReused(_openedBracketIds: SmallImmutableSet<OpeningBracketId>): boolean;
    computeMinIndentation(offset: Length, textModel: ITextModel): number;
}
declare class InvalidBracketAstNode extends ImmutableLeafAstNode {
    get kind(): AstNodeKind.UnexpectedClosingBracket;
    readonly missingOpeningBracketIds: SmallImmutableSet<OpeningBracketId>;
    constructor(closingBrackets: SmallImmutableSet<OpeningBracketId>, length: Length);
    canBeReused(openedBracketIds: SmallImmutableSet<OpeningBracketId>): boolean;
    computeMinIndentation(offset: Length, textModel: ITextModel): number;
}

interface IBracketPairsTextModelPart {
    /**
     * Is fired when bracket pairs change, either due to a text or a settings change.
    */
    onDidChange: Event<void>;
    /**
     * Gets all bracket pairs that intersect the given position.
     * The result is sorted by the start position.
     */
    getBracketPairsInRange(range: IRange): BracketPairInfo[];
    /**
     * Gets all bracket pairs that intersect the given position.
     * The result is sorted by the start position.
     */
    getBracketPairsInRangeWithMinIndentation(range: IRange): BracketPairWithMinIndentationInfo[];
    getBracketsInRange(range: IRange): BracketInfo[];
    /**
     * Find the matching bracket of `request` up, counting brackets.
     * @param request The bracket we're searching for
     * @param position The position at which to start the search.
     * @return The range of the matching bracket, or null if the bracket match was not found.
     */
    findMatchingBracketUp(bracket: string, position: IPosition, maxDuration?: number): Range | null;
    /**
     * Find the first bracket in the model before `position`.
     * @param position The position at which to start the search.
     * @return The info for the first bracket before `position`, or null if there are no more brackets before `positions`.
     */
    findPrevBracket(position: IPosition): IFoundBracket | null;
    /**
     * Find the first bracket in the model after `position`.
     * @param position The position at which to start the search.
     * @return The info for the first bracket after `position`, or null if there are no more brackets after `positions`.
     */
    findNextBracket(position: IPosition): IFoundBracket | null;
    /**
     * Find the enclosing brackets that contain `position`.
     * @param position The position at which to start the search.
     */
    findEnclosingBrackets(position: IPosition, maxDuration?: number): [Range, Range] | null;
    /**
     * Given a `position`, if the position is on top or near a bracket,
     * find the matching bracket of that bracket and return the ranges of both brackets.
     * @param position The position at which to look for a bracket.
     */
    matchBracket(position: IPosition, maxDuration?: number): [Range, Range] | null;
}
interface IFoundBracket {
    range: Range;
    bracketInfo: OpeningBracketKind | ClosingBracketKind;
}
declare class BracketInfo {
    readonly range: Range;
    /** 0-based level */
    readonly nestingLevel: number;
    readonly nestingLevelOfEqualBracketType: number;
    readonly isInvalid: boolean;
    constructor(range: Range, 
    /** 0-based level */
    nestingLevel: number, nestingLevelOfEqualBracketType: number, isInvalid: boolean);
}
declare class BracketPairInfo {
    readonly range: Range;
    readonly openingBracketRange: Range;
    readonly closingBracketRange: Range | undefined;
    /** 0-based */
    readonly nestingLevel: number;
    readonly nestingLevelOfEqualBracketType: number;
    private readonly bracketPairNode;
    constructor(range: Range, openingBracketRange: Range, closingBracketRange: Range | undefined, 
    /** 0-based */
    nestingLevel: number, nestingLevelOfEqualBracketType: number, bracketPairNode: PairAstNode);
    get openingBracketInfo(): OpeningBracketKind;
    get closingBracketInfo(): ClosingBracketKind | undefined;
}
declare class BracketPairWithMinIndentationInfo extends BracketPairInfo {
    /**
     * -1 if not requested, otherwise the size of the minimum indentation in the bracket pair in terms of visible columns.
    */
    readonly minVisibleColumnIndentation: number;
    constructor(range: Range, openingBracketRange: Range, closingBracketRange: Range | undefined, 
    /**
     * 0-based
    */
    nestingLevel: number, nestingLevelOfEqualBracketType: number, bracketPairNode: PairAstNode, 
    /**
     * -1 if not requested, otherwise the size of the minimum indentation in the bracket pair in terms of visible columns.
    */
    minVisibleColumnIndentation: number);
}

/**
 * An event describing that the current language associated with a model has changed.
 */
interface IModelLanguageChangedEvent {
    /**
     * Previous language
     */
    readonly oldLanguage: string;
    /**
     * New language
     */
    readonly newLanguage: string;
}
/**
 * An event describing that the language configuration associated with a model has changed.
 */
interface IModelLanguageConfigurationChangedEvent {
}
interface IModelContentChange {
    /**
     * The range that got replaced.
     */
    readonly range: IRange;
    /**
     * The offset of the range that got replaced.
     */
    readonly rangeOffset: number;
    /**
     * The length of the range that got replaced.
     */
    readonly rangeLength: number;
    /**
     * The new text for the range.
     */
    readonly text: string;
}
/**
 * An event describing a change in the text of a model.
 */
interface IModelContentChangedEvent {
    readonly changes: IModelContentChange[];
    /**
     * The (new) end-of-line character.
     */
    readonly eol: string;
    /**
     * The new version id the model has transitioned to.
     */
    readonly versionId: number;
    /**
     * Flag that indicates that this event was generated while undoing.
     */
    readonly isUndoing: boolean;
    /**
     * Flag that indicates that this event was generated while redoing.
     */
    readonly isRedoing: boolean;
    /**
     * Flag that indicates that all decorations were lost with this edit.
     * The model has been reset to a new value.
     */
    readonly isFlush: boolean;
}
/**
 * An event describing that model decorations have changed.
 */
interface IModelDecorationsChangedEvent {
    readonly affectsMinimap: boolean;
    readonly affectsOverviewRuler: boolean;
}
/**
 * An event describing that some ranges of lines have been tokenized (their tokens have changed).
 * @internal
 */
interface IModelTokensChangedEvent {
    readonly tokenizationSupportChanged: boolean;
    readonly semanticTokensApplied: boolean;
    readonly ranges: {
        /**
         * The start of the range (inclusive)
         */
        readonly fromLineNumber: number;
        /**
         * The end of the range (inclusive)
         */
        readonly toLineNumber: number;
    }[];
}
interface IModelOptionsChangedEvent {
    readonly tabSize: boolean;
    readonly indentSize: boolean;
    readonly insertSpaces: boolean;
    readonly trimAutoWhitespace: boolean;
}
/**
 * @internal
 */
declare const enum RawContentChangedType {
    Flush = 1,
    LineChanged = 2,
    LinesDeleted = 3,
    LinesInserted = 4,
    EOLChanged = 5
}
/**
 * An event describing that a model has been reset to a new value.
 * @internal
 */
declare class ModelRawFlush {
    readonly changeType = RawContentChangedType.Flush;
}
/**
 * Represents text injected on a line
 * @internal
 */
declare class LineInjectedText {
    readonly ownerId: number;
    readonly lineNumber: number;
    readonly column: number;
    readonly options: InjectedTextOptions;
    readonly order: number;
    static applyInjectedText(lineText: string, injectedTexts: LineInjectedText[] | null): string;
    static fromDecorations(decorations: IModelDecoration[]): LineInjectedText[];
    constructor(ownerId: number, lineNumber: number, column: number, options: InjectedTextOptions, order: number);
    withText(text: string): LineInjectedText;
}
/**
 * An event describing that a line has changed in a model.
 * @internal
 */
declare class ModelRawLineChanged {
    readonly changeType = RawContentChangedType.LineChanged;
    /**
     * The line that has changed.
     */
    readonly lineNumber: number;
    /**
     * The new value of the line.
     */
    readonly detail: string;
    /**
     * The injected text on the line.
     */
    readonly injectedText: LineInjectedText[] | null;
    constructor(lineNumber: number, detail: string, injectedText: LineInjectedText[] | null);
}
/**
 * An event describing that line(s) have been deleted in a model.
 * @internal
 */
declare class ModelRawLinesDeleted {
    readonly changeType = RawContentChangedType.LinesDeleted;
    /**
     * At what line the deletion began (inclusive).
     */
    readonly fromLineNumber: number;
    /**
     * At what line the deletion stopped (inclusive).
     */
    readonly toLineNumber: number;
    constructor(fromLineNumber: number, toLineNumber: number);
}
/**
 * An event describing that line(s) have been inserted in a model.
 * @internal
 */
declare class ModelRawLinesInserted {
    readonly changeType = RawContentChangedType.LinesInserted;
    /**
     * Before what line did the insertion begin
     */
    readonly fromLineNumber: number;
    /**
     * `toLineNumber` - `fromLineNumber` + 1 denotes the number of lines that were inserted
     */
    readonly toLineNumber: number;
    /**
     * The text that was inserted
     */
    readonly detail: string[];
    /**
     * The injected texts for every inserted line.
     */
    readonly injectedTexts: (LineInjectedText[] | null)[];
    constructor(fromLineNumber: number, toLineNumber: number, detail: string[], injectedTexts: (LineInjectedText[] | null)[]);
}
/**
 * An event describing that a model has had its EOL changed.
 * @internal
 */
declare class ModelRawEOLChanged {
    readonly changeType = RawContentChangedType.EOLChanged;
}
/**
 * @internal
 */
declare type ModelRawChange = ModelRawFlush | ModelRawLineChanged | ModelRawLinesDeleted | ModelRawLinesInserted | ModelRawEOLChanged;
/**
 * An event describing a change in the text of a model.
 * @internal
 */
declare class ModelRawContentChangedEvent {
    readonly changes: ModelRawChange[];
    /**
     * The new version id the model has transitioned to.
     */
    readonly versionId: number;
    /**
     * Flag that indicates that this event was generated while undoing.
     */
    readonly isUndoing: boolean;
    /**
     * Flag that indicates that this event was generated while redoing.
     */
    readonly isRedoing: boolean;
    resultingSelection: Selection[] | null;
    constructor(changes: ModelRawChange[], versionId: number, isUndoing: boolean, isRedoing: boolean);
    containsEvent(type: RawContentChangedType): boolean;
    static merge(a: ModelRawContentChangedEvent, b: ModelRawContentChangedEvent): ModelRawContentChangedEvent;
}
/**
 * An event describing a change in injected text.
 * @internal
 */
declare class ModelInjectedTextChangedEvent {
    readonly changes: ModelRawLineChanged[];
    constructor(changes: ModelRawLineChanged[]);
}
/**
 * @internal
 */
declare class InternalModelContentChangeEvent {
    readonly rawContentChangedEvent: ModelRawContentChangedEvent;
    readonly contentChangedEvent: IModelContentChangedEvent;
    constructor(rawContentChangedEvent: ModelRawContentChangedEvent, contentChangedEvent: IModelContentChangedEvent);
    merge(other: InternalModelContentChangeEvent): InternalModelContentChangeEvent;
    private static _mergeChangeEvents;
}

interface IGuidesTextModelPart {
    /**
     * @internal
     */
    getActiveIndentGuide(lineNumber: number, minLineNumber: number, maxLineNumber: number): IActiveIndentGuideInfo;
    /**
     * @internal
     */
    getLinesIndentGuides(startLineNumber: number, endLineNumber: number): number[];
    /**
     * Requests the the indent guides for the given range of lines.
     * `result[i]` will contain the indent guides of the `startLineNumber + i`th line.
     * @internal
     */
    getLinesBracketGuides(startLineNumber: number, endLineNumber: number, activePosition: IPosition | null, options: BracketGuideOptions): IndentGuide[][];
}
interface IActiveIndentGuideInfo {
    startLineNumber: number;
    endLineNumber: number;
    indent: number;
}
declare enum HorizontalGuidesState {
    Disabled = 0,
    EnabledForActive = 1,
    Enabled = 2
}
interface BracketGuideOptions {
    includeInactive: boolean;
    horizontalGuides: HorizontalGuidesState;
    highlightActive: boolean;
}
declare class IndentGuide {
    readonly visibleColumn: number | -1;
    readonly column: number | -1;
    readonly className: string;
    /**
     * If set, this indent guide is a horizontal guide (no vertical part).
     * It starts at visibleColumn and continues until endColumn.
    */
    readonly horizontalLine: IndentGuideHorizontalLine | null;
    /**
     * If set (!= -1), only show this guide for wrapped lines that don't contain this model column, but are after it.
    */
    readonly forWrappedLinesAfterColumn: number | -1;
    readonly forWrappedLinesBeforeOrAtColumn: number | -1;
    constructor(visibleColumn: number | -1, column: number | -1, className: string, 
    /**
     * If set, this indent guide is a horizontal guide (no vertical part).
     * It starts at visibleColumn and continues until endColumn.
    */
    horizontalLine: IndentGuideHorizontalLine | null, 
    /**
     * If set (!= -1), only show this guide for wrapped lines that don't contain this model column, but are after it.
    */
    forWrappedLinesAfterColumn: number | -1, forWrappedLinesBeforeOrAtColumn: number | -1);
}
declare class IndentGuideHorizontalLine {
    readonly top: boolean;
    readonly endColumn: number;
    constructor(top: boolean, endColumn: number);
}

/**
 * Represents contiguous tokens over a contiguous range of lines.
 */
declare class ContiguousMultilineTokens {
    static deserialize(buff: Uint8Array, offset: number, result: ContiguousMultilineTokens[]): number;
    /**
     * The start line number for this block of tokens.
     */
    private _startLineNumber;
    /**
     * The tokens are stored in a binary format. There is an element for each line,
     * so `tokens[index]` contains all tokens on line `startLineNumber + index`.
     *
     * On a specific line, each token occupies two array indices. For token i:
     *  - at offset 2*i => endOffset
     *  - at offset 2*i + 1 => metadata
     *
     */
    private _tokens;
    /**
     * (Inclusive) start line number for these tokens.
     */
    get startLineNumber(): number;
    /**
     * (Inclusive) end line number for these tokens.
     */
    get endLineNumber(): number;
    constructor(startLineNumber: number, tokens: Uint32Array[]);
    /**
     * @see {@link _tokens}
     */
    getLineTokens(lineNumber: number): Uint32Array | ArrayBuffer | null;
    appendLineTokens(lineTokens: Uint32Array): void;
    serializeSize(): number;
    serialize(destination: Uint8Array, offset: number): number;
    applyEdit(range: IRange, text: string): void;
    private _acceptDeleteRange;
    private _acceptInsertText;
    private _insertLines;
}

/**
 * Represents sparse tokens over a contiguous range of lines.
 */
declare class SparseMultilineTokens {
    static create(startLineNumber: number, tokens: Uint32Array): SparseMultilineTokens;
    private _startLineNumber;
    private _endLineNumber;
    private readonly _tokens;
    /**
     * (Inclusive) start line number for these tokens.
     */
    get startLineNumber(): number;
    /**
     * (Inclusive) end line number for these tokens.
     */
    get endLineNumber(): number;
    private constructor();
    toString(): string;
    private _updateEndLineNumber;
    isEmpty(): boolean;
    getLineTokens(lineNumber: number): SparseLineTokens | null;
    getRange(): Range | null;
    removeTokens(range: Range): void;
    split(range: Range): [SparseMultilineTokens, SparseMultilineTokens];
    applyEdit(range: IRange, text: string): void;
    acceptEdit(range: IRange, eolCount: number, firstLineLength: number, lastLineLength: number, firstCharCode: number): void;
    private _acceptDeleteRange;
    private _acceptInsertText;
}
declare class SparseLineTokens {
    private readonly _tokens;
    constructor(tokens: Uint32Array);
    getCount(): number;
    getStartCharacter(tokenIndex: number): number;
    getEndCharacter(tokenIndex: number): number;
    getMetadata(tokenIndex: number): number;
}

/**
 * Provides tokenization related functionality of the text model.
*/
interface ITokenizationTextModelPart {
    /**
     * @internal
     */
    setTokens(tokens: ContiguousMultilineTokens[]): void;
    /**
     * Replaces all semantic tokens with the provided `tokens`.
     * @internal
     */
    setSemanticTokens(tokens: SparseMultilineTokens[] | null, isComplete: boolean): void;
    /**
     * Merges the provided semantic tokens into existing semantic tokens.
     * @internal
     */
    setPartialSemanticTokens(range: Range, tokens: SparseMultilineTokens[] | null): void;
    /**
     * @internal
     */
    hasCompleteSemanticTokens(): boolean;
    /**
     * @internal
     */
    hasSomeSemanticTokens(): boolean;
    /**
     * Flush all tokenization state.
     * @internal
     */
    resetTokenization(): void;
    /**
     * Force tokenization information for `lineNumber` to be accurate.
     * @internal
     */
    forceTokenization(lineNumber: number): void;
    /**
     * If it is cheap, force tokenization information for `lineNumber` to be accurate.
     * This is based on a heuristic.
     * @internal
     */
    tokenizeIfCheap(lineNumber: number): void;
    /**
     * Check if calling `forceTokenization` for this `lineNumber` will be cheap (time-wise).
     * This is based on a heuristic.
     * @internal
     */
    isCheapToTokenize(lineNumber: number): boolean;
    /**
     * Get the tokens for the line `lineNumber`.
     * The tokens might be inaccurate. Use `forceTokenization` to ensure accurate tokens.
     * @internal
     */
    getLineTokens(lineNumber: number): LineTokens;
    /**
    * Returns the standard token type for a character if the character were to be inserted at
    * the given position. If the result cannot be accurate, it returns null.
    * @internal
    */
    getTokenTypeIfInsertingCharacter(lineNumber: number, column: number, character: string): StandardTokenType;
    /**
     * @internal
    */
    tokenizeLineWithEdit(position: IPosition, length: number, newText: string): LineTokens | null;
    /**
     * @internal
     */
    tokenizeViewport(startLineNumber: number, endLineNumber: number): void;
    getLanguageId(): string;
    getLanguageIdAtPosition(lineNumber: number, column: number): string;
    setLanguageId(languageId: string): void;
    readonly backgroundTokenizationState: BackgroundTokenizationState;
    readonly onBackgroundTokenizationStateChanged: Event<void>;
}
declare const enum BackgroundTokenizationState {
    Uninitialized = 0,
    InProgress = 1,
    Completed = 2
}

interface ThemeColor {
    id: string;
}
declare namespace ThemeColor {
    function isThemeColor(obj: any): obj is ThemeColor;
}

/**
 * Vertical Lane in the overview ruler of the editor.
 */
declare enum OverviewRulerLane {
    Left = 1,
    Center = 2,
    Right = 4,
    Full = 7
}
/**
 * Position in the minimap to render the decoration.
 */
declare enum MinimapPosition {
    Inline = 1,
    Gutter = 2
}
interface IDecorationOptions {
    /**
     * CSS color to render.
     * e.g.: rgba(100, 100, 100, 0.5) or a color from the color registry
     */
    color: string | ThemeColor | undefined;
    /**
     * CSS color to render.
     * e.g.: rgba(100, 100, 100, 0.5) or a color from the color registry
     */
    darkColor?: string | ThemeColor;
}
/**
 * Options for rendering a model decoration in the overview ruler.
 */
interface IModelDecorationOverviewRulerOptions extends IDecorationOptions {
    /**
     * The position in the overview ruler.
     */
    position: OverviewRulerLane;
}
/**
 * Options for rendering a model decoration in the overview ruler.
 */
interface IModelDecorationMinimapOptions extends IDecorationOptions {
    /**
     * The position in the overview ruler.
     */
    position: MinimapPosition;
}
/**
 * Options for a model decoration.
 */
interface IModelDecorationOptions {
    /**
     * A debug description that can be used for inspecting model decorations.
     * @internal
     */
    description: string;
    /**
     * Customize the growing behavior of the decoration when typing at the edges of the decoration.
     * Defaults to TrackedRangeStickiness.AlwaysGrowsWhenTypingAtEdges
     */
    stickiness?: TrackedRangeStickiness;
    /**
     * CSS class name describing the decoration.
     */
    className?: string | null;
    /**
     * Message to be rendered when hovering over the glyph margin decoration.
     */
    glyphMarginHoverMessage?: IMarkdownString | IMarkdownString[] | null;
    /**
     * Array of MarkdownString to render as the decoration message.
     */
    hoverMessage?: IMarkdownString | IMarkdownString[] | null;
    /**
     * Should the decoration expand to encompass a whole line.
     */
    isWholeLine?: boolean;
    /**
     * Always render the decoration (even when the range it encompasses is collapsed).
     * @internal
     */
    showIfCollapsed?: boolean;
    /**
     * Collapse the decoration if its entire range is being replaced via an edit.
     * @internal
     */
    collapseOnReplaceEdit?: boolean;
    /**
     * Specifies the stack order of a decoration.
     * A decoration with greater stack order is always in front of a decoration with
     * a lower stack order when the decorations are on the same line.
     */
    zIndex?: number;
    /**
     * If set, render this decoration in the overview ruler.
     */
    overviewRuler?: IModelDecorationOverviewRulerOptions | null;
    /**
     * If set, render this decoration in the minimap.
     */
    minimap?: IModelDecorationMinimapOptions | null;
    /**
     * If set, the decoration will be rendered in the glyph margin with this CSS class name.
     */
    glyphMarginClassName?: string | null;
    /**
     * If set, the decoration will be rendered in the lines decorations with this CSS class name.
     */
    linesDecorationsClassName?: string | null;
    /**
     * If set, the decoration will be rendered in the lines decorations with this CSS class name, but only for the first line in case of line wrapping.
     */
    firstLineDecorationClassName?: string | null;
    /**
     * If set, the decoration will be rendered in the margin (covering its full width) with this CSS class name.
     */
    marginClassName?: string | null;
    /**
     * If set, the decoration will be rendered inline with the text with this CSS class name.
     * Please use this only for CSS rules that must impact the text. For example, use `className`
     * to have a background color decoration.
     */
    inlineClassName?: string | null;
    /**
     * If there is an `inlineClassName` which affects letter spacing.
     */
    inlineClassNameAffectsLetterSpacing?: boolean;
    /**
     * If set, the decoration will be rendered before the text with this CSS class name.
     */
    beforeContentClassName?: string | null;
    /**
     * If set, the decoration will be rendered after the text with this CSS class name.
     */
    afterContentClassName?: string | null;
    /**
     * If set, text will be injected in the view after the range.
     */
    after?: InjectedTextOptions | null;
    /**
     * If set, text will be injected in the view before the range.
     */
    before?: InjectedTextOptions | null;
    /**
     * If set, this decoration will not be rendered for comment tokens.
     * @internal
    */
    hideInCommentTokens?: boolean | null;
    /**
     * If set, this decoration will not be rendered for string tokens.
     * @internal
    */
    hideInStringTokens?: boolean | null;
}
/**
 * Configures text that is injected into the view without changing the underlying document.
*/
interface InjectedTextOptions {
    /**
     * Sets the text to inject. Must be a single line.
     */
    readonly content: string;
    /**
     * If set, the decoration will be rendered inline with the text with this CSS class name.
     */
    readonly inlineClassName?: string | null;
    /**
     * If there is an `inlineClassName` which affects letter spacing.
     */
    readonly inlineClassNameAffectsLetterSpacing?: boolean;
    /**
     * This field allows to attach data to this injected text.
     * The data can be read when injected texts at a given position are queried.
     */
    readonly attachedData?: unknown;
    /**
     * Configures cursor stops around injected text.
     * Defaults to {@link InjectedTextCursorStops.Both}.
    */
    readonly cursorStops?: InjectedTextCursorStops | null;
}
declare enum InjectedTextCursorStops {
    Both = 0,
    Right = 1,
    Left = 2,
    None = 3
}
/**
 * New model decorations.
 */
interface IModelDeltaDecoration {
    /**
     * Range that this decoration covers.
     */
    range: IRange;
    /**
     * Options associated with this decoration.
     */
    options: IModelDecorationOptions;
}
/**
 * A decoration in the model.
 */
interface IModelDecoration {
    /**
     * Identifier for a decoration.
     */
    readonly id: string;
    /**
     * Identifier for a decoration's owner.
     */
    readonly ownerId: number;
    /**
     * Range that this decoration covers.
     */
    readonly range: Range;
    /**
     * Options associated with this decoration.
     */
    readonly options: IModelDecorationOptions;
}
/**
 * An accessor that can add, change or remove model decorations.
 * @internal
 */
interface IModelDecorationsChangeAccessor {
    /**
     * Add a new decoration.
     * @param range Range that this decoration covers.
     * @param options Options associated with this decoration.
     * @return An unique identifier associated with this decoration.
     */
    addDecoration(range: IRange, options: IModelDecorationOptions): string;
    /**
     * Change the range that an existing decoration covers.
     * @param id The unique identifier associated with the decoration.
     * @param newRange The new range that this decoration covers.
     */
    changeDecoration(id: string, newRange: IRange): void;
    /**
     * Change the options associated with an existing decoration.
     * @param id The unique identifier associated with the decoration.
     * @param newOptions The new options associated with this decoration.
     */
    changeDecorationOptions(id: string, newOptions: IModelDecorationOptions): void;
    /**
     * Remove an existing decoration.
     * @param id The unique identifier associated with the decoration.
     */
    removeDecoration(id: string): void;
    /**
     * Perform a minimum amount of operations, in order to transform the decorations
     * identified by `oldDecorations` to the decorations described by `newDecorations`
     * and returns the new identifiers associated with the resulting decorations.
     *
     * @param oldDecorations Array containing previous decorations identifiers.
     * @param newDecorations Array describing what decorations should result after the call.
     * @return An array containing the new decorations identifiers.
     */
    deltaDecorations(oldDecorations: string[], newDecorations: IModelDeltaDecoration[]): string[];
}
/**
 * End of line character preference.
 */
declare const enum EndOfLinePreference {
    /**
     * Use the end of line character identified in the text buffer.
     */
    TextDefined = 0,
    /**
     * Use line feed (\n) as the end of line character.
     */
    LF = 1,
    /**
     * Use carriage return and line feed (\r\n) as the end of line character.
     */
    CRLF = 2
}
/**
 * The default end of line to use when instantiating models.
 */
declare const enum DefaultEndOfLine {
    /**
     * Use line feed (\n) as the end of line character.
     */
    LF = 1,
    /**
     * Use carriage return and line feed (\r\n) as the end of line character.
     */
    CRLF = 2
}
/**
 * End of line character preference.
 */
declare const enum EndOfLineSequence {
    /**
     * Use line feed (\n) as the end of line character.
     */
    LF = 0,
    /**
     * Use carriage return and line feed (\r\n) as the end of line character.
     */
    CRLF = 1
}
/**
 * An identifier for a single edit operation.
 * @internal
 */
interface ISingleEditOperationIdentifier {
    /**
     * Identifier major
     */
    major: number;
    /**
     * Identifier minor
     */
    minor: number;
}
/**
 * A single edit operation, that has an identifier.
 */
interface IIdentifiedSingleEditOperation extends ISingleEditOperation {
    /**
     * An identifier associated with this single edit operation.
     * @internal
     */
    identifier?: ISingleEditOperationIdentifier | null;
    /**
     * This indicates that this operation is inserting automatic whitespace
     * that can be removed on next model edit operation if `config.trimAutoWhitespace` is true.
     * @internal
     */
    isAutoWhitespaceEdit?: boolean;
    /**
     * This indicates that this operation is in a set of operations that are tracked and should not be "simplified".
     * @internal
     */
    _isTracked?: boolean;
}
interface IValidEditOperation {
    /**
     * An identifier associated with this single edit operation.
     * @internal
     */
    identifier: ISingleEditOperationIdentifier | null;
    /**
     * The range to replace. This can be empty to emulate a simple insert.
     */
    range: Range;
    /**
     * The text to replace with. This can be empty to emulate a simple delete.
     */
    text: string;
    /**
     * @internal
     */
    textChange: TextChange;
}
/**
 * A callback that can compute the cursor state after applying a series of edit operations.
 */
interface ICursorStateComputer {
    /**
     * A callback that can compute the resulting cursors state after some edit operations have been executed.
     */
    (inverseEditOperations: IValidEditOperation[]): Selection[] | null;
}
declare class TextModelResolvedOptions {
    _textModelResolvedOptionsBrand: void;
    readonly tabSize: number;
    readonly indentSize: number;
    readonly insertSpaces: boolean;
    readonly defaultEOL: DefaultEndOfLine;
    readonly trimAutoWhitespace: boolean;
    readonly bracketPairColorizationOptions: BracketPairColorizationOptions;
    /**
     * @internal
     */
    constructor(src: {
        tabSize: number;
        indentSize: number;
        insertSpaces: boolean;
        defaultEOL: DefaultEndOfLine;
        trimAutoWhitespace: boolean;
        bracketPairColorizationOptions: BracketPairColorizationOptions;
    });
    /**
     * @internal
     */
    equals(other: TextModelResolvedOptions): boolean;
    /**
     * @internal
     */
    createChangeEvent(newOpts: TextModelResolvedOptions): IModelOptionsChangedEvent;
}
interface BracketPairColorizationOptions {
    enabled: boolean;
    independentColorPoolPerBracketType: boolean;
}
interface ITextModelUpdateOptions {
    tabSize?: number;
    indentSize?: number;
    insertSpaces?: boolean;
    trimAutoWhitespace?: boolean;
    bracketColorizationOptions?: BracketPairColorizationOptions;
}
declare class FindMatch {
    _findMatchBrand: void;
    readonly range: Range;
    readonly matches: string[] | null;
    /**
     * @internal
     */
    constructor(range: Range, matches: string[] | null);
}
/**
 * Describes the behavior of decorations when typing/editing near their edges.
 * Note: Please do not edit the values, as they very carefully match `DecorationRangeBehavior`
 */
declare const enum TrackedRangeStickiness {
    AlwaysGrowsWhenTypingAtEdges = 0,
    NeverGrowsWhenTypingAtEdges = 1,
    GrowsOnlyWhenTypingBefore = 2,
    GrowsOnlyWhenTypingAfter = 3
}
/**
 * Text snapshot that works like an iterator.
 * Will try to return chunks of roughly ~64KB size.
 * Will return null when finished.
 *
 * @internal
 */
interface ITextSnapshot {
    read(): string | null;
}
/**
 * A model.
 */
interface ITextModel {
    /**
     * Gets the resource associated with this editor model.
     */
    readonly uri: URI;
    /**
     * A unique identifier associated with this model.
     */
    readonly id: string;
    /**
     * This model is constructed for a simple widget code editor.
     * @internal
     */
    readonly isForSimpleWidget: boolean;
    /**
     * If true, the text model might contain RTL.
     * If false, the text model **contains only** contain LTR.
     * @internal
     */
    mightContainRTL(): boolean;
    /**
     * If true, the text model might contain LINE SEPARATOR (LS), PARAGRAPH SEPARATOR (PS).
     * If false, the text model definitely does not contain these.
     * @internal
     */
    mightContainUnusualLineTerminators(): boolean;
    /**
     * @internal
     */
    removeUnusualLineTerminators(selections?: Selection[]): void;
    /**
     * If true, the text model might contain non basic ASCII.
     * If false, the text model **contains only** basic ASCII.
     * @internal
     */
    mightContainNonBasicASCII(): boolean;
    /**
     * Get the resolved options for this model.
     */
    getOptions(): TextModelResolvedOptions;
    /**
     * Get the formatting options for this model.
     * @internal
     */
    getFormattingOptions(): FormattingOptions;
    /**
     * Get the current version id of the model.
     * Anytime a change happens to the model (even undo/redo),
     * the version id is incremented.
     */
    getVersionId(): number;
    /**
     * Get the alternative version id of the model.
     * This alternative version id is not always incremented,
     * it will return the same values in the case of undo-redo.
     */
    getAlternativeVersionId(): number;
    /**
     * Replace the entire text buffer value contained in this model.
     */
    setValue(newValue: string): void;
    /**
     * Get the text stored in this model.
     * @param eol The end of line character preference. Defaults to `EndOfLinePreference.TextDefined`.
     * @param preserverBOM Preserve a BOM character if it was detected when the model was constructed.
     * @return The text.
     */
    getValue(eol?: EndOfLinePreference, preserveBOM?: boolean): string;
    /**
     * Get the text stored in this model.
     * @param preserverBOM Preserve a BOM character if it was detected when the model was constructed.
     * @return The text snapshot (it is safe to consume it asynchronously).
     * @internal
     */
    createSnapshot(preserveBOM?: boolean): ITextSnapshot;
    /**
     * Get the length of the text stored in this model.
     */
    getValueLength(eol?: EndOfLinePreference, preserveBOM?: boolean): number;
    /**
     * Check if the raw text stored in this model equals another raw text.
     * @internal
     */
    equalsTextBuffer(other: ITextBuffer): boolean;
    /**
     * Get the underling text buffer.
     * @internal
     */
    getTextBuffer(): ITextBuffer;
    /**
     * Get the text in a certain range.
     * @param range The range describing what text to get.
     * @param eol The end of line character preference. This will only be used for multiline ranges. Defaults to `EndOfLinePreference.TextDefined`.
     * @return The text.
     */
    getValueInRange(range: IRange, eol?: EndOfLinePreference): string;
    /**
     * Get the length of text in a certain range.
     * @param range The range describing what text length to get.
     * @return The text length.
     */
    getValueLengthInRange(range: IRange): number;
    /**
     * Get the character count of text in a certain range.
     * @param range The range describing what text length to get.
     */
    getCharacterCountInRange(range: IRange): number;
    /**
     * Splits characters in two buckets. First bucket (A) is of characters that
     * sit in lines with length < `LONG_LINE_BOUNDARY`. Second bucket (B) is of
     * characters that sit in lines with length >= `LONG_LINE_BOUNDARY`.
     * If count(B) > count(A) return true. Returns false otherwise.
     * @internal
     */
    isDominatedByLongLines(): boolean;
    /**
     * Get the number of lines in the model.
     */
    getLineCount(): number;
    /**
     * Get the text for a certain line.
     */
    getLineContent(lineNumber: number): string;
    /**
     * Get the text length for a certain line.
     */
    getLineLength(lineNumber: number): number;
    /**
     * Get the text for all lines.
     */
    getLinesContent(): string[];
    /**
     * Get the end of line sequence predominantly used in the text buffer.
     * @return EOL char sequence (e.g.: '\n' or '\r\n').
     */
    getEOL(): string;
    /**
     * Get the end of line sequence predominantly used in the text buffer.
     */
    getEndOfLineSequence(): EndOfLineSequence;
    /**
     * Get the minimum legal column for line at `lineNumber`
     */
    getLineMinColumn(lineNumber: number): number;
    /**
     * Get the maximum legal column for line at `lineNumber`
     */
    getLineMaxColumn(lineNumber: number): number;
    /**
     * Returns the column before the first non whitespace character for line at `lineNumber`.
     * Returns 0 if line is empty or contains only whitespace.
     */
    getLineFirstNonWhitespaceColumn(lineNumber: number): number;
    /**
     * Returns the column after the last non whitespace character for line at `lineNumber`.
     * Returns 0 if line is empty or contains only whitespace.
     */
    getLineLastNonWhitespaceColumn(lineNumber: number): number;
    /**
     * Create a valid position.
     */
    validatePosition(position: IPosition): Position;
    /**
     * Advances the given position by the given offset (negative offsets are also accepted)
     * and returns it as a new valid position.
     *
     * If the offset and position are such that their combination goes beyond the beginning or
     * end of the model, throws an exception.
     *
     * If the offset is such that the new position would be in the middle of a multi-byte
     * line terminator, throws an exception.
     */
    modifyPosition(position: IPosition, offset: number): Position;
    /**
     * Create a valid range.
     */
    validateRange(range: IRange): Range;
    /**
     * Converts the position to a zero-based offset.
     *
     * The position will be [adjusted](#TextDocument.validatePosition).
     *
     * @param position A position.
     * @return A valid zero-based offset.
     */
    getOffsetAt(position: IPosition): number;
    /**
     * Converts a zero-based offset to a position.
     *
     * @param offset A zero-based offset.
     * @return A valid [position](#Position).
     */
    getPositionAt(offset: number): Position;
    /**
     * Get a range covering the entire model.
     */
    getFullModelRange(): Range;
    /**
     * Returns if the model was disposed or not.
     */
    isDisposed(): boolean;
    /**
     * This model is so large that it would not be a good idea to sync it over
     * to web workers or other places.
     * @internal
     */
    isTooLargeForSyncing(): boolean;
    /**
     * The file is so large, that even tokenization is disabled.
     * @internal
     */
    isTooLargeForTokenization(): boolean;
    /**
     * Search the model.
     * @param searchString The string used to search. If it is a regular expression, set `isRegex` to true.
     * @param searchOnlyEditableRange Limit the searching to only search inside the editable range of the model.
     * @param isRegex Used to indicate that `searchString` is a regular expression.
     * @param matchCase Force the matching to match lower/upper case exactly.
     * @param wordSeparators Force the matching to match entire words only. Pass null otherwise.
     * @param captureMatches The result will contain the captured groups.
     * @param limitResultCount Limit the number of results
     * @return The ranges where the matches are. It is empty if not matches have been found.
     */
    findMatches(searchString: string, searchOnlyEditableRange: boolean, isRegex: boolean, matchCase: boolean, wordSeparators: string | null, captureMatches: boolean, limitResultCount?: number): FindMatch[];
    /**
     * Search the model.
     * @param searchString The string used to search. If it is a regular expression, set `isRegex` to true.
     * @param searchScope Limit the searching to only search inside these ranges.
     * @param isRegex Used to indicate that `searchString` is a regular expression.
     * @param matchCase Force the matching to match lower/upper case exactly.
     * @param wordSeparators Force the matching to match entire words only. Pass null otherwise.
     * @param captureMatches The result will contain the captured groups.
     * @param limitResultCount Limit the number of results
     * @return The ranges where the matches are. It is empty if no matches have been found.
     */
    findMatches(searchString: string, searchScope: IRange | IRange[], isRegex: boolean, matchCase: boolean, wordSeparators: string | null, captureMatches: boolean, limitResultCount?: number): FindMatch[];
    /**
     * Search the model for the next match. Loops to the beginning of the model if needed.
     * @param searchString The string used to search. If it is a regular expression, set `isRegex` to true.
     * @param searchStart Start the searching at the specified position.
     * @param isRegex Used to indicate that `searchString` is a regular expression.
     * @param matchCase Force the matching to match lower/upper case exactly.
     * @param wordSeparators Force the matching to match entire words only. Pass null otherwise.
     * @param captureMatches The result will contain the captured groups.
     * @return The range where the next match is. It is null if no next match has been found.
     */
    findNextMatch(searchString: string, searchStart: IPosition, isRegex: boolean, matchCase: boolean, wordSeparators: string | null, captureMatches: boolean): FindMatch | null;
    /**
     * Search the model for the previous match. Loops to the end of the model if needed.
     * @param searchString The string used to search. If it is a regular expression, set `isRegex` to true.
     * @param searchStart Start the searching at the specified position.
     * @param isRegex Used to indicate that `searchString` is a regular expression.
     * @param matchCase Force the matching to match lower/upper case exactly.
     * @param wordSeparators Force the matching to match entire words only. Pass null otherwise.
     * @param captureMatches The result will contain the captured groups.
     * @return The range where the previous match is. It is null if no previous match has been found.
     */
    findPreviousMatch(searchString: string, searchStart: IPosition, isRegex: boolean, matchCase: boolean, wordSeparators: string | null, captureMatches: boolean): FindMatch | null;
    /**
     * Get the language associated with this model.
     */
    getLanguageId(): string;
    /**
     * Set the current language mode associated with the model.
     * @internal
     */
    setMode(languageId: string): void;
    /**
     * Returns the real (inner-most) language mode at a given position.
     * The result might be inaccurate. Use `forceTokenization` to ensure accurate tokens.
     * @internal
     */
    getLanguageIdAtPosition(lineNumber: number, column: number): string;
    /**
     * Get the word under or besides `position`.
     * @param position The position to look for a word.
     * @return The word under or besides `position`. Might be null.
     */
    getWordAtPosition(position: IPosition): IWordAtPosition | null;
    /**
     * Get the word under or besides `position` trimmed to `position`.column
     * @param position The position to look for a word.
     * @return The word under or besides `position`. Will never be null.
     */
    getWordUntilPosition(position: IPosition): IWordAtPosition;
    /**
     * Change the decorations. The callback will be called with a change accessor
     * that becomes invalid as soon as the callback finishes executing.
     * This allows for all events to be queued up until the change
     * is completed. Returns whatever the callback returns.
     * @param ownerId Identifies the editor id in which these decorations should appear. If no `ownerId` is provided, the decorations will appear in all editors that attach this model.
     * @internal
     */
    changeDecorations<T>(callback: (changeAccessor: IModelDecorationsChangeAccessor) => T, ownerId?: number): T | null;
    /**
     * Perform a minimum amount of operations, in order to transform the decorations
     * identified by `oldDecorations` to the decorations described by `newDecorations`
     * and returns the new identifiers associated with the resulting decorations.
     *
     * @param oldDecorations Array containing previous decorations identifiers.
     * @param newDecorations Array describing what decorations should result after the call.
     * @param ownerId Identifies the editor id in which these decorations should appear. If no `ownerId` is provided, the decorations will appear in all editors that attach this model.
     * @return An array containing the new decorations identifiers.
     */
    deltaDecorations(oldDecorations: string[], newDecorations: IModelDeltaDecoration[], ownerId?: number): string[];
    /**
     * Remove all decorations that have been added with this specific ownerId.
     * @param ownerId The owner id to search for.
     * @internal
     */
    removeAllDecorationsWithOwnerId(ownerId: number): void;
    /**
     * Get the options associated with a decoration.
     * @param id The decoration id.
     * @return The decoration options or null if the decoration was not found.
     */
    getDecorationOptions(id: string): IModelDecorationOptions | null;
    /**
     * Get the range associated with a decoration.
     * @param id The decoration id.
     * @return The decoration range or null if the decoration was not found.
     */
    getDecorationRange(id: string): Range | null;
    /**
     * Gets all the decorations for the line `lineNumber` as an array.
     * @param lineNumber The line number
     * @param ownerId If set, it will ignore decorations belonging to other owners.
     * @param filterOutValidation If set, it will ignore decorations specific to validation (i.e. warnings, errors).
     * @return An array with the decorations
     */
    getLineDecorations(lineNumber: number, ownerId?: number, filterOutValidation?: boolean): IModelDecoration[];
    /**
     * Gets all the decorations for the lines between `startLineNumber` and `endLineNumber` as an array.
     * @param startLineNumber The start line number
     * @param endLineNumber The end line number
     * @param ownerId If set, it will ignore decorations belonging to other owners.
     * @param filterOutValidation If set, it will ignore decorations specific to validation (i.e. warnings, errors).
     * @return An array with the decorations
     */
    getLinesDecorations(startLineNumber: number, endLineNumber: number, ownerId?: number, filterOutValidation?: boolean): IModelDecoration[];
    /**
     * Gets all the decorations in a range as an array. Only `startLineNumber` and `endLineNumber` from `range` are used for filtering.
     * So for now it returns all the decorations on the same line as `range`.
     * @param range The range to search in
     * @param ownerId If set, it will ignore decorations belonging to other owners.
     * @param filterOutValidation If set, it will ignore decorations specific to validation (i.e. warnings, errors).
     * @return An array with the decorations
     */
    getDecorationsInRange(range: IRange, ownerId?: number, filterOutValidation?: boolean): IModelDecoration[];
    /**
     * Gets all the decorations as an array.
     * @param ownerId If set, it will ignore decorations belonging to other owners.
     * @param filterOutValidation If set, it will ignore decorations specific to validation (i.e. warnings, errors).
     */
    getAllDecorations(ownerId?: number, filterOutValidation?: boolean): IModelDecoration[];
    /**
     * Gets all the decorations that should be rendered in the overview ruler as an array.
     * @param ownerId If set, it will ignore decorations belonging to other owners.
     * @param filterOutValidation If set, it will ignore decorations specific to validation (i.e. warnings, errors).
     */
    getOverviewRulerDecorations(ownerId?: number, filterOutValidation?: boolean): IModelDecoration[];
    /**
     * Gets all the decorations that contain injected text.
     * @param ownerId If set, it will ignore decorations belonging to other owners.
     */
    getInjectedTextDecorations(ownerId?: number): IModelDecoration[];
    /**
     * @internal
     */
    _getTrackedRange(id: string): Range | null;
    /**
     * @internal
     */
    _setTrackedRange(id: string | null, newRange: null, newStickiness: TrackedRangeStickiness): null;
    /**
     * @internal
     */
    _setTrackedRange(id: string | null, newRange: Range, newStickiness: TrackedRangeStickiness): string;
    /**
     * Normalize a string containing whitespace according to indentation rules (converts to spaces or to tabs).
     */
    normalizeIndentation(str: string): string;
    /**
     * Change the options of this model.
     */
    updateOptions(newOpts: ITextModelUpdateOptions): void;
    /**
     * Detect the indentation options for this model from its content.
     */
    detectIndentation(defaultInsertSpaces: boolean, defaultTabSize: number): void;
    /**
     * Close the current undo-redo element.
     * This offers a way to create an undo/redo stop point.
     */
    pushStackElement(): void;
    /**
     * Open the current undo-redo element.
     * This offers a way to remove the current undo/redo stop point.
     */
    popStackElement(): void;
    /**
     * Push edit operations, basically editing the model. This is the preferred way
     * of editing the model. The edit operations will land on the undo stack.
     * @param beforeCursorState The cursor state before the edit operations. This cursor state will be returned when `undo` or `redo` are invoked.
     * @param editOperations The edit operations.
     * @param cursorStateComputer A callback that can compute the resulting cursors state after the edit operations have been executed.
     * @return The cursor state returned by the `cursorStateComputer`.
     */
    pushEditOperations(beforeCursorState: Selection[] | null, editOperations: IIdentifiedSingleEditOperation[], cursorStateComputer: ICursorStateComputer): Selection[] | null;
    /**
     * Change the end of line sequence. This is the preferred way of
     * changing the eol sequence. This will land on the undo stack.
     */
    pushEOL(eol: EndOfLineSequence): void;
    /**
     * Edit the model without adding the edits to the undo stack.
     * This can have dire consequences on the undo stack! See @pushEditOperations for the preferred way.
     * @param operations The edit operations.
     * @return If desired, the inverse edit operations, that, when applied, will bring the model back to the previous state.
     */
    applyEdits(operations: IIdentifiedSingleEditOperation[]): void;
    applyEdits(operations: IIdentifiedSingleEditOperation[], computeUndoEdits: false): void;
    applyEdits(operations: IIdentifiedSingleEditOperation[], computeUndoEdits: true): IValidEditOperation[];
    /**
     * Change the end of line sequence without recording in the undo stack.
     * This can have dire consequences on the undo stack! See @pushEOL for the preferred way.
     */
    setEOL(eol: EndOfLineSequence): void;
    /**
     * @internal
     */
    _applyUndo(changes: TextChange[], eol: EndOfLineSequence, resultingAlternativeVersionId: number, resultingSelection: Selection[] | null): void;
    /**
     * @internal
     */
    _applyRedo(changes: TextChange[], eol: EndOfLineSequence, resultingAlternativeVersionId: number, resultingSelection: Selection[] | null): void;
    /**
     * Undo edit operations until the previous undo/redo point.
     * The inverse edit operations will be pushed on the redo stack.
     * @internal
     */
    undo(): void | Promise<void>;
    /**
     * Is there anything in the undo stack?
     * @internal
     */
    canUndo(): boolean;
    /**
     * Redo edit operations until the next undo/redo point.
     * The inverse edit operations will be pushed on the undo stack.
     * @internal
     */
    redo(): void | Promise<void>;
    /**
     * Is there anything in the redo stack?
     * @internal
     */
    canRedo(): boolean;
    /**
     * @deprecated Please use `onDidChangeContent` instead.
     * An event emitted when the contents of the model have changed.
     * @internal
     * @event
     */
    readonly onDidChangeContentOrInjectedText: Event<InternalModelContentChangeEvent | ModelInjectedTextChangedEvent>;
    /**
     * An event emitted when the contents of the model have changed.
     * @event
     */
    onDidChangeContent(listener: (e: IModelContentChangedEvent) => void): IDisposable;
    /**
     * An event emitted when decorations of the model have changed.
     * @event
     */
    readonly onDidChangeDecorations: Event<IModelDecorationsChangedEvent>;
    /**
     * An event emitted when the model options have changed.
     * @event
     */
    readonly onDidChangeOptions: Event<IModelOptionsChangedEvent>;
    /**
     * An event emitted when the language associated with the model has changed.
     * @event
     */
    readonly onDidChangeLanguage: Event<IModelLanguageChangedEvent>;
    /**
     * An event emitted when the language configuration associated with the model has changed.
     * @event
     */
    readonly onDidChangeLanguageConfiguration: Event<IModelLanguageConfigurationChangedEvent>;
    /**
     * An event emitted when the tokens associated with the model have changed.
     * @event
     * @internal
     */
    readonly onDidChangeTokens: Event<IModelTokensChangedEvent>;
    /**
     * An event emitted when the model has been attached to the first editor or detached from the last editor.
     * @event
     */
    readonly onDidChangeAttached: Event<void>;
    /**
     * An event emitted right before disposing the model.
     * @event
     */
    readonly onWillDispose: Event<void>;
    /**
     * Destroy this model.
     */
    dispose(): void;
    /**
     * @internal
     */
    onBeforeAttached(): void;
    /**
     * @internal
     */
    onBeforeDetached(): void;
    /**
     * Returns if this model is attached to an editor or not.
     */
    isAttachedToEditor(): boolean;
    /**
     * Returns the count of editors this model is attached to.
     * @internal
     */
    getAttachedEditorCount(): number;
    /**
     * Among all positions that are projected to the same position in the underlying text model as
     * the given position, select a unique position as indicated by the affinity.
     *
     * PositionAffinity.Left:
     * The normalized position must be equal or left to the requested position.
     *
     * PositionAffinity.Right:
     * The normalized position must be equal or right to the requested position.
     *
     * @internal
     */
    normalizePosition(position: Position, affinity: PositionAffinity): Position;
    /**
     * Gets the column at which indentation stops at a given line.
     * @internal
    */
    getLineIndentColumn(lineNumber: number): number;
    /**
     * Returns an object that can be used to query brackets.
     * @internal
    */
    readonly bracketPairs: IBracketPairsTextModelPart;
    /**
     * Returns an object that can be used to query indent guides.
     * @internal
    */
    readonly guides: IGuidesTextModelPart;
    /**
     * @internal
     */
    readonly tokenization: ITokenizationTextModelPart;
}
declare const enum PositionAffinity {
    /**
     * Prefers the left most position.
    */
    Left = 0,
    /**
     * Prefers the right most position.
    */
    Right = 1,
    /**
     * No preference.
    */
    None = 2,
    /**
     * If the given position is on injected text, prefers the position left of it.
    */
    LeftOfInjectedText = 3,
    /**
     * If the given position is on injected text, prefers the position right of it.
    */
    RightOfInjectedText = 4
}
/**
 * @internal
 */
declare class ValidAnnotatedEditOperation implements IIdentifiedSingleEditOperation {
    readonly identifier: ISingleEditOperationIdentifier | null;
    readonly range: Range;
    readonly text: string | null;
    readonly forceMoveMarkers: boolean;
    readonly isAutoWhitespaceEdit: boolean;
    readonly _isTracked: boolean;
    constructor(identifier: ISingleEditOperationIdentifier | null, range: Range, text: string | null, forceMoveMarkers: boolean, isAutoWhitespaceEdit: boolean, _isTracked: boolean);
}
/**
 * @internal
 *
 * `lineNumber` is 1 based.
 */
interface IReadonlyTextBuffer {
    onDidChangeContent: Event<void>;
    equals(other: ITextBuffer): boolean;
    mightContainRTL(): boolean;
    mightContainUnusualLineTerminators(): boolean;
    resetMightContainUnusualLineTerminators(): void;
    mightContainNonBasicASCII(): boolean;
    getBOM(): string;
    getEOL(): string;
    getOffsetAt(lineNumber: number, column: number): number;
    getPositionAt(offset: number): Position;
    getRangeAt(offset: number, length: number): Range;
    getValueInRange(range: Range, eol: EndOfLinePreference): string;
    createSnapshot(preserveBOM: boolean): ITextSnapshot;
    getValueLengthInRange(range: Range, eol: EndOfLinePreference): number;
    getCharacterCountInRange(range: Range, eol: EndOfLinePreference): number;
    getLength(): number;
    getLineCount(): number;
    getLinesContent(): string[];
    getLineContent(lineNumber: number): string;
    getLineCharCode(lineNumber: number, index: number): number;
    getCharCode(offset: number): number;
    getLineLength(lineNumber: number): number;
    getLineFirstNonWhitespaceColumn(lineNumber: number): number;
    getLineLastNonWhitespaceColumn(lineNumber: number): number;
    findMatchesLineByLine(searchRange: Range, searchData: SearchData, captureMatches: boolean, limitResultCount: number): FindMatch[];
}
/**
 * @internal
 */
declare class SearchData {
    /**
     * The regex to search for. Always defined.
     */
    readonly regex: RegExp;
    /**
     * The word separator classifier.
     */
    readonly wordSeparators: WordCharacterClassifier | null;
    /**
     * The simple string to search for (if possible).
     */
    readonly simpleSearch: string | null;
    constructor(regex: RegExp, wordSeparators: WordCharacterClassifier | null, simpleSearch: string | null);
}
/**
 * @internal
 */
interface ITextBuffer extends IReadonlyTextBuffer {
    setEOL(newEOL: '\r\n' | '\n'): void;
    applyEdits(rawOperations: ValidAnnotatedEditOperation[], recordTrimAutoWhitespace: boolean, computeUndoEdits: boolean): ApplyEditsResult;
}
/**
 * @internal
 */
declare class ApplyEditsResult {
    readonly reverseEdits: IValidEditOperation[] | null;
    readonly changes: IInternalModelContentChange[];
    readonly trimAutoWhitespaceLineNumbers: number[] | null;
    constructor(reverseEdits: IValidEditOperation[] | null, changes: IInternalModelContentChange[], trimAutoWhitespaceLineNumbers: number[] | null);
}
/**
 * @internal
 */
interface IInternalModelContentChange extends IModelContentChange {
    range: Range;
    forceMoveMarkers: boolean;
}

/**
 * @internal
 */
interface ILanguageIdCodec {
    encodeLanguageId(languageId: string): LanguageId;
    decodeLanguageId(languageId: LanguageId): string;
}
/**
 * A provider result represents the values a provider, like the {@link HoverProvider},
 * may return. For once this is the actual result type `T`, like `Hover`, or a thenable that resolves
 * to that type `T`. In addition, `null` and `undefined` can be returned - either directly or from a
 * thenable.
 */
declare type ProviderResult<T> = T | undefined | null | Thenable<T | undefined | null>;
/**
 * An evaluatable expression represents additional information for an expression in a document. Evaluatable expressions are
 * evaluated by a debugger or runtime and their result is rendered in a tooltip-like widget.
 * @internal
 */
interface EvaluatableExpression {
    /**
     * The range to which this expression applies.
     */
    range: IRange;
    /**
     * This expression overrides the expression extracted from the range.
     */
    expression?: string;
}
/**
 * The evaluatable expression provider interface defines the contract between extensions and
 * the debug hover.
 * @internal
 */
interface EvaluatableExpressionProvider {
    /**
     * Provide a hover for the given position and document. Multiple hovers at the same
     * position will be merged by the editor. A hover can have a range which defaults
     * to the word range at the position when omitted.
     */
    provideEvaluatableExpression(model: ITextModel, position: Position, token: CancellationToken): ProviderResult<EvaluatableExpression>;
}
/**
 * Represents a location inside a resource, such as a line
 * inside a text file.
 */
interface Location {
    /**
     * The resource identifier of this location.
     */
    uri: URI;
    /**
     * The document range of this locations.
     */
    range: IRange;
}
/**
 * A symbol kind.
 */
declare const enum SymbolKind {
    File = 0,
    Module = 1,
    Namespace = 2,
    Package = 3,
    Class = 4,
    Method = 5,
    Property = 6,
    Field = 7,
    Constructor = 8,
    Enum = 9,
    Interface = 10,
    Function = 11,
    Variable = 12,
    Constant = 13,
    String = 14,
    Number = 15,
    Boolean = 16,
    Array = 17,
    Object = 18,
    Key = 19,
    Null = 20,
    EnumMember = 21,
    Struct = 22,
    Event = 23,
    Operator = 24,
    TypeParameter = 25
}
declare const enum SymbolTag {
    Deprecated = 1
}
/**
 * Interface used to format a model
 */
interface FormattingOptions {
    /**
     * Size of a tab in spaces.
     */
    tabSize: number;
    /**
     * Prefer spaces over tabs.
     */
    insertSpaces: boolean;
}

interface CallHierarchyItem {
    _sessionId: string;
    _itemId: string;
    kind: SymbolKind;
    name: string;
    detail?: string;
    uri: URI;
    range: IRange;
    selectionRange: IRange;
    tags?: SymbolTag[];
}
interface IncomingCall {
    from: CallHierarchyItem;
    fromRanges: IRange[];
}
interface OutgoingCall {
    fromRanges: IRange[];
    to: CallHierarchyItem;
}
interface CallHierarchySession {
    roots: CallHierarchyItem[];
    dispose(): void;
}
interface CallHierarchyProvider {
    prepareCallHierarchy(document: ITextModel, position: IPosition, token: CancellationToken): ProviderResult<CallHierarchySession>;
    provideIncomingCalls(item: CallHierarchyItem, token: CancellationToken): ProviderResult<IncomingCall[]>;
    provideOutgoingCalls(item: CallHierarchyItem, token: CancellationToken): ProviderResult<OutgoingCall[]>;
}

interface TypeHierarchyItem {
    _sessionId: string;
    _itemId: string;
    kind: SymbolKind;
    name: string;
    detail?: string;
    uri: URI;
    range: IRange;
    selectionRange: IRange;
    tags?: SymbolTag[];
}
interface TypeHierarchySession {
    roots: TypeHierarchyItem[];
    dispose(): void;
}
interface TypeHierarchyProvider {
    prepareTypeHierarchy(document: ITextModel, position: IPosition, token: CancellationToken): ProviderResult<TypeHierarchySession>;
    provideSupertypes(item: TypeHierarchyItem, token: CancellationToken): ProviderResult<TypeHierarchyItem[]>;
    provideSubtypes(item: TypeHierarchyItem, token: CancellationToken): ProviderResult<TypeHierarchyItem[]>;
}

interface IWorkspaceSymbol {
    name: string;
    containerName?: string;
    kind: SymbolKind;
    tags?: SymbolTag[];
    location: Location;
}
interface IWorkspaceSymbolProvider {
    provideWorkspaceSymbols(search: string, token: CancellationToken): ProviderResult<IWorkspaceSymbol[]>;
    resolveWorkspaceSymbol?(item: IWorkspaceSymbol, token: CancellationToken): ProviderResult<IWorkspaceSymbol>;
}

interface Languages {
    registerTypeHierarchyProvider?(documentSelector: vscode.DocumentSelector, provider: TypeHierarchyProvider): vscode.Disposable;
    registerCallHierarchyProvider?(documentSelector: vscode.DocumentSelector, provider: CallHierarchyProvider): vscode.Disposable;
    registerEvaluatableExpressionProvider?(documentSelector: vscode.DocumentSelector, provider: EvaluatableExpressionProvider): vscode.Disposable;
    registerNavigateTypeSupport?(provider: IWorkspaceSymbolProvider): vscode.Disposable;
}
interface Window {
    showMessage<T extends vscode.MessageOptions | string | vscode.MessageItem>(type: Severity, message: string, ...rest: T[]): PromiseLike<T | undefined>;
    createOutputChannel?(name: string): vscode.OutputChannel;
    withProgress?: typeof vscode.window.withProgress;
    showTextDocument?(document: vscode.Uri, options?: vscode.TextDocumentShowOptions): PromiseLike<void>;
}
interface Workspace {
    rootPath?: string;
    workspaceFolders?: typeof vscode.workspace.workspaceFolders;
    onDidChangeWorkspaceFolders?: typeof vscode.workspace.onDidChangeWorkspaceFolders;
    getConfiguration?: typeof vscode.workspace.getConfiguration;
    onDidChangeConfiguration?: vscode.Event<vscode.ConfigurationChangeEvent>;
    onWillSaveTextDocument?: vscode.Event<vscode.TextDocumentWillSaveEvent>;
    onDidSaveTextDocument?: vscode.Event<vscode.TextDocument>;
    createFileSystemWatcher?: typeof vscode.workspace.createFileSystemWatcher;
}
interface Env {
    openExternal?(document: vscode.Uri): PromiseLike<boolean>;
}
interface Services {
    workspace?: Workspace;
    window?: Window;
    env?: Env;
    languages?: Languages;
}
declare namespace Services {
    type Provider = () => Services;
    const get: Provider;
    function install(_services: Services): vscode.Disposable;
}

export { CallHierarchyProvider, Env, EvaluatableExpressionProvider, IWorkspaceSymbolProvider, Languages, Services, Severity, TypeHierarchyProvider, Window, Workspace };
