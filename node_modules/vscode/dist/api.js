import { illegalArgument, onUnexpectedError, canceled, transformErrorForSerialization, CancellationError as CancellationError$1 } from 'monaco-editor/esm/vs/base/common/errors.js';
import { URI } from 'monaco-editor/esm/vs/base/common/uri.js';
import { equals, coalesce, asArray, isNonEmptyArray, isFalsyOrEmpty } from 'monaco-editor/esm/vs/base/common/arrays.js';
import { MarkdownString as MarkdownString$3, parseHrefAndDimensions, isMarkdownString } from 'monaco-editor/esm/vs/base/common/htmlContent.js';
import { generateUuid } from 'monaco-editor/esm/vs/base/common/uuid.js';
import { nextCharLength, regExpFlags, regExpLeadsToEndlessLoop } from 'monaco-editor/esm/vs/base/common/strings.js';
import { Mimes } from 'monaco-editor/esm/vs/base/common/mime.js';
import { isArray, isString as isString$1, isNumber, isObject, validateConstraint } from 'monaco-editor/esm/vs/base/common/types.js';
import { ResourceMap as ResourceMap$1 } from 'monaco-editor/esm/vs/base/common/map.js';
import * as monaco from 'monaco-editor/esm/vs/editor/editor.api.js';
import { marked as marked$1 } from 'monaco-editor/esm/vs/base/common/marked/marked.js';
import { MarkerSeverity } from 'monaco-editor/esm/vs/platform/markers/common/markers.js';
import { parse, revive } from 'monaco-editor/esm/vs/base/common/marshalling.js';
import { cloneAndChange, mixin } from 'monaco-editor/esm/vs/base/common/objects.js';
import { ExtensionIdentifier } from 'monaco-editor/esm/vs/platform/extensions/common/extensions.js';
import { encodeSemanticTokensDto } from 'monaco-editor/esm/vs/editor/common/services/semanticTokensDto.js';
import { InlineCompletionTriggerKind as InlineCompletionTriggerKind$2 } from 'monaco-editor/esm/vs/editor/common/languages.js';
import { DisposableStore, Disposable as Disposable$2, toDisposable, dispose, combinedDisposable } from 'monaco-editor/esm/vs/base/common/lifecycle.js';
import { IdGenerator } from 'monaco-editor/esm/vs/base/common/idGenerator.js';
import { StopWatch } from 'monaco-editor/esm/vs/base/common/stopwatch.js';
import { toErrorMessage } from 'monaco-editor/esm/vs/base/common/errorMessage.js';
import { CommandsRegistry, ICommandService } from 'monaco-editor/esm/vs/platform/commands/common/commands.js';
import { DebounceEmitter, Event } from 'monaco-editor/esm/vs/base/common/event.js';
import { localize } from 'monaco-editor/esm/vs/nls.js';
import { Schemas } from 'monaco-editor/esm/vs/base/common/network.js';
import { ExtUri } from 'monaco-editor/esm/vs/base/common/resources.js';
import { RunOnceScheduler, createCancelablePromise } from 'monaco-editor/esm/vs/base/common/async.js';
import { CancellationToken } from 'monaco-editor/esm/vs/base/common/cancellation.js';
import { MirrorTextModel } from 'monaco-editor/esm/vs/editor/common/model/mirrorTextModel.js';
import { ok } from 'monaco-editor/esm/vs/base/common/assert.js';
import { getWordAtText, ensureValidWordDefinition } from 'monaco-editor/esm/vs/editor/common/core/wordHelper.js';
import { LogLevel } from 'monaco-editor/esm/vs/platform/log/common/log.js';
import { StandaloneServices } from 'monaco-editor/esm/vs/editor/standalone/browser/standaloneServices.js';
import { Services } from './services.js';
import { isLittleEndian } from 'monaco-editor/esm/vs/base/common/platform.js';
import { score } from 'monaco-editor/esm/vs/editor/common/languageSelector.js';
import { SnippetParser } from 'monaco-editor/esm/vs/editor/contrib/snippet/browser/snippetParser.js';
import { ResourceEdit, ResourceFileEdit, ResourceTextEdit, IBulkEditService } from 'monaco-editor/esm/vs/editor/browser/services/bulkEditService.js';
import Severity from 'monaco-editor/esm/vs/base/common/severity.js';
import { IndentAction as IndentAction$1 } from 'monaco-editor/esm/vs/editor/common/languages/languageConfiguration.js';
import { OverviewRulerLane as OverviewRulerLane$1 } from 'monaco-editor/esm/vs/editor/common/model.js';
import { TextEditorCursorStyle as TextEditorCursorStyle$1 } from 'monaco-editor/esm/vs/editor/common/config/editorOptions.js';
function __classPrivateFieldGet(receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
}
function __classPrivateFieldSet(receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
}
class ErrorNoTelemetry extends Error {
    constructor() {
        super(...arguments);
        this.logTelemetry = false;
    }
    static fromError(err) {
        if (err && err instanceof ErrorNoTelemetry) {
            return err;
        }
        if (err && err instanceof Error) {
            const result =  new ErrorNoTelemetry();
            result.name = err.name;
            result.message = err.message;
            result.stack = err.stack;
            return result;
        }
        return (
             new ErrorNoTelemetry(err)
        );
    }
}
function coalesceInPlace(array) {
    let to = 0;
    for (let i = 0; i < array.length; i++) {
        if (!!array[i]) {
            array[to] = array[i];
            to += 1;
        }
    }
    array.length = to;
}
const CancellationTokenSource$1 = monaco.CancellationTokenSource;
function isString(str) {
    return (typeof str === 'string');
}
function isStringArray(value) {
    return Array.isArray(value) && value.every(elem => isString(elem));
}
var _a$2, _b;
 class ResourceMapEntry {
    constructor(uri, value) {
        this.uri = uri;
        this.value = value;
    }
}
class ResourceMap {
    constructor(mapOrKeyFn, toKey) {
        this[_a$2] = 'ResourceMap';
        if (mapOrKeyFn instanceof ResourceMap) {
            this.map =  new Map(mapOrKeyFn.map);
            this.toKey = toKey ?? ResourceMap.defaultToKey;
        }
        else {
            this.map =  new Map();
            this.toKey = mapOrKeyFn ?? ResourceMap.defaultToKey;
        }
    }
    set(resource, value) {
        this.map.set(this.toKey(resource),  new ResourceMapEntry(resource, value));
        return this;
    }
    get(resource) {
        return this.map.get(this.toKey(resource))?.value;
    }
    has(resource) {
        return this.map.has(this.toKey(resource));
    }
    get size() {
        return this.map.size;
    }
    clear() {
        this.map.clear();
    }
    delete(resource) {
        return this.map.delete(this.toKey(resource));
    }
    forEach(clb, thisArg) {
        if (typeof thisArg !== 'undefined') {
            clb = clb.bind(thisArg);
        }
        for (let [_, entry] of this.map) {
            clb(entry.value, entry.uri, this);
        }
    }
    *values() {
        for (let entry of this.map.values()) {
            yield entry.value;
        }
    }
    *keys() {
        for (let entry of this.map.values()) {
            yield entry.uri;
        }
    }
    *entries() {
        for (let entry of this.map.values()) {
            yield [entry.uri, entry.value];
        }
    }
    *[(_a$2 = Symbol.toStringTag, Symbol.iterator)]() {
        for (let [, entry] of this.map) {
            yield [entry.uri, entry.value];
        }
    }
}
ResourceMap.defaultToKey = (resource) => resource.toString();
class ResourceSet {
    constructor(entriesOrKey, toKey) {
        this[_b] = 'ResourceSet';
        if (!entriesOrKey || typeof entriesOrKey === 'function') {
            this._map =  new ResourceMap(entriesOrKey);
        }
        else {
            this._map =  new ResourceMap(toKey);
            entriesOrKey.forEach(this.add, this);
        }
    }
    get size() {
        return this._map.size;
    }
    add(value) {
        this._map.set(value, value);
        return this;
    }
    clear() {
        this._map.clear();
    }
    delete(value) {
        return this._map.delete(value);
    }
    forEach(callbackfn, thisArg) {
        this._map.forEach((_value, key) => callbackfn.call(thisArg, key, key, this));
    }
    has(value) {
        return this._map.has(value);
    }
    entries() {
        return this._map.entries();
    }
    keys() {
        return this._map.keys();
    }
    values() {
        return this._map.keys();
    }
    [(_b = Symbol.toStringTag, Symbol.iterator)]() {
        return this.keys();
    }
}
const _simplePattern = /^(.+)\/(.+?)(;.+)?$/;
function normalizeMimeType(mimeType, strict) {
    const match = _simplePattern.exec(mimeType);
    if (!match) {
        return strict
            ? undefined
            : mimeType;
    }
    return `${match[1].toLowerCase()}/${match[2].toLowerCase()}${match[3] ?? ''}`;
}
var FileType$1;
 (function(FileType) {
    FileType[FileType["Unknown"] = 0] = "Unknown";
    FileType[FileType["File"] = 1] = "File";
    FileType[FileType["Directory"] = 2] = "Directory";
    FileType[FileType["SymbolicLink"] = 64] = "SymbolicLink";
})(FileType$1 || (FileType$1 = {}));
var FilePermission$1;
 (function(FilePermission) {
    FilePermission[FilePermission["Readonly"] = 1] = "Readonly";
})(FilePermission$1 || (FilePermission$1 = {}));
var FileSystemProviderErrorCode;
 (function(FileSystemProviderErrorCode) {
    FileSystemProviderErrorCode["FileExists"] = "EntryExists";
    FileSystemProviderErrorCode["FileNotFound"] = "EntryNotFound";
    FileSystemProviderErrorCode["FileNotADirectory"] = "EntryNotADirectory";
    FileSystemProviderErrorCode["FileIsADirectory"] = "EntryIsADirectory";
    FileSystemProviderErrorCode["FileExceedsMemoryLimit"] = "EntryExceedsMemoryLimit";
    FileSystemProviderErrorCode["FileTooLarge"] = "EntryTooLarge";
    FileSystemProviderErrorCode["FileWriteLocked"] = "EntryWriteLocked";
    FileSystemProviderErrorCode["NoPermissions"] = "NoPermissions";
    FileSystemProviderErrorCode["Unavailable"] = "Unavailable";
    FileSystemProviderErrorCode["Unknown"] = "Unknown";
})(FileSystemProviderErrorCode || (FileSystemProviderErrorCode = {}));
function markAsFileSystemProviderError(error, code) {
    error.name = code ? `${code} (FileSystemError)` : `FileSystemError`;
    return error;
}
class FileOperationError extends ErrorNoTelemetry {
    constructor(message, fileOperationResult, options) {
        super(message);
        this.fileOperationResult = fileOperationResult;
        this.options = options;
    }
}
var _Disposable_callOnDispose, _MarkdownString_delegate, _DataTransfer_items, _a$1, _NotebookCellOutputItem_encoder;
var Disposable_1, Position_1, Range_1, Selection_1, TextEdit_1, NotebookEdit_1, SnippetString_1, Location_1, SymbolInformation_1, DocumentSymbol_1, CodeActionKind_1, MarkdownString_1, TaskGroup_1, Task_1, FileSystemError_1, TestMessage_1;
let Disposable$1 = Disposable_1 = class Disposable {
    constructor(callOnDispose) {
        _Disposable_callOnDispose.set(this, void 0);
        __classPrivateFieldSet(this, _Disposable_callOnDispose, callOnDispose, "f");
    }
    static from(...inDisposables) {
        let disposables = inDisposables;
        return (
             new Disposable_1(function () {
                if (disposables) {
                    for (const disposable of disposables) {
                        if (disposable && typeof disposable.dispose === 'function') {
                            disposable.dispose();
                        }
                    }
                    disposables = undefined;
                }
            })
        );
    }
    dispose() {
        if (typeof __classPrivateFieldGet(this, _Disposable_callOnDispose, "f") === 'function') {
            __classPrivateFieldGet(this, _Disposable_callOnDispose, "f").call(this);
            __classPrivateFieldSet(this, _Disposable_callOnDispose, undefined, "f");
        }
    }
};
_Disposable_callOnDispose =  new WeakMap();
Disposable$1 = Disposable_1 = Disposable$1;
let Position$3 = Position_1 = class Position {
    constructor(line, character) {
        if (line < 0) {
            throw illegalArgument('line must be non-negative');
        }
        if (character < 0) {
            throw illegalArgument('character must be non-negative');
        }
        this._line = line;
        this._character = character;
    }
    static Min(...positions) {
        if (positions.length === 0) {
            throw new TypeError();
        }
        let result = positions[0];
        for (let i = 1; i < positions.length; i++) {
            const p = positions[i];
            if (p.isBefore(result)) {
                result = p;
            }
        }
        return result;
    }
    static Max(...positions) {
        if (positions.length === 0) {
            throw new TypeError();
        }
        let result = positions[0];
        for (let i = 1; i < positions.length; i++) {
            const p = positions[i];
            if (p.isAfter(result)) {
                result = p;
            }
        }
        return result;
    }
    static isPosition(other) {
        if (!other) {
            return false;
        }
        if (other instanceof Position_1) {
            return true;
        }
        let { line, character } = other;
        if (typeof line === 'number' && typeof character === 'number') {
            return true;
        }
        return false;
    }
    static of(obj) {
        if (obj instanceof Position_1) {
            return obj;
        }
        else if (this.isPosition(obj)) {
            return (
                 new Position_1(obj.line, obj.character)
            );
        }
        throw new Error('Invalid argument, is NOT a position-like object');
    }
    get line() {
        return this._line;
    }
    get character() {
        return this._character;
    }
    isBefore(other) {
        if (this._line < other._line) {
            return true;
        }
        if (other._line < this._line) {
            return false;
        }
        return this._character < other._character;
    }
    isBeforeOrEqual(other) {
        if (this._line < other._line) {
            return true;
        }
        if (other._line < this._line) {
            return false;
        }
        return this._character <= other._character;
    }
    isAfter(other) {
        return !this.isBeforeOrEqual(other);
    }
    isAfterOrEqual(other) {
        return !this.isBefore(other);
    }
    isEqual(other) {
        return this._line === other._line && this._character === other._character;
    }
    compareTo(other) {
        if (this._line < other._line) {
            return -1;
        }
        else if (this._line > other.line) {
            return 1;
        }
        else {
            if (this._character < other._character) {
                return -1;
            }
            else if (this._character > other._character) {
                return 1;
            }
            else {
                return 0;
            }
        }
    }
    translate(lineDeltaOrChange, characterDelta = 0) {
        if (lineDeltaOrChange === null || characterDelta === null) {
            throw illegalArgument();
        }
        let lineDelta;
        if (typeof lineDeltaOrChange === 'undefined') {
            lineDelta = 0;
        }
        else if (typeof lineDeltaOrChange === 'number') {
            lineDelta = lineDeltaOrChange;
        }
        else {
            lineDelta = typeof lineDeltaOrChange.lineDelta === 'number' ? lineDeltaOrChange.lineDelta : 0;
            characterDelta = typeof lineDeltaOrChange.characterDelta === 'number' ? lineDeltaOrChange.characterDelta : 0;
        }
        if (lineDelta === 0 && characterDelta === 0) {
            return this;
        }
        return (
             new Position_1(this.line + lineDelta, this.character + characterDelta)
        );
    }
    with(lineOrChange, character = this.character) {
        if (lineOrChange === null || character === null) {
            throw illegalArgument();
        }
        let line;
        if (typeof lineOrChange === 'undefined') {
            line = this.line;
        }
        else if (typeof lineOrChange === 'number') {
            line = lineOrChange;
        }
        else {
            line = typeof lineOrChange.line === 'number' ? lineOrChange.line : this.line;
            character = typeof lineOrChange.character === 'number' ? lineOrChange.character : this.character;
        }
        if (line === this.line && character === this.character) {
            return this;
        }
        return (
             new Position_1(line, character)
        );
    }
    toJSON() {
        return { line: this.line, character: this.character };
    }
};
Position$3 = Position_1 = Position$3;
let Range$3 = Range_1 = class Range {
    constructor(startLineOrStart, startColumnOrEnd, endLine, endColumn) {
        let start;
        let end;
        if (typeof startLineOrStart === 'number' && typeof startColumnOrEnd === 'number' && typeof endLine === 'number' && typeof endColumn === 'number') {
            start =  new Position$3(startLineOrStart, startColumnOrEnd);
            end =  new Position$3(endLine, endColumn);
        }
        else if (Position$3.isPosition(startLineOrStart) && Position$3.isPosition(startColumnOrEnd)) {
            start = Position$3.of(startLineOrStart);
            end = Position$3.of(startColumnOrEnd);
        }
        if (!start || !end) {
            throw new Error('Invalid arguments');
        }
        if (start.isBefore(end)) {
            this._start = start;
            this._end = end;
        }
        else {
            this._start = end;
            this._end = start;
        }
    }
    static isRange(thing) {
        if (thing instanceof Range_1) {
            return true;
        }
        if (!thing) {
            return false;
        }
        return Position$3.isPosition(thing.start)
            && Position$3.isPosition(thing.end);
    }
    static of(obj) {
        if (obj instanceof Range_1) {
            return obj;
        }
        if (this.isRange(obj)) {
            return (
                 new Range_1(obj.start, obj.end)
            );
        }
        throw new Error('Invalid argument, is NOT a range-like object');
    }
    get start() {
        return this._start;
    }
    get end() {
        return this._end;
    }
    contains(positionOrRange) {
        if (Range_1.isRange(positionOrRange)) {
            return this.contains(positionOrRange.start)
                && this.contains(positionOrRange.end);
        }
        else if (Position$3.isPosition(positionOrRange)) {
            if (Position$3.of(positionOrRange).isBefore(this._start)) {
                return false;
            }
            if (this._end.isBefore(positionOrRange)) {
                return false;
            }
            return true;
        }
        return false;
    }
    isEqual(other) {
        return this._start.isEqual(other._start) && this._end.isEqual(other._end);
    }
    intersection(other) {
        const start = Position$3.Max(other.start, this._start);
        const end = Position$3.Min(other.end, this._end);
        if (start.isAfter(end)) {
            return undefined;
        }
        return (
             new Range_1(start, end)
        );
    }
    union(other) {
        if (this.contains(other)) {
            return this;
        }
        else if (other.contains(this)) {
            return other;
        }
        const start = Position$3.Min(other.start, this._start);
        const end = Position$3.Max(other.end, this.end);
        return (
             new Range_1(start, end)
        );
    }
    get isEmpty() {
        return this._start.isEqual(this._end);
    }
    get isSingleLine() {
        return this._start.line === this._end.line;
    }
    with(startOrChange, end = this.end) {
        if (startOrChange === null || end === null) {
            throw illegalArgument();
        }
        let start;
        if (!startOrChange) {
            start = this.start;
        }
        else if (Position$3.isPosition(startOrChange)) {
            start = startOrChange;
        }
        else {
            start = startOrChange.start || this.start;
            end = startOrChange.end || this.end;
        }
        if (start.isEqual(this._start) && end.isEqual(this.end)) {
            return this;
        }
        return (
             new Range_1(start, end)
        );
    }
    toJSON() {
        return [this.start, this.end];
    }
};
Range$3 = Range_1 = Range$3;
let Selection$3 = Selection_1 = class Selection extends Range$3 {
    constructor(anchorLineOrAnchor, anchorColumnOrActive, activeLine, activeColumn) {
        let anchor;
        let active;
        if (typeof anchorLineOrAnchor === 'number' && typeof anchorColumnOrActive === 'number' && typeof activeLine === 'number' && typeof activeColumn === 'number') {
            anchor =  new Position$3(anchorLineOrAnchor, anchorColumnOrActive);
            active =  new Position$3(activeLine, activeColumn);
        }
        else if (Position$3.isPosition(anchorLineOrAnchor) && Position$3.isPosition(anchorColumnOrActive)) {
            anchor = Position$3.of(anchorLineOrAnchor);
            active = Position$3.of(anchorColumnOrActive);
        }
        if (!anchor || !active) {
            throw new Error('Invalid arguments');
        }
        super(anchor, active);
        this._anchor = anchor;
        this._active = active;
    }
    static isSelection(thing) {
        if (thing instanceof Selection_1) {
            return true;
        }
        if (!thing) {
            return false;
        }
        return Range$3.isRange(thing)
            && Position$3.isPosition(thing.anchor)
            && Position$3.isPosition(thing.active)
            && typeof thing.isReversed === 'boolean';
    }
    get anchor() {
        return this._anchor;
    }
    get active() {
        return this._active;
    }
    get isReversed() {
        return this._anchor === this._end;
    }
    toJSON() {
        return {
            start: this.start,
            end: this.end,
            active: this.active,
            anchor: this.anchor
        };
    }
};
Selection$3 = Selection_1 = Selection$3;
var EndOfLine$2;
 (function(EndOfLine) {
    EndOfLine[EndOfLine["LF"] = 1] = "LF";
    EndOfLine[EndOfLine["CRLF"] = 2] = "CRLF";
})(EndOfLine$2 || (EndOfLine$2 = {}));
var EnvironmentVariableMutatorType$1;
 (function(EnvironmentVariableMutatorType) {
    EnvironmentVariableMutatorType[EnvironmentVariableMutatorType["Replace"] = 1] = "Replace";
    EnvironmentVariableMutatorType[EnvironmentVariableMutatorType["Append"] = 2] = "Append";
    EnvironmentVariableMutatorType[EnvironmentVariableMutatorType["Prepend"] = 3] = "Prepend";
})(EnvironmentVariableMutatorType$1 || (EnvironmentVariableMutatorType$1 = {}));
let TextEdit$2 = TextEdit_1 = class TextEdit {
    constructor(range, newText) {
        this._range = range;
        this._newText = newText;
    }
    static isTextEdit(thing) {
        if (thing instanceof TextEdit_1) {
            return true;
        }
        if (!thing) {
            return false;
        }
        return Range$3.isRange(thing)
            && typeof thing.newText === 'string';
    }
    static replace(range, newText) {
        return (
             new TextEdit_1(range, newText)
        );
    }
    static insert(position, newText) {
        return TextEdit_1.replace( new Range$3(position, position), newText);
    }
    static delete(range) {
        return TextEdit_1.replace(range, '');
    }
    static setEndOfLine(eol) {
        const ret =  new TextEdit_1( new Range$3( new Position$3(0, 0),  new Position$3(0, 0)), '');
        ret.newEol = eol;
        return ret;
    }
    get range() {
        return this._range;
    }
    set range(value) {
        if (value && !Range$3.isRange(value)) {
            throw illegalArgument('range');
        }
        this._range = value;
    }
    get newText() {
        return this._newText || '';
    }
    set newText(value) {
        if (value && typeof value !== 'string') {
            throw illegalArgument('newText');
        }
        this._newText = value;
    }
    get newEol() {
        return this._newEol;
    }
    set newEol(value) {
        if (value && typeof value !== 'number') {
            throw illegalArgument('newEol');
        }
        this._newEol = value;
    }
    toJSON() {
        return {
            range: this.range,
            newText: this.newText,
            newEol: this._newEol
        };
    }
};
TextEdit$2 = TextEdit_1 = TextEdit$2;
let NotebookEdit = NotebookEdit_1 = class NotebookEdit {
    constructor(range, newCells) {
        this.range = range;
        this.newCells = newCells;
    }
    static isNotebookCellEdit(thing) {
        if (thing instanceof NotebookEdit_1) {
            return true;
        }
        if (!thing) {
            return false;
        }
        return NotebookRange$2.isNotebookRange(thing)
            && Array.isArray(thing.newCells);
    }
    static replaceCells(range, newCells) {
        return (
             new NotebookEdit_1(range, newCells)
        );
    }
    static insertCells(index, newCells) {
        return (
             new NotebookEdit_1( new NotebookRange$2(index, index), newCells)
        );
    }
    static deleteCells(range) {
        return (
             new NotebookEdit_1(range, [])
        );
    }
    static updateCellMetadata(index, newMetadata) {
        const edit =  new NotebookEdit_1( new NotebookRange$2(index, index), []);
        edit.newCellMetadata = newMetadata;
        return edit;
    }
    static updateNotebookMetadata(newMetadata) {
        const edit =  new NotebookEdit_1( new NotebookRange$2(0, 0), []);
        edit.newNotebookMetadata = newMetadata;
        return edit;
    }
};
NotebookEdit = NotebookEdit_1 = NotebookEdit;
let WorkspaceEdit$2 = class WorkspaceEdit {
    constructor() {
        this._edits = [];
    }
    _allEntries() {
        return this._edits;
    }
    renameFile(from, to, options, metadata) {
        this._edits.push({ _type: 1 , from, to, options, metadata });
    }
    createFile(uri, options, metadata) {
        this._edits.push({ _type: 1 , from: undefined, to: uri, options, metadata });
    }
    deleteFile(uri, options, metadata) {
        this._edits.push({ _type: 1 , from: uri, to: undefined, options, metadata });
    }
    replaceNotebookMetadata(uri, value, metadata) {
        this._edits.push({ _type: 3 , metadata, uri, edit: { editType: 5 , metadata: value }, notebookMetadata: value });
    }
    replaceNotebookCells(uri, startOrRange, endOrCells, cellsOrMetadata, metadata) {
        let start;
        let end;
        let cellData = [];
        let workspaceEditMetadata;
        if (NotebookRange$2.isNotebookRange(startOrRange) && NotebookCellData$2.isNotebookCellDataArray(endOrCells) && !NotebookCellData$2.isNotebookCellDataArray(cellsOrMetadata)) {
            start = startOrRange.start;
            end = startOrRange.end;
            cellData = endOrCells;
            workspaceEditMetadata = cellsOrMetadata;
        }
        else if (typeof startOrRange === 'number' && typeof endOrCells === 'number' && NotebookCellData$2.isNotebookCellDataArray(cellsOrMetadata)) {
            start = startOrRange;
            end = endOrCells;
            cellData = cellsOrMetadata;
            workspaceEditMetadata = metadata;
        }
        if (start === undefined || end === undefined) {
            throw new Error('Invalid arguments');
        }
        if (start !== end || cellData.length > 0) {
            this._edits.push({ _type: 5 , uri, index: start, count: end - start, cells: cellData, metadata: workspaceEditMetadata });
        }
    }
    replaceNotebookCellMetadata(uri, index, cellMetadata, metadata) {
        this._edits.push({ _type: 3 , metadata, uri, edit: { editType: 8 , index, metadata: cellMetadata } });
    }
    replace(uri, range, newText, metadata) {
        this._edits.push({ _type: 2 , uri, edit:  new TextEdit$2(range, newText), metadata });
    }
    insert(resource, position, newText, metadata) {
        this.replace(resource,  new Range$3(position, position), newText, metadata);
    }
    delete(resource, range, metadata) {
        this.replace(resource, range, '', metadata);
    }
    has(uri) {
        return this._edits.some(edit => edit._type === 2  && edit.uri.toString() === uri.toString());
    }
    set(uri, edits) {
        if (!edits) {
            for (let i = 0; i < this._edits.length; i++) {
                const element = this._edits[i];
                if (element._type === 2  && element.uri.toString() === uri.toString()) {
                    this._edits[i] = undefined;
                }
            }
            coalesceInPlace(this._edits);
        }
        else {
            for (const edit of edits) {
                if (edit) {
                    if (NotebookEdit.isNotebookCellEdit(edit)) {
                        if (edit.newCellMetadata) {
                            this.replaceNotebookCellMetadata(uri, edit.range.start, edit.newCellMetadata);
                        }
                        else if (edit.newNotebookMetadata) {
                            this.replaceNotebookMetadata(uri, edit.newNotebookMetadata);
                        }
                        else {
                            this.replaceNotebookCells(uri, edit.range, edit.newCells);
                        }
                    }
                    else {
                        this._edits.push({ _type: 2 , uri, edit });
                    }
                }
            }
        }
    }
    get(uri) {
        const res = [];
        for (let candidate of this._edits) {
            if (candidate._type === 2  && candidate.uri.toString() === uri.toString()) {
                res.push(candidate.edit);
            }
        }
        return res;
    }
    entries() {
        const textEdits =  new ResourceMap$1();
        for (let candidate of this._edits) {
            if (candidate._type === 2 ) {
                let textEdit = textEdits.get(candidate.uri);
                if (!textEdit) {
                    textEdit = [candidate.uri, []];
                    textEdits.set(candidate.uri, textEdit);
                }
                textEdit[1].push(candidate.edit);
            }
        }
        return [...textEdits.values()];
    }
    get size() {
        return this.entries().length;
    }
    toJSON() {
        return this.entries();
    }
};
WorkspaceEdit$2 = WorkspaceEdit$2;
let SnippetString$1 = SnippetString_1 = class SnippetString {
    constructor(value) {
        this._tabstop = 1;
        this.value = value || '';
    }
    static isSnippetString(thing) {
        if (thing instanceof SnippetString_1) {
            return true;
        }
        if (!thing) {
            return false;
        }
        return typeof thing.value === 'string';
    }
    static _escape(value) {
        return value.replace(/\$|}|\\/g, '\\$&');
    }
    appendText(string) {
        this.value += SnippetString_1._escape(string);
        return this;
    }
    appendTabstop(number = this._tabstop++) {
        this.value += '$';
        this.value += number;
        return this;
    }
    appendPlaceholder(value, number = this._tabstop++) {
        if (typeof value === 'function') {
            const nested =  new SnippetString_1();
            nested._tabstop = this._tabstop;
            value(nested);
            this._tabstop = nested._tabstop;
            value = nested.value;
        }
        else {
            value = SnippetString_1._escape(value);
        }
        this.value += '${';
        this.value += number;
        this.value += ':';
        this.value += value;
        this.value += '}';
        return this;
    }
    appendChoice(values, number = this._tabstop++) {
        const value = values.map(s => s.replace(/\$|}|\\|,/g, '\\$&')).join(',');
        this.value += '${';
        this.value += number;
        this.value += '|';
        this.value += value;
        this.value += '|}';
        return this;
    }
    appendVariable(name, defaultValue) {
        if (typeof defaultValue === 'function') {
            const nested =  new SnippetString_1();
            nested._tabstop = this._tabstop;
            defaultValue(nested);
            this._tabstop = nested._tabstop;
            defaultValue = nested.value;
        }
        else if (typeof defaultValue === 'string') {
            defaultValue = defaultValue.replace(/\$|}/g, '\\$&');
        }
        this.value += '${';
        this.value += name;
        if (defaultValue) {
            this.value += ':';
            this.value += defaultValue;
        }
        this.value += '}';
        return this;
    }
};
SnippetString$1 = SnippetString_1 = SnippetString$1;
var DiagnosticTag$2;
 (function(DiagnosticTag) {
    DiagnosticTag[DiagnosticTag["Unnecessary"] = 1] = "Unnecessary";
    DiagnosticTag[DiagnosticTag["Deprecated"] = 2] = "Deprecated";
})(DiagnosticTag$2 || (DiagnosticTag$2 = {}));
var DiagnosticSeverity$2;
 (function(DiagnosticSeverity) {
    DiagnosticSeverity[DiagnosticSeverity["Hint"] = 3] = "Hint";
    DiagnosticSeverity[DiagnosticSeverity["Information"] = 2] = "Information";
    DiagnosticSeverity[DiagnosticSeverity["Warning"] = 1] = "Warning";
    DiagnosticSeverity[DiagnosticSeverity["Error"] = 0] = "Error";
})(DiagnosticSeverity$2 || (DiagnosticSeverity$2 = {}));
let Location$1 = Location_1 = class Location {
    constructor(uri, rangeOrPosition) {
        this.uri = uri;
        if (!rangeOrPosition) ;
        else if (Range$3.isRange(rangeOrPosition)) {
            this.range = Range$3.of(rangeOrPosition);
        }
        else if (Position$3.isPosition(rangeOrPosition)) {
            this.range =  new Range$3(rangeOrPosition, rangeOrPosition);
        }
        else {
            throw new Error('Illegal argument');
        }
    }
    static isLocation(thing) {
        if (thing instanceof Location_1) {
            return true;
        }
        if (!thing) {
            return false;
        }
        return Range$3.isRange(thing.range)
            && URI.isUri(thing.uri);
    }
    toJSON() {
        return {
            uri: this.uri,
            range: this.range
        };
    }
};
Location$1 = Location_1 = Location$1;
let DiagnosticRelatedInformation$2 = class DiagnosticRelatedInformation {
    constructor(location, message) {
        this.location = location;
        this.message = message;
    }
    static is(thing) {
        if (!thing) {
            return false;
        }
        return typeof thing.message === 'string'
            && thing.location
            && Range$3.isRange(thing.location.range)
            && URI.isUri(thing.location.uri);
    }
    static isEqual(a, b) {
        if (a === b) {
            return true;
        }
        if (!a || !b) {
            return false;
        }
        return a.message === b.message
            && a.location.range.isEqual(b.location.range)
            && a.location.uri.toString() === b.location.uri.toString();
    }
};
DiagnosticRelatedInformation$2 = DiagnosticRelatedInformation$2;
let Diagnostic$2 = class Diagnostic {
    constructor(range, message, severity = DiagnosticSeverity$2.Error) {
        if (!Range$3.isRange(range)) {
            throw new TypeError('range must be set');
        }
        if (!message) {
            throw new TypeError('message must be set');
        }
        this.range = range;
        this.message = message;
        this.severity = severity;
    }
    toJSON() {
        return {
            severity: DiagnosticSeverity$2[this.severity],
            message: this.message,
            range: this.range,
            source: this.source,
            code: this.code,
        };
    }
    static isEqual(a, b) {
        if (a === b) {
            return true;
        }
        if (!a || !b) {
            return false;
        }
        return a.message === b.message
            && a.severity === b.severity
            && a.code === b.code
            && a.severity === b.severity
            && a.source === b.source
            && a.range.isEqual(b.range)
            && equals(a.tags, b.tags)
            && equals(a.relatedInformation, b.relatedInformation, DiagnosticRelatedInformation$2.isEqual);
    }
};
Diagnostic$2 = Diagnostic$2;
let Hover$2 = class Hover {
    constructor(contents, range) {
        if (!contents) {
            throw new Error('Illegal argument, contents must be defined');
        }
        if (Array.isArray(contents)) {
            this.contents = contents;
        }
        else {
            this.contents = [contents];
        }
        this.range = range;
    }
};
Hover$2 = Hover$2;
var DocumentHighlightKind$1;
 (function(DocumentHighlightKind) {
    DocumentHighlightKind[DocumentHighlightKind["Text"] = 0] = "Text";
    DocumentHighlightKind[DocumentHighlightKind["Read"] = 1] = "Read";
    DocumentHighlightKind[DocumentHighlightKind["Write"] = 2] = "Write";
})(DocumentHighlightKind$1 || (DocumentHighlightKind$1 = {}));
let DocumentHighlight$2 = class DocumentHighlight {
    constructor(range, kind = DocumentHighlightKind$1.Text) {
        this.range = range;
        this.kind = kind;
    }
    toJSON() {
        return {
            range: this.range,
            kind: DocumentHighlightKind$1[this.kind]
        };
    }
};
DocumentHighlight$2 = DocumentHighlight$2;
var SymbolKind$2;
 (function(SymbolKind) {
    SymbolKind[SymbolKind["File"] = 0] = "File";
    SymbolKind[SymbolKind["Module"] = 1] = "Module";
    SymbolKind[SymbolKind["Namespace"] = 2] = "Namespace";
    SymbolKind[SymbolKind["Package"] = 3] = "Package";
    SymbolKind[SymbolKind["Class"] = 4] = "Class";
    SymbolKind[SymbolKind["Method"] = 5] = "Method";
    SymbolKind[SymbolKind["Property"] = 6] = "Property";
    SymbolKind[SymbolKind["Field"] = 7] = "Field";
    SymbolKind[SymbolKind["Constructor"] = 8] = "Constructor";
    SymbolKind[SymbolKind["Enum"] = 9] = "Enum";
    SymbolKind[SymbolKind["Interface"] = 10] = "Interface";
    SymbolKind[SymbolKind["Function"] = 11] = "Function";
    SymbolKind[SymbolKind["Variable"] = 12] = "Variable";
    SymbolKind[SymbolKind["Constant"] = 13] = "Constant";
    SymbolKind[SymbolKind["String"] = 14] = "String";
    SymbolKind[SymbolKind["Number"] = 15] = "Number";
    SymbolKind[SymbolKind["Boolean"] = 16] = "Boolean";
    SymbolKind[SymbolKind["Array"] = 17] = "Array";
    SymbolKind[SymbolKind["Object"] = 18] = "Object";
    SymbolKind[SymbolKind["Key"] = 19] = "Key";
    SymbolKind[SymbolKind["Null"] = 20] = "Null";
    SymbolKind[SymbolKind["EnumMember"] = 21] = "EnumMember";
    SymbolKind[SymbolKind["Struct"] = 22] = "Struct";
    SymbolKind[SymbolKind["Event"] = 23] = "Event";
    SymbolKind[SymbolKind["Operator"] = 24] = "Operator";
    SymbolKind[SymbolKind["TypeParameter"] = 25] = "TypeParameter";
})(SymbolKind$2 || (SymbolKind$2 = {}));
var SymbolTag$2;
 (function(SymbolTag) {
    SymbolTag[SymbolTag["Deprecated"] = 1] = "Deprecated";
})(SymbolTag$2 || (SymbolTag$2 = {}));
let SymbolInformation$1 = SymbolInformation_1 = class SymbolInformation {
    constructor(name, kind, rangeOrContainer, locationOrUri, containerName) {
        this.name = name;
        this.kind = kind;
        this.containerName = containerName;
        if (typeof rangeOrContainer === 'string') {
            this.containerName = rangeOrContainer;
        }
        if (locationOrUri instanceof Location$1) {
            this.location = locationOrUri;
        }
        else if (rangeOrContainer instanceof Range$3) {
            this.location =  new Location$1(locationOrUri, rangeOrContainer);
        }
        SymbolInformation_1.validate(this);
    }
    static validate(candidate) {
        if (!candidate.name) {
            throw new Error('name must not be falsy');
        }
    }
    toJSON() {
        return {
            name: this.name,
            kind: SymbolKind$2[this.kind],
            location: this.location,
            containerName: this.containerName
        };
    }
};
SymbolInformation$1 = SymbolInformation_1 = SymbolInformation$1;
let DocumentSymbol$2 = DocumentSymbol_1 = class DocumentSymbol {
    constructor(name, detail, kind, range, selectionRange) {
        this.name = name;
        this.detail = detail;
        this.kind = kind;
        this.range = range;
        this.selectionRange = selectionRange;
        this.children = [];
        DocumentSymbol_1.validate(this);
    }
    static validate(candidate) {
        if (!candidate.name) {
            throw new Error('name must not be falsy');
        }
        if (!candidate.range.contains(candidate.selectionRange)) {
            throw new Error('selectionRange must be contained in fullRange');
        }
        if (candidate.children) {
            candidate.children.forEach(DocumentSymbol_1.validate);
        }
    }
};
DocumentSymbol$2 = DocumentSymbol_1 = DocumentSymbol$2;
var CodeActionTriggerKind$2;
 (function(CodeActionTriggerKind) {
    CodeActionTriggerKind[CodeActionTriggerKind["Invoke"] = 1] = "Invoke";
    CodeActionTriggerKind[CodeActionTriggerKind["Automatic"] = 2] = "Automatic";
})(CodeActionTriggerKind$2 || (CodeActionTriggerKind$2 = {}));
let CodeAction$1 = class CodeAction {
    constructor(title, kind) {
        this.title = title;
        this.kind = kind;
    }
};
CodeAction$1 = CodeAction$1;
let CodeActionKind$1 = CodeActionKind_1 = class CodeActionKind {
    constructor(value) {
        this.value = value;
    }
    append(parts) {
        return (
             new CodeActionKind_1(this.value ? this.value + CodeActionKind_1.sep + parts : parts)
        );
    }
    intersects(other) {
        return this.contains(other) || other.contains(this);
    }
    contains(other) {
        return this.value === other.value || other.value.startsWith(this.value + CodeActionKind_1.sep);
    }
};
CodeActionKind$1.sep = '.';
CodeActionKind$1 = CodeActionKind_1 = CodeActionKind$1;
CodeActionKind$1.Empty =  new CodeActionKind$1('');
CodeActionKind$1.QuickFix = CodeActionKind$1.Empty.append('quickfix');
CodeActionKind$1.Refactor = CodeActionKind$1.Empty.append('refactor');
CodeActionKind$1.RefactorExtract = CodeActionKind$1.Refactor.append('extract');
CodeActionKind$1.RefactorInline = CodeActionKind$1.Refactor.append('inline');
CodeActionKind$1.RefactorRewrite = CodeActionKind$1.Refactor.append('rewrite');
CodeActionKind$1.Source = CodeActionKind$1.Empty.append('source');
CodeActionKind$1.SourceOrganizeImports = CodeActionKind$1.Source.append('organizeImports');
CodeActionKind$1.SourceFixAll = CodeActionKind$1.Source.append('fixAll');
let SelectionRange$2 = class SelectionRange {
    constructor(range, parent) {
        this.range = range;
        this.parent = parent;
        if (parent && !parent.range.contains(this.range)) {
            throw new Error('Invalid argument: parent must contain this range');
        }
    }
};
SelectionRange$2 = SelectionRange$2;
class CallHierarchyItem$2 {
    constructor(kind, name, detail, uri, range, selectionRange) {
        this.kind = kind;
        this.name = name;
        this.detail = detail;
        this.uri = uri;
        this.range = range;
        this.selectionRange = selectionRange;
    }
}
class CallHierarchyIncomingCall$1 {
    constructor(item, fromRanges) {
        this.fromRanges = fromRanges;
        this.from = item;
    }
}
class CallHierarchyOutgoingCall$1 {
    constructor(item, fromRanges) {
        this.fromRanges = fromRanges;
        this.to = item;
    }
}
var LanguageStatusSeverity$1;
 (function(LanguageStatusSeverity) {
    LanguageStatusSeverity[LanguageStatusSeverity["Information"] = 0] = "Information";
    LanguageStatusSeverity[LanguageStatusSeverity["Warning"] = 1] = "Warning";
    LanguageStatusSeverity[LanguageStatusSeverity["Error"] = 2] = "Error";
})(LanguageStatusSeverity$1 || (LanguageStatusSeverity$1 = {}));
let CodeLens$1 = class CodeLens {
    constructor(range, command) {
        this.range = range;
        this.command = command;
    }
    get isResolved() {
        return !!this.command;
    }
};
CodeLens$1 = CodeLens$1;
let MarkdownString$2 = MarkdownString_1 = class MarkdownString {
    constructor(value, supportThemeIcons = false) {
        _MarkdownString_delegate.set(this, void 0);
        __classPrivateFieldSet(this, _MarkdownString_delegate,  new MarkdownString$3(value, { supportThemeIcons }), "f");
    }
    static isMarkdownString(thing) {
        if (thing instanceof MarkdownString_1) {
            return true;
        }
        return thing && thing.appendCodeblock && thing.appendMarkdown && thing.appendText && (thing.value !== undefined);
    }
    get value() {
        return __classPrivateFieldGet(this, _MarkdownString_delegate, "f").value;
    }
    set value(value) {
        __classPrivateFieldGet(this, _MarkdownString_delegate, "f").value = value;
    }
    get isTrusted() {
        return __classPrivateFieldGet(this, _MarkdownString_delegate, "f").isTrusted;
    }
    set isTrusted(value) {
        __classPrivateFieldGet(this, _MarkdownString_delegate, "f").isTrusted = value;
    }
    get supportThemeIcons() {
        return __classPrivateFieldGet(this, _MarkdownString_delegate, "f").supportThemeIcons;
    }
    set supportThemeIcons(value) {
        __classPrivateFieldGet(this, _MarkdownString_delegate, "f").supportThemeIcons = value;
    }
    get supportHtml() {
        return __classPrivateFieldGet(this, _MarkdownString_delegate, "f").supportHtml;
    }
    set supportHtml(value) {
        __classPrivateFieldGet(this, _MarkdownString_delegate, "f").supportHtml = value;
    }
    get baseUri() {
        return __classPrivateFieldGet(this, _MarkdownString_delegate, "f").baseUri;
    }
    set baseUri(value) {
        __classPrivateFieldGet(this, _MarkdownString_delegate, "f").baseUri = value;
    }
    appendText(value) {
        __classPrivateFieldGet(this, _MarkdownString_delegate, "f").appendText(value);
        return this;
    }
    appendMarkdown(value) {
        __classPrivateFieldGet(this, _MarkdownString_delegate, "f").appendMarkdown(value);
        return this;
    }
    appendCodeblock(value, language) {
        __classPrivateFieldGet(this, _MarkdownString_delegate, "f").appendCodeblock(language ?? '', value);
        return this;
    }
};
_MarkdownString_delegate =  new WeakMap();
MarkdownString$2 = MarkdownString_1 = MarkdownString$2;
let ParameterInformation$2 = class ParameterInformation {
    constructor(label, documentation) {
        this.label = label;
        this.documentation = documentation;
    }
};
ParameterInformation$2 = ParameterInformation$2;
let SignatureInformation$2 = class SignatureInformation {
    constructor(label, documentation) {
        this.label = label;
        this.documentation = documentation;
        this.parameters = [];
    }
};
SignatureInformation$2 = SignatureInformation$2;
let SignatureHelp$2 = class SignatureHelp {
    constructor() {
        this.activeSignature = 0;
        this.activeParameter = 0;
        this.signatures = [];
    }
};
SignatureHelp$2 = SignatureHelp$2;
var SignatureHelpTriggerKind$1;
 (function(SignatureHelpTriggerKind) {
    SignatureHelpTriggerKind[SignatureHelpTriggerKind["Invoke"] = 1] = "Invoke";
    SignatureHelpTriggerKind[SignatureHelpTriggerKind["TriggerCharacter"] = 2] = "TriggerCharacter";
    SignatureHelpTriggerKind[SignatureHelpTriggerKind["ContentChange"] = 3] = "ContentChange";
})(SignatureHelpTriggerKind$1 || (SignatureHelpTriggerKind$1 = {}));
var InlayHintKind$2;
 (function(InlayHintKind) {
    InlayHintKind[InlayHintKind["Type"] = 1] = "Type";
    InlayHintKind[InlayHintKind["Parameter"] = 2] = "Parameter";
})(InlayHintKind$2 || (InlayHintKind$2 = {}));
let InlayHintLabelPart$1 = class InlayHintLabelPart {
    constructor(value) {
        this.value = value;
    }
};
InlayHintLabelPart$1 = InlayHintLabelPart$1;
let InlayHint$1 = class InlayHint {
    constructor(position, label, kind) {
        this.position = position;
        this.label = label;
        this.kind = kind;
    }
};
InlayHint$1 = InlayHint$1;
var CompletionTriggerKind$2;
 (function(CompletionTriggerKind) {
    CompletionTriggerKind[CompletionTriggerKind["Invoke"] = 0] = "Invoke";
    CompletionTriggerKind[CompletionTriggerKind["TriggerCharacter"] = 1] = "TriggerCharacter";
    CompletionTriggerKind[CompletionTriggerKind["TriggerForIncompleteCompletions"] = 2] = "TriggerForIncompleteCompletions";
})(CompletionTriggerKind$2 || (CompletionTriggerKind$2 = {}));
var CompletionItemKind$2;
 (function(CompletionItemKind) {
    CompletionItemKind[CompletionItemKind["Text"] = 0] = "Text";
    CompletionItemKind[CompletionItemKind["Method"] = 1] = "Method";
    CompletionItemKind[CompletionItemKind["Function"] = 2] = "Function";
    CompletionItemKind[CompletionItemKind["Constructor"] = 3] = "Constructor";
    CompletionItemKind[CompletionItemKind["Field"] = 4] = "Field";
    CompletionItemKind[CompletionItemKind["Variable"] = 5] = "Variable";
    CompletionItemKind[CompletionItemKind["Class"] = 6] = "Class";
    CompletionItemKind[CompletionItemKind["Interface"] = 7] = "Interface";
    CompletionItemKind[CompletionItemKind["Module"] = 8] = "Module";
    CompletionItemKind[CompletionItemKind["Property"] = 9] = "Property";
    CompletionItemKind[CompletionItemKind["Unit"] = 10] = "Unit";
    CompletionItemKind[CompletionItemKind["Value"] = 11] = "Value";
    CompletionItemKind[CompletionItemKind["Enum"] = 12] = "Enum";
    CompletionItemKind[CompletionItemKind["Keyword"] = 13] = "Keyword";
    CompletionItemKind[CompletionItemKind["Snippet"] = 14] = "Snippet";
    CompletionItemKind[CompletionItemKind["Color"] = 15] = "Color";
    CompletionItemKind[CompletionItemKind["File"] = 16] = "File";
    CompletionItemKind[CompletionItemKind["Reference"] = 17] = "Reference";
    CompletionItemKind[CompletionItemKind["Folder"] = 18] = "Folder";
    CompletionItemKind[CompletionItemKind["EnumMember"] = 19] = "EnumMember";
    CompletionItemKind[CompletionItemKind["Constant"] = 20] = "Constant";
    CompletionItemKind[CompletionItemKind["Struct"] = 21] = "Struct";
    CompletionItemKind[CompletionItemKind["Event"] = 22] = "Event";
    CompletionItemKind[CompletionItemKind["Operator"] = 23] = "Operator";
    CompletionItemKind[CompletionItemKind["TypeParameter"] = 24] = "TypeParameter";
    CompletionItemKind[CompletionItemKind["User"] = 25] = "User";
    CompletionItemKind[CompletionItemKind["Issue"] = 26] = "Issue";
})(CompletionItemKind$2 || (CompletionItemKind$2 = {}));
var CompletionItemTag$2;
 (function(CompletionItemTag) {
    CompletionItemTag[CompletionItemTag["Deprecated"] = 1] = "Deprecated";
})(CompletionItemTag$2 || (CompletionItemTag$2 = {}));
let CompletionItem$1 = class CompletionItem {
    constructor(label, kind) {
        this.label = label;
        this.kind = kind;
    }
    toJSON() {
        return {
            label: this.label,
            kind: this.kind && CompletionItemKind$2[this.kind],
            detail: this.detail,
            documentation: this.documentation,
            sortText: this.sortText,
            filterText: this.filterText,
            preselect: this.preselect,
            insertText: this.insertText,
            textEdit: this.textEdit
        };
    }
};
CompletionItem$1 = CompletionItem$1;
let CompletionList$1 = class CompletionList {
    constructor(items = [], isIncomplete = false) {
        this.items = items;
        this.isIncomplete = isIncomplete;
    }
};
CompletionList$1 = CompletionList$1;
let InlineSuggestion = class InlineSuggestion {
    constructor(insertText, range, command) {
        this.insertText = insertText;
        this.range = range;
        this.command = command;
    }
};
InlineSuggestion = InlineSuggestion;
let InlineSuggestionList = class InlineSuggestionList {
    constructor(items) {
        this.commands = undefined;
        this.items = items;
    }
};
InlineSuggestionList = InlineSuggestionList;
var ViewColumn$1;
 (function(ViewColumn) {
    ViewColumn[ViewColumn["Active"] = -1] = "Active";
    ViewColumn[ViewColumn["Beside"] = -2] = "Beside";
    ViewColumn[ViewColumn["One"] = 1] = "One";
    ViewColumn[ViewColumn["Two"] = 2] = "Two";
    ViewColumn[ViewColumn["Three"] = 3] = "Three";
    ViewColumn[ViewColumn["Four"] = 4] = "Four";
    ViewColumn[ViewColumn["Five"] = 5] = "Five";
    ViewColumn[ViewColumn["Six"] = 6] = "Six";
    ViewColumn[ViewColumn["Seven"] = 7] = "Seven";
    ViewColumn[ViewColumn["Eight"] = 8] = "Eight";
    ViewColumn[ViewColumn["Nine"] = 9] = "Nine";
})(ViewColumn$1 || (ViewColumn$1 = {}));
var StatusBarAlignment$1;
 (function(StatusBarAlignment) {
    StatusBarAlignment[StatusBarAlignment["Left"] = 1] = "Left";
    StatusBarAlignment[StatusBarAlignment["Right"] = 2] = "Right";
})(StatusBarAlignment$1 || (StatusBarAlignment$1 = {}));
var TextEditorLineNumbersStyle$1;
 (function(TextEditorLineNumbersStyle) {
    TextEditorLineNumbersStyle[TextEditorLineNumbersStyle["Off"] = 0] = "Off";
    TextEditorLineNumbersStyle[TextEditorLineNumbersStyle["On"] = 1] = "On";
    TextEditorLineNumbersStyle[TextEditorLineNumbersStyle["Relative"] = 2] = "Relative";
})(TextEditorLineNumbersStyle$1 || (TextEditorLineNumbersStyle$1 = {}));
var TextDocumentSaveReason$1;
 (function(TextDocumentSaveReason) {
    TextDocumentSaveReason[TextDocumentSaveReason["Manual"] = 1] = "Manual";
    TextDocumentSaveReason[TextDocumentSaveReason["AfterDelay"] = 2] = "AfterDelay";
    TextDocumentSaveReason[TextDocumentSaveReason["FocusOut"] = 3] = "FocusOut";
})(TextDocumentSaveReason$1 || (TextDocumentSaveReason$1 = {}));
var TextEditorRevealType$1;
 (function(TextEditorRevealType) {
    TextEditorRevealType[TextEditorRevealType["Default"] = 0] = "Default";
    TextEditorRevealType[TextEditorRevealType["InCenter"] = 1] = "InCenter";
    TextEditorRevealType[TextEditorRevealType["InCenterIfOutsideViewport"] = 2] = "InCenterIfOutsideViewport";
    TextEditorRevealType[TextEditorRevealType["AtTop"] = 3] = "AtTop";
})(TextEditorRevealType$1 || (TextEditorRevealType$1 = {}));
var TextEditorSelectionChangeKind$1;
 (function(TextEditorSelectionChangeKind) {
    TextEditorSelectionChangeKind[TextEditorSelectionChangeKind["Keyboard"] = 1] = "Keyboard";
    TextEditorSelectionChangeKind[TextEditorSelectionChangeKind["Mouse"] = 2] = "Mouse";
    TextEditorSelectionChangeKind[TextEditorSelectionChangeKind["Command"] = 3] = "Command";
})(TextEditorSelectionChangeKind$1 || (TextEditorSelectionChangeKind$1 = {}));
var TextDocumentChangeReason$1;
 (function(TextDocumentChangeReason) {
    TextDocumentChangeReason[TextDocumentChangeReason["Undo"] = 1] = "Undo";
    TextDocumentChangeReason[TextDocumentChangeReason["Redo"] = 2] = "Redo";
})(TextDocumentChangeReason$1 || (TextDocumentChangeReason$1 = {}));
var DecorationRangeBehavior$1;
 (function(DecorationRangeBehavior) {
    DecorationRangeBehavior[DecorationRangeBehavior["OpenOpen"] = 0] = "OpenOpen";
    DecorationRangeBehavior[DecorationRangeBehavior["ClosedClosed"] = 1] = "ClosedClosed";
    DecorationRangeBehavior[DecorationRangeBehavior["OpenClosed"] = 2] = "OpenClosed";
    DecorationRangeBehavior[DecorationRangeBehavior["ClosedOpen"] = 3] = "ClosedOpen";
})(DecorationRangeBehavior$1 || (DecorationRangeBehavior$1 = {}));
 (function(TextEditorSelectionChangeKind) {
    function fromValue(s) {
        switch (s) {
            case 'keyboard': return TextEditorSelectionChangeKind.Keyboard;
            case 'mouse': return TextEditorSelectionChangeKind.Mouse;
            case 'api': return TextEditorSelectionChangeKind.Command;
        }
        return undefined;
    }
    TextEditorSelectionChangeKind.fromValue = fromValue;
})(TextEditorSelectionChangeKind$1 || (TextEditorSelectionChangeKind$1 = {}));
let DocumentLink$2 = class DocumentLink {
    constructor(range, target) {
        if (target && !(URI.isUri(target))) {
            throw illegalArgument('target');
        }
        if (!Range$3.isRange(range) || range.isEmpty) {
            throw illegalArgument('range');
        }
        this.range = range;
        this.target = target;
    }
};
DocumentLink$2 = DocumentLink$2;
let Color$2 = class Color {
    constructor(red, green, blue, alpha) {
        this.red = red;
        this.green = green;
        this.blue = blue;
        this.alpha = alpha;
    }
};
Color$2 = Color$2;
let ColorInformation$1 = class ColorInformation {
    constructor(range, color) {
        if (color && !(color instanceof Color$2)) {
            throw illegalArgument('color');
        }
        if (!Range$3.isRange(range) || range.isEmpty) {
            throw illegalArgument('range');
        }
        this.range = range;
        this.color = color;
    }
};
ColorInformation$1 = ColorInformation$1;
let ColorPresentation$2 = class ColorPresentation {
    constructor(label) {
        if (!label || typeof label !== 'string') {
            throw illegalArgument('label');
        }
        this.label = label;
    }
};
ColorPresentation$2 = ColorPresentation$2;
class TerminalLink$1 {
    constructor(startIndex, length, tooltip) {
        this.startIndex = startIndex;
        this.length = length;
        this.tooltip = tooltip;
        if (typeof startIndex !== 'number' || startIndex < 0) {
            throw illegalArgument('startIndex');
        }
        if (typeof length !== 'number' || length < 1) {
            throw illegalArgument('length');
        }
        if (tooltip !== undefined && typeof tooltip !== 'string') {
            throw illegalArgument('tooltip');
        }
    }
}
var TerminalLocation$1;
 (function(TerminalLocation) {
    TerminalLocation[TerminalLocation["Panel"] = 1] = "Panel";
    TerminalLocation[TerminalLocation["Editor"] = 2] = "Editor";
})(TerminalLocation$1 || (TerminalLocation$1 = {}));
class TerminalProfile$1 {
    constructor(options) {
        this.options = options;
        if (typeof options !== 'object') {
            throw illegalArgument('options');
        }
    }
}
var TaskRevealKind$1;
 (function(TaskRevealKind) {
    TaskRevealKind[TaskRevealKind["Always"] = 1] = "Always";
    TaskRevealKind[TaskRevealKind["Silent"] = 2] = "Silent";
    TaskRevealKind[TaskRevealKind["Never"] = 3] = "Never";
})(TaskRevealKind$1 || (TaskRevealKind$1 = {}));
var TaskPanelKind$1;
 (function(TaskPanelKind) {
    TaskPanelKind[TaskPanelKind["Shared"] = 1] = "Shared";
    TaskPanelKind[TaskPanelKind["Dedicated"] = 2] = "Dedicated";
    TaskPanelKind[TaskPanelKind["New"] = 3] = "New";
})(TaskPanelKind$1 || (TaskPanelKind$1 = {}));
let TaskGroup$1 = TaskGroup_1 = class TaskGroup {
    constructor(id, label) {
        this.label = label;
        if (typeof id !== 'string') {
            throw illegalArgument('name');
        }
        if (typeof label !== 'string') {
            throw illegalArgument('name');
        }
        this._id = id;
    }
    static from(value) {
        switch (value) {
            case 'clean':
                return TaskGroup_1.Clean;
            case 'build':
                return TaskGroup_1.Build;
            case 'rebuild':
                return TaskGroup_1.Rebuild;
            case 'test':
                return TaskGroup_1.Test;
            default:
                return undefined;
        }
    }
    get id() {
        return this._id;
    }
};
TaskGroup$1.Clean =  new TaskGroup_1('clean', 'Clean');
TaskGroup$1.Build =  new TaskGroup_1('build', 'Build');
TaskGroup$1.Rebuild =  new TaskGroup_1('rebuild', 'Rebuild');
TaskGroup$1.Test =  new TaskGroup_1('test', 'Test');
TaskGroup$1 = TaskGroup_1 = TaskGroup$1;
function computeTaskExecutionId(values) {
    let id = '';
    for (let i = 0; i < values.length; i++) {
        id += values[i].replace(/,/g, ',,') + ',';
    }
    return id;
}
let ProcessExecution$1 = class ProcessExecution {
    constructor(process, varg1, varg2) {
        if (typeof process !== 'string') {
            throw illegalArgument('process');
        }
        this._args = [];
        this._process = process;
        if (varg1 !== undefined) {
            if (Array.isArray(varg1)) {
                this._args = varg1;
                this._options = varg2;
            }
            else {
                this._options = varg1;
            }
        }
    }
    get process() {
        return this._process;
    }
    set process(value) {
        if (typeof value !== 'string') {
            throw illegalArgument('process');
        }
        this._process = value;
    }
    get args() {
        return this._args;
    }
    set args(value) {
        if (!Array.isArray(value)) {
            value = [];
        }
        this._args = value;
    }
    get options() {
        return this._options;
    }
    set options(value) {
        this._options = value;
    }
    computeId() {
        const props = [];
        props.push('process');
        if (this._process !== undefined) {
            props.push(this._process);
        }
        if (this._args && this._args.length > 0) {
            for (let arg of this._args) {
                props.push(arg);
            }
        }
        return computeTaskExecutionId(props);
    }
};
ProcessExecution$1 = ProcessExecution$1;
let ShellExecution$1 = class ShellExecution {
    constructor(arg0, arg1, arg2) {
        this._args = [];
        if (Array.isArray(arg1)) {
            if (!arg0) {
                throw illegalArgument('command can\'t be undefined or null');
            }
            if (typeof arg0 !== 'string' && typeof arg0.value !== 'string') {
                throw illegalArgument('command');
            }
            this._command = arg0;
            this._args = arg1;
            this._options = arg2;
        }
        else {
            if (typeof arg0 !== 'string') {
                throw illegalArgument('commandLine');
            }
            this._commandLine = arg0;
            this._options = arg1;
        }
    }
    get commandLine() {
        return this._commandLine;
    }
    set commandLine(value) {
        if (typeof value !== 'string') {
            throw illegalArgument('commandLine');
        }
        this._commandLine = value;
    }
    get command() {
        return this._command ? this._command : '';
    }
    set command(value) {
        if (typeof value !== 'string' && typeof value.value !== 'string') {
            throw illegalArgument('command');
        }
        this._command = value;
    }
    get args() {
        return this._args;
    }
    set args(value) {
        this._args = value || [];
    }
    get options() {
        return this._options;
    }
    set options(value) {
        this._options = value;
    }
    computeId() {
        const props = [];
        props.push('shell');
        if (this._commandLine !== undefined) {
            props.push(this._commandLine);
        }
        if (this._command !== undefined) {
            props.push(typeof this._command === 'string' ? this._command : this._command.value);
        }
        if (this._args && this._args.length > 0) {
            for (let arg of this._args) {
                props.push(typeof arg === 'string' ? arg : arg.value);
            }
        }
        return computeTaskExecutionId(props);
    }
};
ShellExecution$1 = ShellExecution$1;
var ShellQuoting$1;
 (function(ShellQuoting) {
    ShellQuoting[ShellQuoting["Escape"] = 1] = "Escape";
    ShellQuoting[ShellQuoting["Strong"] = 2] = "Strong";
    ShellQuoting[ShellQuoting["Weak"] = 3] = "Weak";
})(ShellQuoting$1 || (ShellQuoting$1 = {}));
var TaskScope$1;
 (function(TaskScope) {
    TaskScope[TaskScope["Global"] = 1] = "Global";
    TaskScope[TaskScope["Workspace"] = 2] = "Workspace";
})(TaskScope$1 || (TaskScope$1 = {}));
class CustomExecution$1 {
    constructor(callback) {
        this._callback = callback;
    }
    computeId() {
        return 'customExecution' + generateUuid();
    }
    set callback(value) {
        this._callback = value;
    }
    get callback() {
        return this._callback;
    }
}
let Task$1 = Task_1 = class Task {
    constructor(definition, arg2, arg3, arg4, arg5, arg6) {
        this.__deprecated = false;
        this._definition = this.definition = definition;
        let problemMatchers;
        if (typeof arg2 === 'string') {
            this._name = this.name = arg2;
            this._source = this.source = arg3;
            this.execution = arg4;
            problemMatchers = arg5;
            this.__deprecated = true;
        }
        else if (arg2 === TaskScope$1.Global || arg2 === TaskScope$1.Workspace) {
            this.target = arg2;
            this._name = this.name = arg3;
            this._source = this.source = arg4;
            this.execution = arg5;
            problemMatchers = arg6;
        }
        else {
            this.target = arg2;
            this._name = this.name = arg3;
            this._source = this.source = arg4;
            this.execution = arg5;
            problemMatchers = arg6;
        }
        if (typeof problemMatchers === 'string') {
            this._problemMatchers = [problemMatchers];
            this._hasDefinedMatchers = true;
        }
        else if (Array.isArray(problemMatchers)) {
            this._problemMatchers = problemMatchers;
            this._hasDefinedMatchers = true;
        }
        else {
            this._problemMatchers = [];
            this._hasDefinedMatchers = false;
        }
        this._isBackground = false;
        this._presentationOptions = Object.create(null);
        this._runOptions = Object.create(null);
    }
    get _id() {
        return this.__id;
    }
    set _id(value) {
        this.__id = value;
    }
    get _deprecated() {
        return this.__deprecated;
    }
    clear() {
        if (this.__id === undefined) {
            return;
        }
        this.__id = undefined;
        this._scope = undefined;
        this.computeDefinitionBasedOnExecution();
    }
    computeDefinitionBasedOnExecution() {
        if (this._execution instanceof ProcessExecution$1) {
            this._definition = {
                type: Task_1.ProcessType,
                id: this._execution.computeId()
            };
        }
        else if (this._execution instanceof ShellExecution$1) {
            this._definition = {
                type: Task_1.ShellType,
                id: this._execution.computeId()
            };
        }
        else if (this._execution instanceof CustomExecution$1) {
            this._definition = {
                type: Task_1.ExtensionCallbackType,
                id: this._execution.computeId()
            };
        }
        else {
            this._definition = {
                type: Task_1.EmptyType,
                id: generateUuid()
            };
        }
    }
    get definition() {
        return this._definition;
    }
    set definition(value) {
        if (value === undefined || value === null) {
            throw illegalArgument('Kind can\'t be undefined or null');
        }
        this.clear();
        this._definition = value;
    }
    get scope() {
        return this._scope;
    }
    set target(value) {
        this.clear();
        this._scope = value;
    }
    get name() {
        return this._name;
    }
    set name(value) {
        if (typeof value !== 'string') {
            throw illegalArgument('name');
        }
        this.clear();
        this._name = value;
    }
    get execution() {
        return this._execution;
    }
    set execution(value) {
        if (value === null) {
            value = undefined;
        }
        this.clear();
        this._execution = value;
        const type = this._definition.type;
        if (Task_1.EmptyType === type || Task_1.ProcessType === type || Task_1.ShellType === type || Task_1.ExtensionCallbackType === type) {
            this.computeDefinitionBasedOnExecution();
        }
    }
    get problemMatchers() {
        return this._problemMatchers;
    }
    set problemMatchers(value) {
        if (!Array.isArray(value)) {
            this.clear();
            this._problemMatchers = [];
            this._hasDefinedMatchers = false;
            return;
        }
        else {
            this.clear();
            this._problemMatchers = value;
            this._hasDefinedMatchers = true;
        }
    }
    get hasDefinedMatchers() {
        return this._hasDefinedMatchers;
    }
    get isBackground() {
        return this._isBackground;
    }
    set isBackground(value) {
        if (value !== true && value !== false) {
            value = false;
        }
        this.clear();
        this._isBackground = value;
    }
    get source() {
        return this._source;
    }
    set source(value) {
        if (typeof value !== 'string' || value.length === 0) {
            throw illegalArgument('source must be a string of length > 0');
        }
        this.clear();
        this._source = value;
    }
    get group() {
        return this._group;
    }
    set group(value) {
        if (value === null) {
            value = undefined;
        }
        this.clear();
        this._group = value;
    }
    get detail() {
        return this._detail;
    }
    set detail(value) {
        if (value === null) {
            value = undefined;
        }
        this._detail = value;
    }
    get presentationOptions() {
        return this._presentationOptions;
    }
    set presentationOptions(value) {
        if (value === null || value === undefined) {
            value = Object.create(null);
        }
        this.clear();
        this._presentationOptions = value;
    }
    get runOptions() {
        return this._runOptions;
    }
    set runOptions(value) {
        if (value === null || value === undefined) {
            value = Object.create(null);
        }
        this.clear();
        this._runOptions = value;
    }
};
Task$1.ExtensionCallbackType = 'customExecution';
Task$1.ProcessType = 'process';
Task$1.ShellType = 'shell';
Task$1.EmptyType = '$empty';
Task$1 = Task_1 = Task$1;
var ProgressLocation$1;
 (function(ProgressLocation) {
    ProgressLocation[ProgressLocation["SourceControl"] = 1] = "SourceControl";
    ProgressLocation[ProgressLocation["Window"] = 10] = "Window";
    ProgressLocation[ProgressLocation["Notification"] = 15] = "Notification";
})(ProgressLocation$1 || (ProgressLocation$1 = {}));
let TreeItem$1 = class TreeItem {
    constructor(arg1, collapsibleState = TreeItemCollapsibleState$1.None) {
        this.collapsibleState = collapsibleState;
        if (URI.isUri(arg1)) {
            this.resourceUri = arg1;
        }
        else {
            this.label = arg1;
        }
    }
};
TreeItem$1 = TreeItem$1;
var TreeItemCollapsibleState$1;
 (function(TreeItemCollapsibleState) {
    TreeItemCollapsibleState[TreeItemCollapsibleState["None"] = 0] = "None";
    TreeItemCollapsibleState[TreeItemCollapsibleState["Collapsed"] = 1] = "Collapsed";
    TreeItemCollapsibleState[TreeItemCollapsibleState["Expanded"] = 2] = "Expanded";
})(TreeItemCollapsibleState$1 || (TreeItemCollapsibleState$1 = {}));
let DataTransferItem$1 = class DataTransferItem {
    constructor(value) {
        this.value = value;
    }
    async asString() {
        return typeof this.value === 'string' ? this.value : JSON.stringify(this.value);
    }
    asFile() {
        return undefined;
    }
};
DataTransferItem$1 = DataTransferItem$1;
let DataTransfer$1 = class DataTransfer {
    constructor(init) {
        _DataTransfer_items.set(this,  new Map());
        for (const [mime, item] of init ?? []) {
            const existing = __classPrivateFieldGet(this, _DataTransfer_items, "f").get(mime);
            if (existing) {
                existing.push(item);
            }
            else {
                __classPrivateFieldGet(this, _DataTransfer_items, "f").set(mime, [item]);
            }
        }
    }
    get(mimeType) {
        return __classPrivateFieldGet(this, _DataTransfer_items, "f").get(mimeType)?.[0];
    }
    set(mimeType, value) {
        __classPrivateFieldGet(this, _DataTransfer_items, "f").set(mimeType, [value]);
    }
    forEach(callbackfn) {
        for (const [mime, items] of __classPrivateFieldGet(this, _DataTransfer_items, "f")) {
            items.forEach(item => callbackfn(item, mime));
        }
    }
};
_DataTransfer_items =  new WeakMap();
DataTransfer$1 = DataTransfer$1;
let ThemeIcon$1 = class ThemeIcon {
    constructor(id, color) {
        this.id = id;
        this.color = color;
    }
};
ThemeIcon$1 = ThemeIcon$1;
ThemeIcon$1.File =  new ThemeIcon$1('file');
ThemeIcon$1.Folder =  new ThemeIcon$1('folder');
let ThemeColor$1 = class ThemeColor {
    constructor(id) {
        this.id = id;
    }
};
ThemeColor$1 = ThemeColor$1;
var ConfigurationTarget$1;
 (function(ConfigurationTarget) {
    ConfigurationTarget[ConfigurationTarget["Global"] = 1] = "Global";
    ConfigurationTarget[ConfigurationTarget["Workspace"] = 2] = "Workspace";
    ConfigurationTarget[ConfigurationTarget["WorkspaceFolder"] = 3] = "WorkspaceFolder";
})(ConfigurationTarget$1 || (ConfigurationTarget$1 = {}));
let RelativePattern$1 = class RelativePattern {
    constructor(base, pattern) {
        if (typeof base !== 'string') {
            if (!base || !URI.isUri(base) && !URI.isUri(base.uri)) {
                throw illegalArgument('base');
            }
        }
        if (typeof pattern !== 'string') {
            throw illegalArgument('pattern');
        }
        if (typeof base === 'string') {
            this.baseUri = URI.file(base);
        }
        else if (URI.isUri(base)) {
            this.baseUri = base;
        }
        else {
            this.baseUri = base.uri;
        }
        this.pattern = pattern;
    }
    get base() {
        return this._base;
    }
    set base(base) {
        this._base = base;
        this._baseUri = URI.file(base);
    }
    get baseUri() {
        return this._baseUri;
    }
    set baseUri(baseUri) {
        this._baseUri = baseUri;
        this._base = baseUri.fsPath;
    }
    toJSON() {
        return {
            pattern: this.pattern,
            base: this.base,
            baseUri: this.baseUri.toJSON()
        };
    }
};
RelativePattern$1 = RelativePattern$1;
let Breakpoint$1 = class Breakpoint {
    constructor(enabled, condition, hitCondition, logMessage) {
        this.enabled = typeof enabled === 'boolean' ? enabled : true;
        if (typeof condition === 'string') {
            this.condition = condition;
        }
        if (typeof hitCondition === 'string') {
            this.hitCondition = hitCondition;
        }
        if (typeof logMessage === 'string') {
            this.logMessage = logMessage;
        }
    }
    get id() {
        if (!this._id) {
            this._id = generateUuid();
        }
        return this._id;
    }
};
Breakpoint$1 = Breakpoint$1;
let SourceBreakpoint$1 = class SourceBreakpoint extends Breakpoint$1 {
    constructor(location, enabled, condition, hitCondition, logMessage) {
        super(enabled, condition, hitCondition, logMessage);
        if (location === null) {
            throw illegalArgument('location');
        }
        this.location = location;
    }
};
SourceBreakpoint$1 = SourceBreakpoint$1;
let FunctionBreakpoint$1 = class FunctionBreakpoint extends Breakpoint$1 {
    constructor(functionName, enabled, condition, hitCondition, logMessage) {
        super(enabled, condition, hitCondition, logMessage);
        this.functionName = functionName;
    }
};
FunctionBreakpoint$1 = FunctionBreakpoint$1;
let DebugAdapterExecutable$1 = class DebugAdapterExecutable {
    constructor(command, args, options) {
        this.command = command;
        this.args = args || [];
        this.options = options;
    }
};
DebugAdapterExecutable$1 = DebugAdapterExecutable$1;
let DebugAdapterServer$1 = class DebugAdapterServer {
    constructor(port, host) {
        this.port = port;
        this.host = host;
    }
};
DebugAdapterServer$1 = DebugAdapterServer$1;
let DebugAdapterNamedPipeServer$1 = class DebugAdapterNamedPipeServer {
    constructor(path) {
        this.path = path;
    }
};
DebugAdapterNamedPipeServer$1 = DebugAdapterNamedPipeServer$1;
let DebugAdapterInlineImplementation$1 = class DebugAdapterInlineImplementation {
    constructor(impl) {
        this.implementation = impl;
    }
};
DebugAdapterInlineImplementation$1 = DebugAdapterInlineImplementation$1;
let EvaluatableExpression$2 = class EvaluatableExpression {
    constructor(range, expression) {
        this.range = range;
        this.expression = expression;
    }
};
EvaluatableExpression$2 = EvaluatableExpression$2;
var InlineCompletionTriggerKind$1;
 (function(InlineCompletionTriggerKind) {
    InlineCompletionTriggerKind[InlineCompletionTriggerKind["Invoke"] = 0] = "Invoke";
    InlineCompletionTriggerKind[InlineCompletionTriggerKind["Automatic"] = 1] = "Automatic";
})(InlineCompletionTriggerKind$1 || (InlineCompletionTriggerKind$1 = {}));
let InlineValueText$1 = class InlineValueText {
    constructor(range, text) {
        this.range = range;
        this.text = text;
    }
};
InlineValueText$1 = InlineValueText$1;
let InlineValueVariableLookup$1 = class InlineValueVariableLookup {
    constructor(range, variableName, caseSensitiveLookup = true) {
        this.range = range;
        this.variableName = variableName;
        this.caseSensitiveLookup = caseSensitiveLookup;
    }
};
InlineValueVariableLookup$1 = InlineValueVariableLookup$1;
let InlineValueEvaluatableExpression$1 = class InlineValueEvaluatableExpression {
    constructor(range, expression) {
        this.range = range;
        this.expression = expression;
    }
};
InlineValueEvaluatableExpression$1 = InlineValueEvaluatableExpression$1;
var FileChangeType$1;
 (function(FileChangeType) {
    FileChangeType[FileChangeType["Changed"] = 1] = "Changed";
    FileChangeType[FileChangeType["Created"] = 2] = "Created";
    FileChangeType[FileChangeType["Deleted"] = 3] = "Deleted";
})(FileChangeType$1 || (FileChangeType$1 = {}));
let FileSystemError$1 = FileSystemError_1 = class FileSystemError extends Error {
    constructor(uriOrMessage, code = FileSystemProviderErrorCode.Unknown, terminator) {
        super(URI.isUri(uriOrMessage) ? uriOrMessage.toString(true) : uriOrMessage);
        this.code = terminator?.name ?? 'Unknown';
        markAsFileSystemProviderError(this, code);
        if (typeof Object.setPrototypeOf === 'function') {
            Object.setPrototypeOf(this, FileSystemError_1.prototype);
        }
        if (typeof Error.captureStackTrace === 'function' && typeof terminator === 'function') {
            Error.captureStackTrace(this, terminator);
        }
    }
    static FileExists(messageOrUri) {
        return (
             new FileSystemError_1(
                messageOrUri,
                FileSystemProviderErrorCode.FileExists,
                FileSystemError_1.FileExists
            )
        );
    }
    static FileNotFound(messageOrUri) {
        return (
             new FileSystemError_1(
                messageOrUri,
                FileSystemProviderErrorCode.FileNotFound,
                FileSystemError_1.FileNotFound
            )
        );
    }
    static FileNotADirectory(messageOrUri) {
        return (
             new FileSystemError_1(
                messageOrUri,
                FileSystemProviderErrorCode.FileNotADirectory,
                FileSystemError_1.FileNotADirectory
            )
        );
    }
    static FileIsADirectory(messageOrUri) {
        return (
             new FileSystemError_1(
                messageOrUri,
                FileSystemProviderErrorCode.FileIsADirectory,
                FileSystemError_1.FileIsADirectory
            )
        );
    }
    static NoPermissions(messageOrUri) {
        return (
             new FileSystemError_1(
                messageOrUri,
                FileSystemProviderErrorCode.NoPermissions,
                FileSystemError_1.NoPermissions
            )
        );
    }
    static Unavailable(messageOrUri) {
        return (
             new FileSystemError_1(
                messageOrUri,
                FileSystemProviderErrorCode.Unavailable,
                FileSystemError_1.Unavailable
            )
        );
    }
};
FileSystemError$1 = FileSystemError_1 = FileSystemError$1;
let FoldingRange$2 = class FoldingRange {
    constructor(start, end, kind) {
        this.start = start;
        this.end = end;
        this.kind = kind;
    }
};
FoldingRange$2 = FoldingRange$2;
var FoldingRangeKind$3;
 (function(FoldingRangeKind) {
    FoldingRangeKind[FoldingRangeKind["Comment"] = 1] = "Comment";
    FoldingRangeKind[FoldingRangeKind["Imports"] = 2] = "Imports";
    FoldingRangeKind[FoldingRangeKind["Region"] = 3] = "Region";
})(FoldingRangeKind$3 || (FoldingRangeKind$3 = {}));
var CommentThreadCollapsibleState$1;
 (function(CommentThreadCollapsibleState) {
    CommentThreadCollapsibleState[CommentThreadCollapsibleState["Collapsed"] = 0] = "Collapsed";
    CommentThreadCollapsibleState[CommentThreadCollapsibleState["Expanded"] = 1] = "Expanded";
})(CommentThreadCollapsibleState$1 || (CommentThreadCollapsibleState$1 = {}));
var CommentMode$1;
 (function(CommentMode) {
    CommentMode[CommentMode["Editing"] = 0] = "Editing";
    CommentMode[CommentMode["Preview"] = 1] = "Preview";
})(CommentMode$1 || (CommentMode$1 = {}));
class SemanticTokensLegend$1 {
    constructor(tokenTypes, tokenModifiers = []) {
        this.tokenTypes = tokenTypes;
        this.tokenModifiers = tokenModifiers;
    }
}
function isStrArrayOrUndefined(arg) {
    return ((typeof arg === 'undefined') || isStringArray(arg));
}
class SemanticTokensBuilder$1 {
    constructor(legend) {
        this._prevLine = 0;
        this._prevChar = 0;
        this._dataIsSortedAndDeltaEncoded = true;
        this._data = [];
        this._dataLen = 0;
        this._tokenTypeStrToInt =  new Map();
        this._tokenModifierStrToInt =  new Map();
        this._hasLegend = false;
        if (legend) {
            this._hasLegend = true;
            for (let i = 0, len = legend.tokenTypes.length; i < len; i++) {
                this._tokenTypeStrToInt.set(legend.tokenTypes[i], i);
            }
            for (let i = 0, len = legend.tokenModifiers.length; i < len; i++) {
                this._tokenModifierStrToInt.set(legend.tokenModifiers[i], i);
            }
        }
    }
    push(arg0, arg1, arg2, arg3, arg4) {
        if (typeof arg0 === 'number' && typeof arg1 === 'number' && typeof arg2 === 'number' && typeof arg3 === 'number' && (typeof arg4 === 'number' || typeof arg4 === 'undefined')) {
            if (typeof arg4 === 'undefined') {
                arg4 = 0;
            }
            return this._pushEncoded(arg0, arg1, arg2, arg3, arg4);
        }
        if (Range$3.isRange(arg0) && typeof arg1 === 'string' && isStrArrayOrUndefined(arg2)) {
            return this._push(arg0, arg1, arg2);
        }
        throw illegalArgument();
    }
    _push(range, tokenType, tokenModifiers) {
        if (!this._hasLegend) {
            throw new Error('Legend must be provided in constructor');
        }
        if (range.start.line !== range.end.line) {
            throw new Error('`range` cannot span multiple lines');
        }
        if (!this._tokenTypeStrToInt.has(tokenType)) {
            throw new Error('`tokenType` is not in the provided legend');
        }
        const line = range.start.line;
        const char = range.start.character;
        const length = range.end.character - range.start.character;
        const nTokenType = this._tokenTypeStrToInt.get(tokenType);
        let nTokenModifiers = 0;
        if (tokenModifiers) {
            for (const tokenModifier of tokenModifiers) {
                if (!this._tokenModifierStrToInt.has(tokenModifier)) {
                    throw new Error('`tokenModifier` is not in the provided legend');
                }
                const nTokenModifier = this._tokenModifierStrToInt.get(tokenModifier);
                nTokenModifiers |= (1 << nTokenModifier) >>> 0;
            }
        }
        this._pushEncoded(line, char, length, nTokenType, nTokenModifiers);
    }
    _pushEncoded(line, char, length, tokenType, tokenModifiers) {
        if (this._dataIsSortedAndDeltaEncoded && (line < this._prevLine || (line === this._prevLine && char < this._prevChar))) {
            this._dataIsSortedAndDeltaEncoded = false;
            const tokenCount = (this._data.length / 5) | 0;
            let prevLine = 0;
            let prevChar = 0;
            for (let i = 0; i < tokenCount; i++) {
                let line = this._data[5 * i];
                let char = this._data[5 * i + 1];
                if (line === 0) {
                    line = prevLine;
                    char += prevChar;
                }
                else {
                    line += prevLine;
                }
                this._data[5 * i] = line;
                this._data[5 * i + 1] = char;
                prevLine = line;
                prevChar = char;
            }
        }
        let pushLine = line;
        let pushChar = char;
        if (this._dataIsSortedAndDeltaEncoded && this._dataLen > 0) {
            pushLine -= this._prevLine;
            if (pushLine === 0) {
                pushChar -= this._prevChar;
            }
        }
        this._data[this._dataLen++] = pushLine;
        this._data[this._dataLen++] = pushChar;
        this._data[this._dataLen++] = length;
        this._data[this._dataLen++] = tokenType;
        this._data[this._dataLen++] = tokenModifiers;
        this._prevLine = line;
        this._prevChar = char;
    }
    static _sortAndDeltaEncode(data) {
        let pos = [];
        const tokenCount = (data.length / 5) | 0;
        for (let i = 0; i < tokenCount; i++) {
            pos[i] = i;
        }
        pos.sort((a, b) => {
            const aLine = data[5 * a];
            const bLine = data[5 * b];
            if (aLine === bLine) {
                const aChar = data[5 * a + 1];
                const bChar = data[5 * b + 1];
                return aChar - bChar;
            }
            return aLine - bLine;
        });
        const result =  new Uint32Array(data.length);
        let prevLine = 0;
        let prevChar = 0;
        for (let i = 0; i < tokenCount; i++) {
            const srcOffset = 5 * pos[i];
            const line = data[srcOffset + 0];
            const char = data[srcOffset + 1];
            const length = data[srcOffset + 2];
            const tokenType = data[srcOffset + 3];
            const tokenModifiers = data[srcOffset + 4];
            const pushLine = line - prevLine;
            const pushChar = (pushLine === 0 ? char - prevChar : char);
            const dstOffset = 5 * i;
            result[dstOffset + 0] = pushLine;
            result[dstOffset + 1] = pushChar;
            result[dstOffset + 2] = length;
            result[dstOffset + 3] = tokenType;
            result[dstOffset + 4] = tokenModifiers;
            prevLine = line;
            prevChar = char;
        }
        return result;
    }
    build(resultId) {
        if (!this._dataIsSortedAndDeltaEncoded) {
            return (
                 new SemanticTokens$1(SemanticTokensBuilder$1._sortAndDeltaEncode(this._data), resultId)
            );
        }
        return (
             new SemanticTokens$1( new Uint32Array(this._data), resultId)
        );
    }
}
class SemanticTokens$1 {
    constructor(data, resultId) {
        this.resultId = resultId;
        this.data = data;
    }
}
class SemanticTokensEdit$1 {
    constructor(start, deleteCount, data) {
        this.start = start;
        this.deleteCount = deleteCount;
        this.data = data;
    }
}
class SemanticTokensEdits$1 {
    constructor(edits, resultId) {
        this.resultId = resultId;
        this.edits = edits;
    }
}
var DebugConsoleMode$1;
 (function(DebugConsoleMode) {
    DebugConsoleMode[DebugConsoleMode["Separate"] = 0] = "Separate";
    DebugConsoleMode[DebugConsoleMode["MergeWithParent"] = 1] = "MergeWithParent";
})(DebugConsoleMode$1 || (DebugConsoleMode$1 = {}));
let QuickInputButtons$1 = class QuickInputButtons {
    constructor() { }
};
QuickInputButtons$1.Back = { iconPath:  new ThemeIcon$1('arrow-left') };
QuickInputButtons$1 = QuickInputButtons$1;
var QuickPickItemKind$1;
 (function(QuickPickItemKind) {
    QuickPickItemKind[QuickPickItemKind["Separator"] = -1] = "Separator";
    QuickPickItemKind[QuickPickItemKind["Default"] = 0] = "Default";
})(QuickPickItemKind$1 || (QuickPickItemKind$1 = {}));
var InputBoxValidationSeverity$1;
 (function(InputBoxValidationSeverity) {
    InputBoxValidationSeverity[InputBoxValidationSeverity["Info"] = 1] = "Info";
    InputBoxValidationSeverity[InputBoxValidationSeverity["Warning"] = 2] = "Warning";
    InputBoxValidationSeverity[InputBoxValidationSeverity["Error"] = 3] = "Error";
})(InputBoxValidationSeverity$1 || (InputBoxValidationSeverity$1 = {}));
var ExtensionKind$1;
 (function(ExtensionKind) {
    ExtensionKind[ExtensionKind["UI"] = 1] = "UI";
    ExtensionKind[ExtensionKind["Workspace"] = 2] = "Workspace";
})(ExtensionKind$1 || (ExtensionKind$1 = {}));
class FileDecoration$1 {
    constructor(badge, tooltip, color) {
        this.badge = badge;
        this.tooltip = tooltip;
        this.color = color;
    }
    static validate(d) {
        if (d.badge) {
            let len = nextCharLength(d.badge, 0);
            if (len < d.badge.length) {
                len += nextCharLength(d.badge, len);
            }
            if (d.badge.length > len) {
                throw new Error(`The 'badge'-property must be undefined or a short character`);
            }
        }
        if (!d.color && !d.badge && !d.tooltip) {
            throw new Error(`The decoration is empty`);
        }
        return true;
    }
}
var ColorThemeKind$1;
 (function(ColorThemeKind) {
    ColorThemeKind[ColorThemeKind["Light"] = 1] = "Light";
    ColorThemeKind[ColorThemeKind["Dark"] = 2] = "Dark";
    ColorThemeKind[ColorThemeKind["HighContrast"] = 3] = "HighContrast";
    ColorThemeKind[ColorThemeKind["HighContrastLight"] = 4] = "HighContrastLight";
})(ColorThemeKind$1 || (ColorThemeKind$1 = {}));
class NotebookRange$2 {
    constructor(start, end) {
        if (start < 0) {
            throw illegalArgument('start must be positive');
        }
        if (end < 0) {
            throw illegalArgument('end must be positive');
        }
        if (start <= end) {
            this._start = start;
            this._end = end;
        }
        else {
            this._start = end;
            this._end = start;
        }
    }
    static isNotebookRange(thing) {
        if (thing instanceof NotebookRange$2) {
            return true;
        }
        if (!thing) {
            return false;
        }
        return typeof thing.start === 'number'
            && typeof thing.end === 'number';
    }
    get start() {
        return this._start;
    }
    get end() {
        return this._end;
    }
    get isEmpty() {
        return this._start === this._end;
    }
    with(change) {
        let start = this._start;
        let end = this._end;
        if (change.start !== undefined) {
            start = change.start;
        }
        if (change.end !== undefined) {
            end = change.end;
        }
        if (start === this._start && end === this._end) {
            return this;
        }
        return (
             new NotebookRange$2(start, end)
        );
    }
}
class NotebookCellData$2 {
    constructor(kind, value, languageId, mime, outputs, metadata, executionSummary) {
        this.kind = kind;
        this.value = value;
        this.languageId = languageId;
        this.mime = mime;
        this.outputs = outputs ?? [];
        this.metadata = metadata;
        this.executionSummary = executionSummary;
        NotebookCellData$2.validate(this);
    }
    static validate(data) {
        if (typeof data.kind !== 'number') {
            throw new Error('NotebookCellData MUST have \'kind\' property');
        }
        if (typeof data.value !== 'string') {
            throw new Error('NotebookCellData MUST have \'value\' property');
        }
        if (typeof data.languageId !== 'string') {
            throw new Error('NotebookCellData MUST have \'languageId\' property');
        }
    }
    static isNotebookCellDataArray(value) {
        return Array.isArray(value) && value.every(elem => NotebookCellData$2.isNotebookCellData(elem));
    }
    static isNotebookCellData(value) {
        return true;
    }
}
class NotebookData$1 {
    constructor(cells) {
        this.cells = cells;
    }
}
class NotebookCellOutputItem$2 {
    constructor(data, mime) {
        this.data = data;
        this.mime = mime;
        const mimeNormalized = normalizeMimeType(mime, true);
        if (!mimeNormalized) {
            throw new Error(`INVALID mime type: ${mime}. Must be in the format "type/subtype[;optionalparameter]"`);
        }
        this.mime = mimeNormalized;
    }
    static isNotebookCellOutputItem(obj) {
        if (obj instanceof NotebookCellOutputItem$2) {
            return true;
        }
        if (!obj) {
            return false;
        }
        return typeof obj.mime === 'string'
            && obj.data instanceof Uint8Array;
    }
    static error(err) {
        const obj = {
            name: err.name,
            message: err.message,
            stack: err.stack
        };
        return NotebookCellOutputItem$2.json(obj, 'application/vnd.code.notebook.error');
    }
    static stdout(value) {
        return NotebookCellOutputItem$2.text(value, 'application/vnd.code.notebook.stdout');
    }
    static stderr(value) {
        return NotebookCellOutputItem$2.text(value, 'application/vnd.code.notebook.stderr');
    }
    static bytes(value, mime = 'application/octet-stream') {
        return (
             new NotebookCellOutputItem$2(value, mime)
        );
    }
    static text(value, mime = Mimes.text) {
        const bytes = __classPrivateFieldGet(NotebookCellOutputItem$2, _a$1, "f", _NotebookCellOutputItem_encoder).encode(String(value));
        return (
             new NotebookCellOutputItem$2(bytes, mime)
        );
    }
    static json(value, mime = 'text/x-json') {
        const rawStr = JSON.stringify(value, undefined, '\t');
        return NotebookCellOutputItem$2.text(rawStr, mime);
    }
}
_a$1 = NotebookCellOutputItem$2;
_NotebookCellOutputItem_encoder = { value:  new TextEncoder() };
class NotebookCellOutput$2 {
    constructor(items, idOrMetadata, metadata) {
        this.items = NotebookCellOutput$2.ensureUniqueMimeTypes(items, true);
        if (typeof idOrMetadata === 'string') {
            this.id = idOrMetadata;
            this.metadata = metadata;
        }
        else {
            this.id = generateUuid();
            this.metadata = idOrMetadata ?? metadata;
        }
    }
    static isNotebookCellOutput(candidate) {
        if (candidate instanceof NotebookCellOutput$2) {
            return true;
        }
        if (!candidate || typeof candidate !== 'object') {
            return false;
        }
        return typeof candidate.id === 'string' && isArray(candidate.items);
    }
    static ensureUniqueMimeTypes(items, warn = false) {
        const seen =  new Set();
        const removeIdx =  new Set();
        for (let i = 0; i < items.length; i++) {
            const item = items[i];
            const normalMime = normalizeMimeType(item.mime);
            if (!seen.has(normalMime)) {
                seen.add(normalMime);
                continue;
            }
            removeIdx.add(i);
            if (warn) {
                console.warn(`DUPLICATED mime type '${item.mime}' will be dropped`);
            }
        }
        if (removeIdx.size === 0) {
            return items;
        }
        return items.filter((_item, index) => !removeIdx.has(index));
    }
}
var NotebookCellKind$2;
 (function(NotebookCellKind) {
    NotebookCellKind[NotebookCellKind["Markup"] = 1] = "Markup";
    NotebookCellKind[NotebookCellKind["Code"] = 2] = "Code";
})(NotebookCellKind$2 || (NotebookCellKind$2 = {}));
var NotebookCellStatusBarAlignment$1;
 (function(NotebookCellStatusBarAlignment) {
    NotebookCellStatusBarAlignment[NotebookCellStatusBarAlignment["Left"] = 1] = "Left";
    NotebookCellStatusBarAlignment[NotebookCellStatusBarAlignment["Right"] = 2] = "Right";
})(NotebookCellStatusBarAlignment$1 || (NotebookCellStatusBarAlignment$1 = {}));
var NotebookEditorRevealType$1;
 (function(NotebookEditorRevealType) {
    NotebookEditorRevealType[NotebookEditorRevealType["Default"] = 0] = "Default";
    NotebookEditorRevealType[NotebookEditorRevealType["InCenter"] = 1] = "InCenter";
    NotebookEditorRevealType[NotebookEditorRevealType["InCenterIfOutsideViewport"] = 2] = "InCenterIfOutsideViewport";
    NotebookEditorRevealType[NotebookEditorRevealType["AtTop"] = 3] = "AtTop";
})(NotebookEditorRevealType$1 || (NotebookEditorRevealType$1 = {}));
class NotebookCellStatusBarItem$1 {
    constructor(text, alignment) {
        this.text = text;
        this.alignment = alignment;
    }
}
var NotebookControllerAffinity$1;
 (function(NotebookControllerAffinity) {
    NotebookControllerAffinity[NotebookControllerAffinity["Default"] = 1] = "Default";
    NotebookControllerAffinity[NotebookControllerAffinity["Preferred"] = 2] = "Preferred";
})(NotebookControllerAffinity$1 || (NotebookControllerAffinity$1 = {}));
var ExtensionMode$1;
 (function(ExtensionMode) {
    ExtensionMode[ExtensionMode["Production"] = 1] = "Production";
    ExtensionMode[ExtensionMode["Development"] = 2] = "Development";
    ExtensionMode[ExtensionMode["Test"] = 3] = "Test";
})(ExtensionMode$1 || (ExtensionMode$1 = {}));
class LinkedEditingRanges$1 {
    constructor(ranges, wordPattern) {
        this.ranges = ranges;
        this.wordPattern = wordPattern;
    }
}
var TestRunProfileKind$1;
 (function(TestRunProfileKind) {
    TestRunProfileKind[TestRunProfileKind["Run"] = 1] = "Run";
    TestRunProfileKind[TestRunProfileKind["Debug"] = 2] = "Debug";
    TestRunProfileKind[TestRunProfileKind["Coverage"] = 3] = "Coverage";
})(TestRunProfileKind$1 || (TestRunProfileKind$1 = {}));
let TestRunRequest$1 = class TestRunRequest {
    constructor(include = undefined, exclude = undefined, profile = undefined) {
        this.include = include;
        this.exclude = exclude;
        this.profile = profile;
    }
};
TestRunRequest$1 = TestRunRequest$1;
let TestMessage$1 = TestMessage_1 = class TestMessage {
    constructor(message) {
        this.message = message;
    }
    static diff(message, expected, actual) {
        const msg =  new TestMessage_1(message);
        msg.expectedOutput = expected;
        msg.actualOutput = actual;
        return msg;
    }
};
TestMessage$1 = TestMessage_1 = TestMessage$1;
let TestTag$1 = class TestTag {
    constructor(id) {
        this.id = id;
    }
};
TestTag$1 = TestTag$1;
class TypeHierarchyItem$2 {
    constructor(kind, name, detail, uri, range, selectionRange) {
        this.kind = kind;
        this.name = name;
        this.detail = detail;
        this.uri = uri;
        this.range = range;
        this.selectionRange = selectionRange;
    }
}
class TextTabInput {
    constructor(uri) {
        this.uri = uri;
    }
}
class TextDiffTabInput {
    constructor(original, modified) {
        this.original = original;
        this.modified = modified;
    }
}
class CustomEditorTabInput {
    constructor(uri, viewType) {
        this.uri = uri;
        this.viewType = viewType;
    }
}
class WebviewEditorTabInput {
    constructor(viewType) {
        this.viewType = viewType;
    }
}
class NotebookEditorTabInput {
    constructor(uri, notebookType) {
        this.uri = uri;
        this.notebookType = notebookType;
    }
}
class NotebookDiffEditorTabInput {
    constructor(original, modified, notebookType) {
        this.original = original;
        this.modified = modified;
        this.notebookType = notebookType;
    }
}
class TerminalEditorTabInput {
    constructor() { }
}
var DebugConfigurationProviderTriggerKind$1;
 (function(DebugConfigurationProviderTriggerKind) {
    DebugConfigurationProviderTriggerKind[DebugConfigurationProviderTriggerKind["Initial"] = 1] = "Initial";
    DebugConfigurationProviderTriggerKind[DebugConfigurationProviderTriggerKind["Dynamic"] = 2] = "Dynamic";
})(
    DebugConfigurationProviderTriggerKind$1 || (DebugConfigurationProviderTriggerKind$1 = {})
);
const hasBuffer$1 = (typeof Buffer !== 'undefined');
let textEncoder;
let textDecoder;
class VSBuffer {
    constructor(buffer) {
        this.buffer = buffer;
        this.byteLength = this.buffer.byteLength;
    }
    static alloc(byteLength) {
        if (hasBuffer$1) {
            return (
                 new VSBuffer(Buffer.allocUnsafe(byteLength))
            );
        }
        else {
            return (
                 new VSBuffer( new Uint8Array(byteLength))
            );
        }
    }
    static wrap(actual) {
        if (hasBuffer$1 && !(Buffer.isBuffer(actual))) {
            actual = Buffer.from(actual.buffer, actual.byteOffset, actual.byteLength);
        }
        return (
             new VSBuffer(actual)
        );
    }
    static fromString(source, options) {
        const dontUseNodeBuffer = options?.dontUseNodeBuffer || false;
        if (!dontUseNodeBuffer && hasBuffer$1) {
            return (
                 new VSBuffer(Buffer.from(source))
            );
        }
        else {
            if (!textEncoder) {
                textEncoder =  new TextEncoder();
            }
            return (
                 new VSBuffer(textEncoder.encode(source))
            );
        }
    }
    static fromByteArray(source) {
        const result = VSBuffer.alloc(source.length);
        for (let i = 0, len = source.length; i < len; i++) {
            result.buffer[i] = source[i];
        }
        return result;
    }
    static concat(buffers, totalLength) {
        if (typeof totalLength === 'undefined') {
            totalLength = 0;
            for (let i = 0, len = buffers.length; i < len; i++) {
                totalLength += buffers[i].byteLength;
            }
        }
        const ret = VSBuffer.alloc(totalLength);
        let offset = 0;
        for (let i = 0, len = buffers.length; i < len; i++) {
            const element = buffers[i];
            ret.set(element, offset);
            offset += element.byteLength;
        }
        return ret;
    }
    clone() {
        const result = VSBuffer.alloc(this.byteLength);
        result.set(this);
        return result;
    }
    toString() {
        if (hasBuffer$1) {
            return this.buffer.toString();
        }
        else {
            if (!textDecoder) {
                textDecoder =  new TextDecoder();
            }
            return textDecoder.decode(this.buffer);
        }
    }
    slice(start, end) {
        return (
             new VSBuffer(this.buffer.subarray(start, end))
        );
    }
    set(array, offset) {
        if (array instanceof VSBuffer) {
            this.buffer.set(array.buffer, offset);
        }
        else if (array instanceof Uint8Array) {
            this.buffer.set(array, offset);
        }
        else if (array instanceof ArrayBuffer) {
            this.buffer.set( new Uint8Array(array), offset);
        }
        else if (ArrayBuffer.isView(array)) {
            this.buffer.set( new Uint8Array(array.buffer, array.byteOffset, array.byteLength), offset);
        }
        else {
            throw new Error(`Unknown argument 'array'`);
        }
    }
    readUInt32BE(offset) {
        return readUInt32BE(this.buffer, offset);
    }
    writeUInt32BE(value, offset) {
        writeUInt32BE(this.buffer, value, offset);
    }
    readUInt32LE(offset) {
        return readUInt32LE(this.buffer, offset);
    }
    writeUInt32LE(value, offset) {
        writeUInt32LE(this.buffer, value, offset);
    }
    readUInt8(offset) {
        return readUInt8(this.buffer, offset);
    }
    writeUInt8(value, offset) {
        writeUInt8(this.buffer, value, offset);
    }
}
function readUInt32BE(source, offset) {
    return (source[offset] * 2 ** 24
        + source[offset + 1] * 2 ** 16
        + source[offset + 2] * 2 ** 8
        + source[offset + 3]);
}
function writeUInt32BE(destination, value, offset) {
    destination[offset + 3] = value;
    value = value >>> 8;
    destination[offset + 2] = value;
    value = value >>> 8;
    destination[offset + 1] = value;
    value = value >>> 8;
    destination[offset] = value;
}
function readUInt32LE(source, offset) {
    return (((source[offset + 0] << 0) >>> 0) |
        ((source[offset + 1] << 8) >>> 0) |
        ((source[offset + 2] << 16) >>> 0) |
        ((source[offset + 3] << 24) >>> 0));
}
function writeUInt32LE(destination, value, offset) {
    destination[offset + 0] = (value & 0b11111111);
    value = value >>> 8;
    destination[offset + 1] = (value & 0b11111111);
    value = value >>> 8;
    destination[offset + 2] = (value & 0b11111111);
    value = value >>> 8;
    destination[offset + 3] = (value & 0b11111111);
}
function readUInt8(source, offset) {
    return source[offset];
}
function writeUInt8(destination, value, offset) {
    destination[offset] = value;
}
var UIKind$1;
 (function(UIKind) {
    UIKind[UIKind["Desktop"] = 1] = "Desktop";
    UIKind[UIKind["Web"] = 2] = "Web";
})(UIKind$1 || (UIKind$1 = {}));
const Emitter = monaco.Emitter;
const marked = marked$1.marked;
const Range$2 = monaco.Range;
const FoldingRangeKind$2 = monaco.languages.FoldingRangeKind;
var CellKind;
 (function(CellKind) {
    CellKind[CellKind["Markup"] = 1] = "Markup";
    CellKind[CellKind["Code"] = 2] = "Code";
})(CellKind || (CellKind = {}));
var Selection$2;
 (function(Selection) {
    function to(selection) {
        const { selectionStartLineNumber, selectionStartColumn, positionLineNumber, positionColumn } = selection;
        const start = new Position$3(selectionStartLineNumber - 1, selectionStartColumn - 1);
        const end = new Position$3(positionLineNumber - 1, positionColumn - 1);
        return new Selection$3(start, end);
    }
    Selection.to = to;
    function from(selection) {
        const { anchor, active } = selection;
        return {
            selectionStartLineNumber: anchor.line + 1,
            selectionStartColumn: anchor.character + 1,
            positionLineNumber: active.line + 1,
            positionColumn: active.character + 1
        };
    }
    Selection.from = from;
})(Selection$2 || (Selection$2 = {}));
var Range$1;
 (function(Range) {
    function from(range) {
        if (!range) {
            return undefined;
        }
        const { start, end } = range;
        return {
            startLineNumber: start.line + 1,
            startColumn: start.character + 1,
            endLineNumber: end.line + 1,
            endColumn: end.character + 1
        };
    }
    Range.from = from;
    function to(range) {
        if (!range) {
            return undefined;
        }
        const { startLineNumber, startColumn, endLineNumber, endColumn } = range;
        return new Range$3(startLineNumber - 1, startColumn - 1, endLineNumber - 1, endColumn - 1);
    }
    Range.to = to;
})(Range$1 || (Range$1 = {}));
var Position$2;
 (function(Position) {
    function to(position) {
        return new Position$3(position.lineNumber - 1, position.column - 1);
    }
    Position.to = to;
    function from(position) {
        return { lineNumber: position.line + 1, column: position.character + 1 };
    }
    Position.from = from;
})(Position$2 || (Position$2 = {}));
var DocumentSelector;
 (function(DocumentSelector) {
    function from(value, uriTransformer) {
        return coalesce(asArray(value).map(sel => _doTransformDocumentSelector(sel, uriTransformer)));
    }
    DocumentSelector.from = from;
    function _doTransformDocumentSelector(selector, uriTransformer) {
        if (typeof selector === 'string') {
            return {
                $serialized: true,
                language: selector
            };
        }
        if (selector) {
            return {
                $serialized: true,
                language: selector.language,
                scheme: _transformScheme(selector.scheme, uriTransformer),
                pattern: GlobPattern.from(selector.pattern) ?? undefined,
                exclusive: selector.exclusive,
                notebookType: selector.notebookType
            };
        }
        return undefined;
    }
    function _transformScheme(scheme, uriTransformer) {
        if (uriTransformer && typeof scheme === 'string') {
            return uriTransformer.transformOutgoingScheme(scheme);
        }
        return scheme;
    }
})(DocumentSelector || (DocumentSelector = {}));
var DiagnosticTag$1;
 (function(DiagnosticTag) {
    function from(value) {
        switch (value) {
            case DiagnosticTag$2.Unnecessary:
                return 1 ;
            case DiagnosticTag$2.Deprecated:
                return 2 ;
        }
        return undefined;
    }
    DiagnosticTag.from = from;
    function to(value) {
        switch (value) {
            case 1 :
                return DiagnosticTag$2.Unnecessary;
            case 2 :
                return DiagnosticTag$2.Deprecated;
            default:
                return undefined;
        }
    }
    DiagnosticTag.to = to;
})(DiagnosticTag$1 || (DiagnosticTag$1 = {}));
var Diagnostic$1;
 (function(Diagnostic) {
    function from(value) {
        let code;
        if (value.code) {
            if (isString$1(value.code) || isNumber(value.code)) {
                code = String(value.code);
            }
            else {
                code = {
                    value: String(value.code.value),
                    target: value.code.target,
                };
            }
        }
        return {
            ...Range$1.from(value.range),
            message: value.message,
            source: value.source,
            code,
            severity: DiagnosticSeverity$1.from(value.severity),
            relatedInformation: value.relatedInformation && value.relatedInformation.map(DiagnosticRelatedInformation$1.from),
            tags: Array.isArray(value.tags) ? coalesce(value.tags.map(DiagnosticTag$1.from)) : undefined,
        };
    }
    Diagnostic.from = from;
    function to(value) {
        const res = new Diagnostic$2(Range$1.to(value), value.message, DiagnosticSeverity$1.to(value.severity));
        res.source = value.source;
        res.code = isString$1(value.code) ? value.code : value.code?.value;
        res.relatedInformation = value.relatedInformation && value.relatedInformation.map(DiagnosticRelatedInformation$1.to);
        res.tags = value.tags && coalesce(value.tags.map(DiagnosticTag$1.to));
        return res;
    }
    Diagnostic.to = to;
})(Diagnostic$1 || (Diagnostic$1 = {}));
var DiagnosticRelatedInformation$1;
 (function(DiagnosticRelatedInformation) {
    function from(value) {
        return {
            ...Range$1.from(value.location.range),
            message: value.message,
            resource: value.location.uri
        };
    }
    DiagnosticRelatedInformation.from = from;
    function to(value) {
        return new DiagnosticRelatedInformation$2(new Location$1(value.resource, Range$1.to(value)), value.message);
    }
    DiagnosticRelatedInformation.to = to;
})(DiagnosticRelatedInformation$1 || (DiagnosticRelatedInformation$1 = {}));
var DiagnosticSeverity$1;
 (function(DiagnosticSeverity) {
    function from(value) {
        switch (value) {
            case DiagnosticSeverity$2.Error:
                return MarkerSeverity.Error;
            case DiagnosticSeverity$2.Warning:
                return MarkerSeverity.Warning;
            case DiagnosticSeverity$2.Information:
                return MarkerSeverity.Info;
            case DiagnosticSeverity$2.Hint:
                return MarkerSeverity.Hint;
        }
        return MarkerSeverity.Error;
    }
    DiagnosticSeverity.from = from;
    function to(value) {
        switch (value) {
            case MarkerSeverity.Info:
                return DiagnosticSeverity$2.Information;
            case MarkerSeverity.Warning:
                return DiagnosticSeverity$2.Warning;
            case MarkerSeverity.Error:
                return DiagnosticSeverity$2.Error;
            case MarkerSeverity.Hint:
                return DiagnosticSeverity$2.Hint;
            default:
                return DiagnosticSeverity$2.Error;
        }
    }
    DiagnosticSeverity.to = to;
})(DiagnosticSeverity$1 || (DiagnosticSeverity$1 = {}));
var MarkdownString$1;
 (function(MarkdownString) {
    function fromMany(markup) {
        return markup.map(MarkdownString.from);
    }
    MarkdownString.fromMany = fromMany;
    function isCodeblock(thing) {
        return thing && typeof thing === 'object'
            && typeof thing.language === 'string'
            && typeof thing.value === 'string';
    }
    function from(markup) {
        let res;
        if (isCodeblock(markup)) {
            const { language, value } = markup;
            res = { value: '```' + language + '\n' + value + '\n```\n' };
        }
        else if (MarkdownString$2.isMarkdownString(markup)) {
            res = { value: markup.value, isTrusted: markup.isTrusted, supportThemeIcons: markup.supportThemeIcons, supportHtml: markup.supportHtml, baseUri: markup.baseUri };
        }
        else if (typeof markup === 'string') {
            res = { value: markup };
        }
        else {
            res = { value: '' };
        }
        const resUris = Object.create(null);
        res.uris = resUris;
        const collectUri = (href) => {
            try {
                let uri = URI.parse(href, true);
                uri = uri.with({ query: _uriMassage(uri.query, resUris) });
                resUris[href] = uri;
            }
            catch (e) {
            }
            return '';
        };
        const renderer = new marked.Renderer();
        renderer.link = collectUri;
        renderer.image = href => typeof href === 'string' ? collectUri(parseHrefAndDimensions(href).href) : '';
        marked(res.value, { renderer });
        return res;
    }
    MarkdownString.from = from;
    function _uriMassage(part, bucket) {
        if (!part) {
            return part;
        }
        let data;
        try {
            data = parse(part);
        }
        catch (e) {
        }
        if (!data) {
            return part;
        }
        let changed = false;
        data = cloneAndChange(data, value => {
            if (URI.isUri(value)) {
                const key = `__uri_${Math.random().toString(16).slice(2, 8)}`;
                bucket[key] = value;
                changed = true;
                return key;
            }
            else {
                return undefined;
            }
        });
        if (!changed) {
            return part;
        }
        return JSON.stringify(data);
    }
    function to(value) {
        const result = new MarkdownString$2(value.value, value.supportThemeIcons);
        result.isTrusted = value.isTrusted;
        result.supportHtml = value.supportHtml;
        result.baseUri = value.baseUri ? URI.from(value.baseUri) : undefined;
        return result;
    }
    MarkdownString.to = to;
    function fromStrict(value) {
        if (!value) {
            return undefined;
        }
        return typeof value === 'string' ? value : MarkdownString.from(value);
    }
    MarkdownString.fromStrict = fromStrict;
})(MarkdownString$1 || (MarkdownString$1 = {}));
var TextEdit$1;
 (function(TextEdit) {
    function from(edit) {
        return {
            text: edit.newText,
            eol: edit.newEol && EndOfLine$1.from(edit.newEol),
            range: Range$1.from(edit.range)
        };
    }
    TextEdit.from = from;
    function to(edit) {
        const result = new TextEdit$2(Range$1.to(edit.range), edit.text);
        result.newEol = (typeof edit.eol === 'undefined' ? undefined : EndOfLine$1.to(edit.eol));
        return result;
    }
    TextEdit.to = to;
})(TextEdit$1 || (TextEdit$1 = {}));
var WorkspaceEdit$1;
 (function(WorkspaceEdit) {
    function from(value, versionInfo) {
        const result = {
            edits: []
        };
        if (value instanceof WorkspaceEdit$2) {
            const toCreate =  new ResourceSet();
            for (const entry of value._allEntries()) {
                if (entry._type === 1  && URI.isUri(entry.to) && entry.from === undefined) {
                    toCreate.add(entry.to);
                }
            }
            for (const entry of value._allEntries()) {
                if (entry._type === 1 ) {
                    result.edits.push({
                        _type: 1 ,
                        oldUri: entry.from,
                        newUri: entry.to,
                        options: entry.options,
                        metadata: entry.metadata
                    });
                }
                else if (entry._type === 2 ) {
                    result.edits.push({
                        _type: 2 ,
                        resource: entry.uri,
                        edit: TextEdit$1.from(entry.edit),
                        modelVersionId: !toCreate.has(entry.uri) ? versionInfo?.getTextDocumentVersion(entry.uri) : undefined,
                        metadata: entry.metadata
                    });
                }
                else if (entry._type === 3 ) {
                    result.edits.push({
                        _type: 3 ,
                        metadata: entry.metadata,
                        resource: entry.uri,
                        edit: entry.edit,
                        notebookMetadata: entry.notebookMetadata,
                        notebookVersionId: versionInfo?.getNotebookDocumentVersion(entry.uri)
                    });
                }
                else if (entry._type === 5 ) {
                    result.edits.push({
                        _type: 3 ,
                        metadata: entry.metadata,
                        resource: entry.uri,
                        notebookVersionId: versionInfo?.getNotebookDocumentVersion(entry.uri),
                        edit: {
                            editType: 1 ,
                            index: entry.index,
                            count: entry.count,
                            cells: entry.cells.map(NotebookCellData$1.from)
                        }
                    });
                }
            }
        }
        return result;
    }
    WorkspaceEdit.from = from;
    function to(value) {
        const result = new WorkspaceEdit$2();
        for (const edit of value.edits) {
            if (edit.edit) {
                result.replace(URI.revive(edit.resource), Range$1.to(edit.edit.range), edit.edit.text);
            }
            else {
                result.renameFile(URI.revive(edit.oldUri), URI.revive(edit.newUri), edit.options);
            }
        }
        return result;
    }
    WorkspaceEdit.to = to;
})(WorkspaceEdit$1 || (WorkspaceEdit$1 = {}));
var SymbolKind$1;
 (function(SymbolKind) {
    const _fromMapping = Object.create(null);
    _fromMapping[SymbolKind$2.File] = 0 ;
    _fromMapping[SymbolKind$2.Module] = 1 ;
    _fromMapping[SymbolKind$2.Namespace] = 2 ;
    _fromMapping[SymbolKind$2.Package] = 3 ;
    _fromMapping[SymbolKind$2.Class] = 4 ;
    _fromMapping[SymbolKind$2.Method] = 5 ;
    _fromMapping[SymbolKind$2.Property] = 6 ;
    _fromMapping[SymbolKind$2.Field] = 7 ;
    _fromMapping[SymbolKind$2.Constructor] = 8 ;
    _fromMapping[SymbolKind$2.Enum] = 9 ;
    _fromMapping[SymbolKind$2.Interface] = 10 ;
    _fromMapping[SymbolKind$2.Function] = 11 ;
    _fromMapping[SymbolKind$2.Variable] = 12 ;
    _fromMapping[SymbolKind$2.Constant] = 13 ;
    _fromMapping[SymbolKind$2.String] = 14 ;
    _fromMapping[SymbolKind$2.Number] = 15 ;
    _fromMapping[SymbolKind$2.Boolean] = 16 ;
    _fromMapping[SymbolKind$2.Array] = 17 ;
    _fromMapping[SymbolKind$2.Object] = 18 ;
    _fromMapping[SymbolKind$2.Key] = 19 ;
    _fromMapping[SymbolKind$2.Null] = 20 ;
    _fromMapping[SymbolKind$2.EnumMember] = 21 ;
    _fromMapping[SymbolKind$2.Struct] = 22 ;
    _fromMapping[SymbolKind$2.Event] = 23 ;
    _fromMapping[SymbolKind$2.Operator] = 24 ;
    _fromMapping[SymbolKind$2.TypeParameter] = 25 ;
    function from(kind) {
        return typeof _fromMapping[kind] === 'number' ? _fromMapping[kind] : 6 ;
    }
    SymbolKind.from = from;
    function to(kind) {
        for (const k in _fromMapping) {
            if (_fromMapping[k] === kind) {
                return Number(k);
            }
        }
        return SymbolKind$2.Property;
    }
    SymbolKind.to = to;
})(SymbolKind$1 || (SymbolKind$1 = {}));
var SymbolTag$1;
 (function(SymbolTag) {
    function from(kind) {
        switch (kind) {
            case SymbolTag$2.Deprecated: return 1 ;
        }
    }
    SymbolTag.from = from;
    function to(kind) {
        switch (kind) {
            case 1 : return SymbolTag$2.Deprecated;
        }
    }
    SymbolTag.to = to;
})(SymbolTag$1 || (SymbolTag$1 = {}));
var WorkspaceSymbol;
 (function(WorkspaceSymbol) {
    function from(info) {
        return {
            name: info.name,
            kind: SymbolKind$1.from(info.kind),
            tags: info.tags && info.tags.map(SymbolTag$1.from),
            containerName: info.containerName,
            location: location.from(info.location)
        };
    }
    WorkspaceSymbol.from = from;
    function to(info) {
        const result = new SymbolInformation$1(info.name, SymbolKind$1.to(info.kind), info.containerName, location.to(info.location));
        result.tags = info.tags && info.tags.map(SymbolTag$1.to);
        return result;
    }
    WorkspaceSymbol.to = to;
})(WorkspaceSymbol || (WorkspaceSymbol = {}));
var DocumentSymbol$1;
 (function(DocumentSymbol) {
    function from(info) {
        const result = {
            name: info.name || '!!MISSING: name!!',
            detail: info.detail,
            range: Range$1.from(info.range),
            selectionRange: Range$1.from(info.selectionRange),
            kind: SymbolKind$1.from(info.kind),
            tags: info.tags?.map(SymbolTag$1.from) ?? []
        };
        if (info.children) {
            result.children = info.children.map(from);
        }
        return result;
    }
    DocumentSymbol.from = from;
    function to(info) {
        const result = new DocumentSymbol$2(info.name, info.detail, SymbolKind$1.to(info.kind), Range$1.to(info.range), Range$1.to(info.selectionRange));
        if (isNonEmptyArray(info.tags)) {
            result.tags = info.tags.map(SymbolTag$1.to);
        }
        if (info.children) {
            result.children = info.children.map(to);
        }
        return result;
    }
    DocumentSymbol.to = to;
})(DocumentSymbol$1 || (DocumentSymbol$1 = {}));
var CallHierarchyItem$1;
 (function(CallHierarchyItem) {
    function to(item) {
        const result = new CallHierarchyItem$2(SymbolKind$1.to(item.kind), item.name, item.detail || '', URI.revive(item.uri), Range$1.to(item.range), Range$1.to(item.selectionRange));
        result._sessionId = item._sessionId;
        result._itemId = item._itemId;
        return result;
    }
    CallHierarchyItem.to = to;
    function from(item, sessionId, itemId) {
        sessionId = sessionId ?? item._sessionId;
        itemId = itemId ?? item._itemId;
        if (sessionId === undefined || itemId === undefined) {
            throw new Error('invalid item');
        }
        return {
            _sessionId: sessionId,
            _itemId: itemId,
            name: item.name,
            detail: item.detail,
            kind: SymbolKind$1.from(item.kind),
            uri: item.uri,
            range: Range$1.from(item.range),
            selectionRange: Range$1.from(item.selectionRange),
            tags: item.tags?.map(SymbolTag$1.from)
        };
    }
    CallHierarchyItem.from = from;
})(CallHierarchyItem$1 || (CallHierarchyItem$1 = {}));
var location;
 (function(location) {
    function from(value) {
        return {
            range: value.range && Range$1.from(value.range),
            uri: value.uri
        };
    }
    location.from = from;
    function to(value) {
        return new Location$1(URI.revive(value.uri), Range$1.to(value.range));
    }
    location.to = to;
})(location || (location = {}));
var DefinitionLink;
 (function(DefinitionLink) {
    function from(value) {
        const definitionLink = value;
        const location = value;
        return {
            originSelectionRange: definitionLink.originSelectionRange
                ? Range$1.from(definitionLink.originSelectionRange)
                : undefined,
            uri: definitionLink.targetUri ? definitionLink.targetUri : location.uri,
            range: Range$1.from(definitionLink.targetRange ? definitionLink.targetRange : location.range),
            targetSelectionRange: definitionLink.targetSelectionRange
                ? Range$1.from(definitionLink.targetSelectionRange)
                : undefined,
        };
    }
    DefinitionLink.from = from;
    function to(value) {
        return {
            targetUri: URI.revive(value.uri),
            targetRange: Range$1.to(value.range),
            targetSelectionRange: value.targetSelectionRange
                ? Range$1.to(value.targetSelectionRange)
                : undefined,
            originSelectionRange: value.originSelectionRange
                ? Range$1.to(value.originSelectionRange)
                : undefined
        };
    }
    DefinitionLink.to = to;
})(DefinitionLink || (DefinitionLink = {}));
var Hover$1;
 (function(Hover) {
    function from(hover) {
        return {
            range: Range$1.from(hover.range),
            contents: MarkdownString$1.fromMany(hover.contents)
        };
    }
    Hover.from = from;
    function to(info) {
        return new Hover$2(info.contents.map(MarkdownString$1.to), Range$1.to(info.range));
    }
    Hover.to = to;
})(Hover$1 || (Hover$1 = {}));
var EvaluatableExpression$1;
 (function(EvaluatableExpression) {
    function from(expression) {
        return {
            range: Range$1.from(expression.range),
            expression: expression.expression
        };
    }
    EvaluatableExpression.from = from;
    function to(info) {
        return new EvaluatableExpression$2(Range$1.to(info.range), info.expression);
    }
    EvaluatableExpression.to = to;
})(EvaluatableExpression$1 || (EvaluatableExpression$1 = {}));
var DocumentHighlight$1;
 (function(DocumentHighlight) {
    function from(documentHighlight) {
        return {
            range: Range$1.from(documentHighlight.range),
            kind: documentHighlight.kind
        };
    }
    DocumentHighlight.from = from;
    function to(occurrence) {
        return new DocumentHighlight$2(Range$1.to(occurrence.range), occurrence.kind);
    }
    DocumentHighlight.to = to;
})(DocumentHighlight$1 || (DocumentHighlight$1 = {}));
var CompletionTriggerKind$1;
 (function(CompletionTriggerKind) {
    function to(kind) {
        switch (kind) {
            case 1 :
                return CompletionTriggerKind$2.TriggerCharacter;
            case 2 :
                return CompletionTriggerKind$2.TriggerForIncompleteCompletions;
            case 0 :
            default:
                return CompletionTriggerKind$2.Invoke;
        }
    }
    CompletionTriggerKind.to = to;
})(CompletionTriggerKind$1 || (CompletionTriggerKind$1 = {}));
var CompletionContext;
 (function(CompletionContext) {
    function to(context) {
        return {
            triggerKind: CompletionTriggerKind$1.to(context.triggerKind),
            triggerCharacter: context.triggerCharacter
        };
    }
    CompletionContext.to = to;
})(CompletionContext || (CompletionContext = {}));
var CompletionItemTag$1;
 (function(CompletionItemTag) {
    function from(kind) {
        switch (kind) {
            case CompletionItemTag$2.Deprecated: return 1 ;
        }
    }
    CompletionItemTag.from = from;
    function to(kind) {
        switch (kind) {
            case 1 : return CompletionItemTag$2.Deprecated;
        }
    }
    CompletionItemTag.to = to;
})(CompletionItemTag$1 || (CompletionItemTag$1 = {}));
var CompletionItemKind$1;
 (function(CompletionItemKind) {
    const _from =  new Map([
        [CompletionItemKind$2.Method, 0 ],
        [CompletionItemKind$2.Function, 1 ],
        [CompletionItemKind$2.Constructor, 2 ],
        [CompletionItemKind$2.Field, 3 ],
        [CompletionItemKind$2.Variable, 4 ],
        [CompletionItemKind$2.Class, 5 ],
        [CompletionItemKind$2.Interface, 7 ],
        [CompletionItemKind$2.Struct, 6 ],
        [CompletionItemKind$2.Module, 8 ],
        [CompletionItemKind$2.Property, 9 ],
        [CompletionItemKind$2.Unit, 12 ],
        [CompletionItemKind$2.Value, 13 ],
        [CompletionItemKind$2.Constant, 14 ],
        [CompletionItemKind$2.Enum, 15 ],
        [CompletionItemKind$2.EnumMember, 16 ],
        [CompletionItemKind$2.Keyword, 17 ],
        [CompletionItemKind$2.Snippet, 27 ],
        [CompletionItemKind$2.Text, 18 ],
        [CompletionItemKind$2.Color, 19 ],
        [CompletionItemKind$2.File, 20 ],
        [CompletionItemKind$2.Reference, 21 ],
        [CompletionItemKind$2.Folder, 23 ],
        [CompletionItemKind$2.Event, 10 ],
        [CompletionItemKind$2.Operator, 11 ],
        [CompletionItemKind$2.TypeParameter, 24 ],
        [CompletionItemKind$2.Issue, 26 ],
        [CompletionItemKind$2.User, 25 ],
    ]);
    function from(kind) {
        return _from.get(kind) ?? 9 ;
    }
    CompletionItemKind.from = from;
    const _to =  new Map([
        [0 , CompletionItemKind$2.Method],
        [1 , CompletionItemKind$2.Function],
        [2 , CompletionItemKind$2.Constructor],
        [3 , CompletionItemKind$2.Field],
        [4 , CompletionItemKind$2.Variable],
        [5 , CompletionItemKind$2.Class],
        [7 , CompletionItemKind$2.Interface],
        [6 , CompletionItemKind$2.Struct],
        [8 , CompletionItemKind$2.Module],
        [9 , CompletionItemKind$2.Property],
        [12 , CompletionItemKind$2.Unit],
        [13 , CompletionItemKind$2.Value],
        [14 , CompletionItemKind$2.Constant],
        [15 , CompletionItemKind$2.Enum],
        [16 , CompletionItemKind$2.EnumMember],
        [17 , CompletionItemKind$2.Keyword],
        [27 , CompletionItemKind$2.Snippet],
        [18 , CompletionItemKind$2.Text],
        [19 , CompletionItemKind$2.Color],
        [20 , CompletionItemKind$2.File],
        [21 , CompletionItemKind$2.Reference],
        [23 , CompletionItemKind$2.Folder],
        [10 , CompletionItemKind$2.Event],
        [11 , CompletionItemKind$2.Operator],
        [24 , CompletionItemKind$2.TypeParameter],
        [25 , CompletionItemKind$2.User],
        [26 , CompletionItemKind$2.Issue],
    ]);
    function to(kind) {
        return _to.get(kind) ?? CompletionItemKind$2.Property;
    }
    CompletionItemKind.to = to;
})(CompletionItemKind$1 || (CompletionItemKind$1 = {}));
var ParameterInformation$1;
 (function(ParameterInformation) {
    function from(info) {
        return {
            label: info.label,
            documentation: MarkdownString$1.fromStrict(info.documentation)
        };
    }
    ParameterInformation.from = from;
    function to(info) {
        return {
            label: info.label,
            documentation: isMarkdownString(info.documentation) ? MarkdownString$1.to(info.documentation) : info.documentation
        };
    }
    ParameterInformation.to = to;
})(ParameterInformation$1 || (ParameterInformation$1 = {}));
var SignatureInformation$1;
 (function(SignatureInformation) {
    function from(info) {
        return {
            label: info.label,
            documentation: MarkdownString$1.fromStrict(info.documentation),
            parameters: Array.isArray(info.parameters) ? info.parameters.map(ParameterInformation$1.from) : [],
            activeParameter: info.activeParameter,
        };
    }
    SignatureInformation.from = from;
    function to(info) {
        return {
            label: info.label,
            documentation: isMarkdownString(info.documentation) ? MarkdownString$1.to(info.documentation) : info.documentation,
            parameters: Array.isArray(info.parameters) ? info.parameters.map(ParameterInformation$1.to) : [],
            activeParameter: info.activeParameter,
        };
    }
    SignatureInformation.to = to;
})(SignatureInformation$1 || (SignatureInformation$1 = {}));
var SignatureHelp$1;
 (function(SignatureHelp) {
    function from(help) {
        return {
            activeSignature: help.activeSignature,
            activeParameter: help.activeParameter,
            signatures: Array.isArray(help.signatures) ? help.signatures.map(SignatureInformation$1.from) : [],
        };
    }
    SignatureHelp.from = from;
    function to(help) {
        return {
            activeSignature: help.activeSignature,
            activeParameter: help.activeParameter,
            signatures: Array.isArray(help.signatures) ? help.signatures.map(SignatureInformation$1.to) : [],
        };
    }
    SignatureHelp.to = to;
})(SignatureHelp$1 || (SignatureHelp$1 = {}));
var InlayHintKind$1;
 (function(InlayHintKind) {
    function from(kind) {
        return kind;
    }
    InlayHintKind.from = from;
    function to(kind) {
        return kind;
    }
    InlayHintKind.to = to;
})(InlayHintKind$1 || (InlayHintKind$1 = {}));
var DocumentLink$1;
 (function(DocumentLink) {
    function from(link) {
        return {
            range: Range$1.from(link.range),
            url: link.target,
            tooltip: link.tooltip
        };
    }
    DocumentLink.from = from;
    function to(link) {
        let target = undefined;
        if (link.url) {
            try {
                target = typeof link.url === 'string' ? URI.parse(link.url, true) : URI.revive(link.url);
            }
            catch (err) {
            }
        }
        return new DocumentLink$2(Range$1.to(link.range), target);
    }
    DocumentLink.to = to;
})(DocumentLink$1 || (DocumentLink$1 = {}));
var ColorPresentation$1;
 (function(ColorPresentation) {
    function to(colorPresentation) {
        const cp = new ColorPresentation$2(colorPresentation.label);
        if (colorPresentation.textEdit) {
            cp.textEdit = TextEdit$1.to(colorPresentation.textEdit);
        }
        if (colorPresentation.additionalTextEdits) {
            cp.additionalTextEdits = colorPresentation.additionalTextEdits.map(value => TextEdit$1.to(value));
        }
        return cp;
    }
    ColorPresentation.to = to;
    function from(colorPresentation) {
        return {
            label: colorPresentation.label,
            textEdit: colorPresentation.textEdit ? TextEdit$1.from(colorPresentation.textEdit) : undefined,
            additionalTextEdits: colorPresentation.additionalTextEdits ? colorPresentation.additionalTextEdits.map(value => TextEdit$1.from(value)) : undefined
        };
    }
    ColorPresentation.from = from;
})(ColorPresentation$1 || (ColorPresentation$1 = {}));
var Color$1;
 (function(Color) {
    function to(c) {
        return new Color$2(c[0], c[1], c[2], c[3]);
    }
    Color.to = to;
    function from(color) {
        return [color.red, color.green, color.blue, color.alpha];
    }
    Color.from = from;
})(Color$1 || (Color$1 = {}));
var SelectionRange$1;
 (function(SelectionRange) {
    function from(obj) {
        return { range: Range$1.from(obj.range) };
    }
    SelectionRange.from = from;
    function to(obj) {
        return new SelectionRange$2(Range$1.to(obj.range));
    }
    SelectionRange.to = to;
})(SelectionRange$1 || (SelectionRange$1 = {}));
var EndOfLine$1;
 (function(EndOfLine) {
    function from(eol) {
        if (eol === EndOfLine$2.CRLF) {
            return 1 ;
        }
        else if (eol === EndOfLine$2.LF) {
            return 0 ;
        }
        return undefined;
    }
    EndOfLine.from = from;
    function to(eol) {
        if (eol === 1 ) {
            return EndOfLine$2.CRLF;
        }
        else if (eol === 0 ) {
            return EndOfLine$2.LF;
        }
        return undefined;
    }
    EndOfLine.to = to;
})(EndOfLine$1 || (EndOfLine$1 = {}));
var FoldingRange$1;
 (function(FoldingRange) {
    function from(r) {
        const range = { start: r.start + 1, end: r.end + 1 };
        if (r.kind) {
            range.kind = FoldingRangeKind$1.from(r.kind);
        }
        return range;
    }
    FoldingRange.from = from;
})(FoldingRange$1 || (FoldingRange$1 = {}));
var FoldingRangeKind$1;
 (function(FoldingRangeKind) {
    function from(kind) {
        if (kind) {
            switch (kind) {
                case FoldingRangeKind$3.Comment:
                    return FoldingRangeKind$2.Comment;
                case FoldingRangeKind$3.Imports:
                    return FoldingRangeKind$2.Imports;
                case FoldingRangeKind$3.Region:
                    return FoldingRangeKind$2.Region;
            }
        }
        return undefined;
    }
    FoldingRangeKind.from = from;
})(FoldingRangeKind$1 || (FoldingRangeKind$1 = {}));
var GlobPattern;
 (function(GlobPattern) {
    function from(pattern) {
        if (pattern instanceof RelativePattern$1) {
            return pattern.toJSON();
        }
        if (typeof pattern === 'string') {
            return pattern;
        }
        if (isRelativePatternShape(pattern) || isLegacyRelativePatternShape(pattern)) {
            return new RelativePattern$1(pattern.baseUri ?? pattern.base, pattern.pattern).toJSON();
        }
        return pattern;
    }
    GlobPattern.from = from;
    function isRelativePatternShape(obj) {
        const rp = obj;
        if (!rp) {
            return false;
        }
        return URI.isUri(rp.baseUri) && typeof rp.pattern === 'string';
    }
    function isLegacyRelativePatternShape(obj) {
        const rp = obj;
        if (!rp) {
            return false;
        }
        return typeof rp.base === 'string' && typeof rp.pattern === 'string';
    }
    function to(pattern) {
        if (typeof pattern === 'string') {
            return pattern;
        }
        return new RelativePattern$1(URI.revive(pattern.baseUri), pattern.pattern);
    }
    GlobPattern.to = to;
})(GlobPattern || (GlobPattern = {}));
var LanguageSelector;
 (function(LanguageSelector) {
    function from(selector) {
        if (!selector) {
            return undefined;
        }
        else if (Array.isArray(selector)) {
            return selector.map(from);
        }
        else if (typeof selector === 'string') {
            return selector;
        }
        else {
            const filter = selector;
            return {
                language: filter.language,
                scheme: filter.scheme,
                pattern: GlobPattern.from(filter.pattern),
                exclusive: filter.exclusive,
                notebookType: filter.notebookType
            };
        }
    }
    LanguageSelector.from = from;
})(LanguageSelector || (LanguageSelector = {}));
var NotebookRange$1;
 (function(NotebookRange) {
    function from(range) {
        return { start: range.start, end: range.end };
    }
    NotebookRange.from = from;
    function to(range) {
        return new NotebookRange$2(range.start, range.end);
    }
    NotebookRange.to = to;
})(NotebookRange$1 || (NotebookRange$1 = {}));
var NotebookCellExecutionSummary;
 (function(NotebookCellExecutionSummary) {
    function to(data) {
        return {
            timing: typeof data.runStartTime === 'number' && typeof data.runEndTime === 'number' ? { startTime: data.runStartTime, endTime: data.runEndTime } : undefined,
            executionOrder: data.executionOrder,
            success: data.lastRunSuccess
        };
    }
    NotebookCellExecutionSummary.to = to;
    function from(data) {
        return {
            lastRunSuccess: data.success,
            runStartTime: data.timing?.startTime,
            runEndTime: data.timing?.endTime,
            executionOrder: data.executionOrder
        };
    }
    NotebookCellExecutionSummary.from = from;
})(NotebookCellExecutionSummary || (NotebookCellExecutionSummary = {}));
var NotebookCellKind$1;
 (function(NotebookCellKind) {
    function from(data) {
        switch (data) {
            case NotebookCellKind$2.Markup:
                return CellKind.Markup;
            case NotebookCellKind$2.Code:
            default:
                return CellKind.Code;
        }
    }
    NotebookCellKind.from = from;
    function to(data) {
        switch (data) {
            case CellKind.Markup:
                return NotebookCellKind$2.Markup;
            case CellKind.Code:
            default:
                return NotebookCellKind$2.Code;
        }
    }
    NotebookCellKind.to = to;
})(NotebookCellKind$1 || (NotebookCellKind$1 = {}));
var NotebookCellData$1;
 (function(NotebookCellData) {
    function from(data) {
        return {
            cellKind: NotebookCellKind$1.from(data.kind),
            language: data.languageId,
            mime: data.mime,
            source: data.value,
            metadata: data.metadata,
            internalMetadata: NotebookCellExecutionSummary.from(data.executionSummary ?? {}),
            outputs: data.outputs ? data.outputs.map(NotebookCellOutput$1.from) : []
        };
    }
    NotebookCellData.from = from;
    function to(data) {
        return new NotebookCellData$2(NotebookCellKind$1.to(data.cellKind), data.source, data.language, data.mime, data.outputs ? data.outputs.map(NotebookCellOutput$1.to) : undefined, data.metadata, data.internalMetadata ? NotebookCellExecutionSummary.to(data.internalMetadata) : undefined);
    }
    NotebookCellData.to = to;
})(NotebookCellData$1 || (NotebookCellData$1 = {}));
var NotebookCellOutputItem$1;
 (function(NotebookCellOutputItem) {
    function from(item) {
        return {
            mime: item.mime,
            valueBytes: VSBuffer.wrap(item.data),
        };
    }
    NotebookCellOutputItem.from = from;
    function to(item) {
        return new NotebookCellOutputItem$2(item.valueBytes.buffer, item.mime);
    }
    NotebookCellOutputItem.to = to;
})(NotebookCellOutputItem$1 || (NotebookCellOutputItem$1 = {}));
var NotebookCellOutput$1;
 (function(NotebookCellOutput) {
    function from(output) {
        return {
            outputId: output.id,
            items: output.items.map(NotebookCellOutputItem$1.from),
            metadata: output.metadata
        };
    }
    NotebookCellOutput.from = from;
    function to(output) {
        const items = output.items.map(NotebookCellOutputItem$1.to);
        return new NotebookCellOutput$2(items, output.outputId, output.metadata);
    }
    NotebookCellOutput.to = to;
})(NotebookCellOutput$1 || (NotebookCellOutput$1 = {}));
var CodeActionTriggerKind$1;
 (function(CodeActionTriggerKind) {
    function to(value) {
        switch (value) {
            case 1 :
                return CodeActionTriggerKind$2.Invoke;
            case 2 :
                return CodeActionTriggerKind$2.Automatic;
        }
    }
    CodeActionTriggerKind.to = to;
})(CodeActionTriggerKind$1 || (CodeActionTriggerKind$1 = {}));
var TypeHierarchyItem$1;
 (function(TypeHierarchyItem) {
    function to(item) {
        const result = new TypeHierarchyItem$2(SymbolKind$1.to(item.kind), item.name, item.detail || '', URI.revive(item.uri), Range$1.to(item.range), Range$1.to(item.selectionRange));
        result._sessionId = item._sessionId;
        result._itemId = item._itemId;
        return result;
    }
    TypeHierarchyItem.to = to;
    function from(item, sessionId, itemId) {
        sessionId = sessionId ?? item._sessionId;
        itemId = itemId ?? item._itemId;
        if (sessionId === undefined || itemId === undefined) {
            throw new Error('invalid item');
        }
        return {
            _sessionId: sessionId,
            _itemId: itemId,
            kind: SymbolKind$1.from(item.kind),
            name: item.name,
            detail: item.detail ?? '',
            uri: item.uri,
            range: Range$1.from(item.range),
            selectionRange: Range$1.from(item.selectionRange),
            tags: item.tags?.map(SymbolTag$1.from)
        };
    }
    TypeHierarchyItem.from = from;
})(TypeHierarchyItem$1 || (TypeHierarchyItem$1 = {}));
class ProxyIdentifier {
    constructor(sid) {
        this._proxyIdentifierBrand = undefined;
        this.sid = sid;
        this.nid = (++ProxyIdentifier.count);
    }
}
ProxyIdentifier.count = 0;
const identifiers = [];
function createProxyIdentifier(identifier) {
    const result =  new ProxyIdentifier(identifier);
    identifiers[result.nid] = result;
    return result;
}
function getStringIdentifierForProxy(nid) {
    return identifiers[nid].sid;
}
class SerializableObjectWithBuffers {
    constructor(value) {
        this.value = value;
    }
}
function reviveWorkspaceEditDto(data) {
    if (data && data.edits) {
        for (const edit of data.edits) {
            if (typeof edit.resource === 'object') {
                edit.resource = URI.revive(edit.resource);
            }
            else {
                edit.newUri = URI.revive(edit.newUri);
                edit.oldUri = URI.revive(edit.oldUri);
            }
            if (edit.metadata && edit.metadata.iconPath) {
                edit.metadata = revive(edit.metadata);
            }
        }
    }
    return data;
}
const MainContext = {
    MainThreadAuthentication:  createProxyIdentifier('MainThreadAuthentication'),
    MainThreadBulkEdits:  createProxyIdentifier('MainThreadBulkEdits'),
    MainThreadClipboard:  createProxyIdentifier('MainThreadClipboard'),
    MainThreadCommands:  createProxyIdentifier('MainThreadCommands'),
    MainThreadComments:  createProxyIdentifier('MainThreadComments'),
    MainThreadConfiguration:  createProxyIdentifier('MainThreadConfiguration'),
    MainThreadConsole:  createProxyIdentifier('MainThreadConsole'),
    MainThreadDebugService:  createProxyIdentifier('MainThreadDebugService'),
    MainThreadDecorations:  createProxyIdentifier('MainThreadDecorations'),
    MainThreadDiagnostics:  createProxyIdentifier('MainThreadDiagnostics'),
    MainThreadDialogs:  createProxyIdentifier('MainThreadDiaglogs'),
    MainThreadDocuments:  createProxyIdentifier('MainThreadDocuments'),
    MainThreadDocumentContentProviders:  createProxyIdentifier('MainThreadDocumentContentProviders'),
    MainThreadTextEditors:  createProxyIdentifier('MainThreadTextEditors'),
    MainThreadEditorInsets:  createProxyIdentifier('MainThreadEditorInsets'),
    MainThreadEditorTabs:  createProxyIdentifier('MainThreadEditorTabs'),
    MainThreadErrors:  createProxyIdentifier('MainThreadErrors'),
    MainThreadTreeViews:  createProxyIdentifier('MainThreadTreeViews'),
    MainThreadDownloadService:  createProxyIdentifier('MainThreadDownloadService'),
    MainThreadKeytar:  createProxyIdentifier('MainThreadKeytar'),
    MainThreadLanguageFeatures:  createProxyIdentifier('MainThreadLanguageFeatures'),
    MainThreadLanguages:  createProxyIdentifier('MainThreadLanguages'),
    MainThreadLogger:  createProxyIdentifier('MainThreadLogger'),
    MainThreadMessageService:  createProxyIdentifier('MainThreadMessageService'),
    MainThreadOutputService:  createProxyIdentifier('MainThreadOutputService'),
    MainThreadProgress:  createProxyIdentifier('MainThreadProgress'),
    MainThreadQuickOpen:  createProxyIdentifier('MainThreadQuickOpen'),
    MainThreadStatusBar:  createProxyIdentifier('MainThreadStatusBar'),
    MainThreadSecretState:  createProxyIdentifier('MainThreadSecretState'),
    MainThreadStorage:  createProxyIdentifier('MainThreadStorage'),
    MainThreadTelemetry:  createProxyIdentifier('MainThreadTelemetry'),
    MainThreadTerminalService:  createProxyIdentifier('MainThreadTerminalService'),
    MainThreadWebviews:  createProxyIdentifier('MainThreadWebviews'),
    MainThreadWebviewPanels:  createProxyIdentifier('MainThreadWebviewPanels'),
    MainThreadWebviewViews:  createProxyIdentifier('MainThreadWebviewViews'),
    MainThreadCustomEditors:  createProxyIdentifier('MainThreadCustomEditors'),
    MainThreadUrls:  createProxyIdentifier('MainThreadUrls'),
    MainThreadUriOpeners:  createProxyIdentifier('MainThreadUriOpeners'),
    MainThreadWorkspace:  createProxyIdentifier('MainThreadWorkspace'),
    MainThreadFileSystem:  createProxyIdentifier('MainThreadFileSystem'),
    MainThreadExtensionService:  createProxyIdentifier('MainThreadExtensionService'),
    MainThreadSCM:  createProxyIdentifier('MainThreadSCM'),
    MainThreadSearch:  createProxyIdentifier('MainThreadSearch'),
    MainThreadTask:  createProxyIdentifier('MainThreadTask'),
    MainThreadWindow:  createProxyIdentifier('MainThreadWindow'),
    MainThreadLabelService:  createProxyIdentifier('MainThreadLabelService'),
    MainThreadNotebook:  createProxyIdentifier('MainThreadNotebook'),
    MainThreadNotebookDocuments:  createProxyIdentifier('MainThreadNotebookDocumentsShape'),
    MainThreadNotebookEditors:  createProxyIdentifier('MainThreadNotebookEditorsShape'),
    MainThreadNotebookKernels:  createProxyIdentifier('MainThreadNotebookKernels'),
    MainThreadNotebookRenderers:  createProxyIdentifier('MainThreadNotebookRenderers'),
    MainThreadInteractive:  createProxyIdentifier('MainThreadInteractive'),
    MainThreadTheming:  createProxyIdentifier('MainThreadTheming'),
    MainThreadTunnelService:  createProxyIdentifier('MainThreadTunnelService'),
    MainThreadTimeline:  createProxyIdentifier('MainThreadTimeline'),
    MainThreadTesting:  createProxyIdentifier('MainThreadTesting'),
};
const ExtHostContext = {
    ExtHostCommands:  createProxyIdentifier('ExtHostCommands'),
    ExtHostConfiguration:  createProxyIdentifier('ExtHostConfiguration'),
    ExtHostDiagnostics:  createProxyIdentifier('ExtHostDiagnostics'),
    ExtHostDebugService:  createProxyIdentifier('ExtHostDebugService'),
    ExtHostDecorations:  createProxyIdentifier('ExtHostDecorations'),
    ExtHostDocumentsAndEditors:  createProxyIdentifier('ExtHostDocumentsAndEditors'),
    ExtHostDocuments:  createProxyIdentifier('ExtHostDocuments'),
    ExtHostDocumentContentProviders:  createProxyIdentifier('ExtHostDocumentContentProviders'),
    ExtHostDocumentSaveParticipant:  createProxyIdentifier('ExtHostDocumentSaveParticipant'),
    ExtHostEditors:  createProxyIdentifier('ExtHostEditors'),
    ExtHostTreeViews:  createProxyIdentifier('ExtHostTreeViews'),
    ExtHostFileSystem:  createProxyIdentifier('ExtHostFileSystem'),
    ExtHostFileSystemInfo:  createProxyIdentifier('ExtHostFileSystemInfo'),
    ExtHostFileSystemEventService:  createProxyIdentifier('ExtHostFileSystemEventService'),
    ExtHostLanguages:  createProxyIdentifier('ExtHostLanguages'),
    ExtHostLanguageFeatures:  createProxyIdentifier('ExtHostLanguageFeatures'),
    ExtHostQuickOpen:  createProxyIdentifier('ExtHostQuickOpen'),
    ExtHostExtensionService:  createProxyIdentifier('ExtHostExtensionService'),
    ExtHostLogLevelServiceShape:  createProxyIdentifier('ExtHostLogLevelServiceShape'),
    ExtHostTerminalService:  createProxyIdentifier('ExtHostTerminalService'),
    ExtHostSCM:  createProxyIdentifier('ExtHostSCM'),
    ExtHostSearch:  createProxyIdentifier('ExtHostSearch'),
    ExtHostTask:  createProxyIdentifier('ExtHostTask'),
    ExtHostWorkspace:  createProxyIdentifier('ExtHostWorkspace'),
    ExtHostWindow:  createProxyIdentifier('ExtHostWindow'),
    ExtHostWebviews:  createProxyIdentifier('ExtHostWebviews'),
    ExtHostWebviewPanels:  createProxyIdentifier('ExtHostWebviewPanels'),
    ExtHostCustomEditors:  createProxyIdentifier('ExtHostCustomEditors'),
    ExtHostWebviewViews:  createProxyIdentifier('ExtHostWebviewViews'),
    ExtHostEditorInsets:  createProxyIdentifier('ExtHostEditorInsets'),
    ExtHostEditorTabs:  createProxyIdentifier('ExtHostEditorTabs'),
    ExtHostProgress:  createProxyIdentifier('ExtHostProgress'),
    ExtHostComments:  createProxyIdentifier('ExtHostComments'),
    ExtHostSecretState:  createProxyIdentifier('ExtHostSecretState'),
    ExtHostStorage:  createProxyIdentifier('ExtHostStorage'),
    ExtHostUrls:  createProxyIdentifier('ExtHostUrls'),
    ExtHostUriOpeners:  createProxyIdentifier('ExtHostUriOpeners'),
    ExtHostOutputService:  createProxyIdentifier('ExtHostOutputService'),
    ExtHosLabelService:  createProxyIdentifier('ExtHostLabelService'),
    ExtHostNotebook:  createProxyIdentifier('ExtHostNotebook'),
    ExtHostNotebookDocuments:  createProxyIdentifier('ExtHostNotebookDocuments'),
    ExtHostNotebookEditors:  createProxyIdentifier('ExtHostNotebookEditors'),
    ExtHostNotebookKernels:  createProxyIdentifier('ExtHostNotebookKernels'),
    ExtHostNotebookRenderers:  createProxyIdentifier('ExtHostNotebookRenderers'),
    ExtHostInteractive:  createProxyIdentifier('ExtHostInteractive'),
    ExtHostTheming:  createProxyIdentifier('ExtHostTheming'),
    ExtHostTunnelService:  createProxyIdentifier('ExtHostTunnelService'),
    ExtHostAuthentication:  createProxyIdentifier('ExtHostAuthentication'),
    ExtHostTimeline:  createProxyIdentifier('ExtHostTimeline'),
    ExtHostTesting:  createProxyIdentifier('ExtHostTesting'),
    ExtHostTelemetry:  createProxyIdentifier('ExtHostTelemetry'),
};
const Position$1 = monaco.Position;
const Selection$1 = monaco.Selection;
function reverseEndianness(arr) {
    for (let i = 0, len = arr.length; i < len; i += 4) {
        const b0 = arr[i + 0];
        const b1 = arr[i + 1];
        const b2 = arr[i + 2];
        const b3 = arr[i + 3];
        arr[i + 0] = b3;
        arr[i + 1] = b2;
        arr[i + 2] = b1;
        arr[i + 3] = b0;
    }
}
function fromLittleEndianBuffer(buff) {
    const uint8Arr = buff.buffer;
    if (!isLittleEndian()) {
        reverseEndianness(uint8Arr);
    }
    if (uint8Arr.byteOffset % 4 === 0) {
        return (
             new Uint32Array(uint8Arr.buffer, uint8Arr.byteOffset, uint8Arr.length / 4)
        );
    }
    else {
        const data =  new Uint8Array(uint8Arr.byteLength);
        data.set(uint8Arr);
        return (
             new Uint32Array(data.buffer, data.byteOffset, data.length / 4)
        );
    }
}
function decodeSemanticTokensDto(_buff) {
    const src = fromLittleEndianBuffer(_buff);
    let offset = 0;
    const id = src[offset++];
    const type = src[offset++];
    if (type === 1 ) {
        const length = src[offset++];
        const data = src.subarray(offset, offset + length);
        offset += length;
        return {
            id: id,
            type: 'full',
            data: data
        };
    }
    const deltaCount = src[offset++];
    const deltas = [];
    for (let i = 0; i < deltaCount; i++) {
        const start = src[offset++];
        const deleteCount = src[offset++];
        const length = src[offset++];
        let data;
        if (length > 0) {
            data = src.subarray(offset, offset + length);
            offset += length;
        }
        deltas[i] = { start, deleteCount, data };
    }
    return {
        id: id,
        type: 'delta',
        deltas: deltas
    };
}
class Cache {
    constructor(id) {
        this.id = id;
        this._data =  new Map();
        this._idPool = 1;
    }
    add(item) {
        const id = this._idPool++;
        this._data.set(id, item);
        this.logDebugInfo();
        return id;
    }
    get(pid, id) {
        return this._data.has(pid) ? this._data.get(pid)[id] : undefined;
    }
    delete(id) {
        this._data.delete(id);
        this.logDebugInfo();
    }
    logDebugInfo() {
        if (!Cache.enableDebugLogging) {
            return;
        }
        console.log(`${this.id} cache size - ${this._data.size}`);
    }
}
Cache.enableDebugLogging = false;
Object.freeze({
    identifier:  new ExtensionIdentifier('nullExtensionDescription'),
    name: 'Null Extension Description',
    version: '0.0.0',
    publisher: 'vscode',
    engines: { vscode: '' },
    extensionLocation: URI.parse('void:location'),
    isBuiltin: false,
    targetPlatform: "undefined" ,
    isUserBuiltin: false,
    isUnderDevelopment: false,
});
function isProposedApiEnabled(extension, proposal) {
    if (!extension.enabledApiProposals) {
        return false;
    }
    return extension.enabledApiProposals.includes(proposal);
}
 class DocumentSymbolAdapter {
    constructor(_documents, _provider) {
        this._documents = _documents;
        this._provider = _provider;
    }
    async provideDocumentSymbols(resource, token) {
        const doc = this._documents.getDocument(resource);
        const value = await this._provider.provideDocumentSymbols(doc, token);
        if (isFalsyOrEmpty(value)) {
            return undefined;
        }
        else if (value[0] instanceof DocumentSymbol$2) {
            return value.map(DocumentSymbol$1.from);
        }
        else {
            return DocumentSymbolAdapter._asDocumentSymbolTree(value);
        }
    }
    static _asDocumentSymbolTree(infos) {
        infos = infos.slice(0).sort((a, b) => {
            let res = a.location.range.start.compareTo(b.location.range.start);
            if (res === 0) {
                res = b.location.range.end.compareTo(a.location.range.end);
            }
            return res;
        });
        const res = [];
        const parentStack = [];
        for (const info of infos) {
            const element = {
                name: info.name || '!!MISSING: name!!',
                kind: SymbolKind$1.from(info.kind),
                tags: info.tags?.map(SymbolTag$1.from) || [],
                detail: '',
                containerName: info.containerName,
                range: Range$1.from(info.location.range),
                selectionRange: Range$1.from(info.location.range),
                children: []
            };
            while (true) {
                if (parentStack.length === 0) {
                    parentStack.push(element);
                    res.push(element);
                    break;
                }
                const parent = parentStack[parentStack.length - 1];
                if (Range$2.containsRange(parent.range, element.range) && !Range$2.equalsRange(parent.range, element.range)) {
                    if (parent.children) {
                        parent.children.push(element);
                    }
                    parentStack.push(element);
                    break;
                }
                parentStack.pop();
            }
        }
        return res;
    }
}
 class CodeLensAdapter {
    constructor(_documents, _commands, _provider) {
        this._documents = _documents;
        this._commands = _commands;
        this._provider = _provider;
        this._cache =  new Cache('CodeLens');
        this._disposables =  new Map();
    }
    async provideCodeLenses(resource, token) {
        const doc = this._documents.getDocument(resource);
        const lenses = await this._provider.provideCodeLenses(doc, token);
        if (!lenses || token.isCancellationRequested) {
            return undefined;
        }
        const cacheId = this._cache.add(lenses);
        const disposables =  new DisposableStore();
        this._disposables.set(cacheId, disposables);
        const result = {
            cacheId,
            lenses: [],
        };
        for (let i = 0; i < lenses.length; i++) {
            result.lenses.push({
                cacheId: [cacheId, i],
                range: Range$1.from(lenses[i].range),
                command: this._commands.toInternal(lenses[i].command, disposables)
            });
        }
        return result;
    }
    async resolveCodeLens(symbol, token) {
        const lens = symbol.cacheId && this._cache.get(...symbol.cacheId);
        if (!lens) {
            return undefined;
        }
        let resolvedLens;
        if (typeof this._provider.resolveCodeLens !== 'function' || lens.isResolved) {
            resolvedLens = lens;
        }
        else {
            resolvedLens = await this._provider.resolveCodeLens(lens, token);
        }
        if (!resolvedLens) {
            resolvedLens = lens;
        }
        if (token.isCancellationRequested) {
            return undefined;
        }
        const disposables = symbol.cacheId && this._disposables.get(symbol.cacheId[0]);
        if (!disposables) {
            return undefined;
        }
        symbol.command = this._commands.toInternal(resolvedLens.command ?? CodeLensAdapter._badCmd, disposables);
        return symbol;
    }
    releaseCodeLenses(cachedId) {
        this._disposables.get(cachedId)?.dispose();
        this._disposables.delete(cachedId);
        this._cache.delete(cachedId);
    }
}
CodeLensAdapter._badCmd = { command: 'missing', title: '!!MISSING: command!!' };
function convertToLocationLinks(value) {
    if (Array.isArray(value)) {
        return value.map(DefinitionLink.from);
    }
    else if (value) {
        return [DefinitionLink.from(value)];
    }
    return [];
}
 class DefinitionAdapter {
    constructor(_documents, _provider) {
        this._documents = _documents;
        this._provider = _provider;
    }
    async provideDefinition(resource, position, token) {
        const doc = this._documents.getDocument(resource);
        const pos = Position$2.to(position);
        const value = await this._provider.provideDefinition(doc, pos, token);
        return convertToLocationLinks(value);
    }
}
 class DeclarationAdapter {
    constructor(_documents, _provider) {
        this._documents = _documents;
        this._provider = _provider;
    }
    async provideDeclaration(resource, position, token) {
        const doc = this._documents.getDocument(resource);
        const pos = Position$2.to(position);
        const value = await this._provider.provideDeclaration(doc, pos, token);
        return convertToLocationLinks(value);
    }
}
 class ImplementationAdapter {
    constructor(_documents, _provider) {
        this._documents = _documents;
        this._provider = _provider;
    }
    async provideImplementation(resource, position, token) {
        const doc = this._documents.getDocument(resource);
        const pos = Position$2.to(position);
        const value = await this._provider.provideImplementation(doc, pos, token);
        return convertToLocationLinks(value);
    }
}
 class TypeDefinitionAdapter {
    constructor(_documents, _provider) {
        this._documents = _documents;
        this._provider = _provider;
    }
    async provideTypeDefinition(resource, position, token) {
        const doc = this._documents.getDocument(resource);
        const pos = Position$2.to(position);
        const value = await this._provider.provideTypeDefinition(doc, pos, token);
        return convertToLocationLinks(value);
    }
}
 class HoverAdapter {
    constructor(_documents, _provider) {
        this._documents = _documents;
        this._provider = _provider;
    }
    async provideHover(resource, position, token) {
        const doc = this._documents.getDocument(resource);
        const pos = Position$2.to(position);
        const value = await this._provider.provideHover(doc, pos, token);
        if (!value || isFalsyOrEmpty(value.contents)) {
            return undefined;
        }
        if (!value.range) {
            value.range = doc.getWordRangeAtPosition(pos);
        }
        if (!value.range) {
            value.range =  new Range$3(pos, pos);
        }
        return Hover$1.from(value);
    }
}
 class EvaluatableExpressionAdapter {
    constructor(_documents, _provider) {
        this._documents = _documents;
        this._provider = _provider;
    }
    async provideEvaluatableExpression(resource, position, token) {
        const doc = this._documents.getDocument(resource);
        const pos = Position$2.to(position);
        const value = await this._provider.provideEvaluatableExpression(doc, pos, token);
        if (value) {
            return EvaluatableExpression$1.from(value);
        }
        return undefined;
    }
}
 class DocumentHighlightAdapter {
    constructor(_documents, _provider) {
        this._documents = _documents;
        this._provider = _provider;
    }
    async provideDocumentHighlights(resource, position, token) {
        const doc = this._documents.getDocument(resource);
        const pos = Position$2.to(position);
        const value = await this._provider.provideDocumentHighlights(doc, pos, token);
        if (Array.isArray(value)) {
            return value.map(DocumentHighlight$1.from);
        }
        return undefined;
    }
}
 class LinkedEditingRangeAdapter {
    constructor(_documents, _provider) {
        this._documents = _documents;
        this._provider = _provider;
    }
    async provideLinkedEditingRanges(resource, position, token) {
        const doc = this._documents.getDocument(resource);
        const pos = Position$2.to(position);
        const value = await this._provider.provideLinkedEditingRanges(doc, pos, token);
        if (value && Array.isArray(value.ranges)) {
            return {
                ranges: coalesce(value.ranges.map(Range$1.from)),
                wordPattern: value.wordPattern
            };
        }
        return undefined;
    }
}
 class ReferenceAdapter {
    constructor(_documents, _provider) {
        this._documents = _documents;
        this._provider = _provider;
    }
    async provideReferences(resource, position, context, token) {
        const doc = this._documents.getDocument(resource);
        const pos = Position$2.to(position);
        const value = await this._provider.provideReferences(doc, pos, context, token);
        if (Array.isArray(value)) {
            return value.map(location.from);
        }
        return undefined;
    }
}
 class CodeActionAdapter {
    constructor(_documents, _commands, _diagnostics, _provider, _logService, _extension, _apiDeprecation) {
        this._documents = _documents;
        this._commands = _commands;
        this._diagnostics = _diagnostics;
        this._provider = _provider;
        this._logService = _logService;
        this._extension = _extension;
        this._apiDeprecation = _apiDeprecation;
        this._cache =  new Cache('CodeAction');
        this._disposables =  new Map();
    }
    async provideCodeActions(resource, rangeOrSelection, context, token) {
        const doc = this._documents.getDocument(resource);
        const ran = Selection$1.isISelection(rangeOrSelection)
            ? Selection$2.to(rangeOrSelection)
            : Range$1.to(rangeOrSelection);
        const allDiagnostics = [];
        for (const diagnostic of this._diagnostics.getDiagnostics(resource)) {
            if (ran.intersection(diagnostic.range)) {
                const newLen = allDiagnostics.push(diagnostic);
                if (newLen > CodeActionAdapter._maxCodeActionsPerFile) {
                    break;
                }
            }
        }
        const codeActionContext = {
            diagnostics: allDiagnostics,
            only: context.only ?  new CodeActionKind$1(context.only) : undefined,
            triggerKind: CodeActionTriggerKind$1.to(context.trigger),
        };
        const commandsOrActions = await this._provider.provideCodeActions(doc, ran, codeActionContext, token);
        if (!isNonEmptyArray(commandsOrActions) || token.isCancellationRequested) {
            return undefined;
        }
        const cacheId = this._cache.add(commandsOrActions);
        const disposables =  new DisposableStore();
        this._disposables.set(cacheId, disposables);
        const actions = [];
        for (let i = 0; i < commandsOrActions.length; i++) {
            const candidate = commandsOrActions[i];
            if (!candidate) {
                continue;
            }
            if (CodeActionAdapter._isCommand(candidate)) {
                this._apiDeprecation.report('CodeActionProvider.provideCodeActions - return commands', this._extension, `Return 'CodeAction' instances instead.`);
                actions.push({
                    _isSynthetic: true,
                    title: candidate.title,
                    command: this._commands.toInternal(candidate, disposables),
                });
            }
            else {
                if (codeActionContext.only) {
                    if (!candidate.kind) {
                        this._logService.warn(`${this._extension.identifier.value} - Code actions of kind '${codeActionContext.only.value} 'requested but returned code action does not have a 'kind'. Code action will be dropped. Please set 'CodeAction.kind'.`);
                    }
                    else if (!codeActionContext.only.contains(candidate.kind)) {
                        this._logService.warn(`${this._extension.identifier.value} - Code actions of kind '${codeActionContext.only.value} 'requested but returned code action is of kind '${candidate.kind.value}'. Code action will be dropped. Please check 'CodeActionContext.only' to only return requested code actions.`);
                    }
                }
                actions.push({
                    cacheId: [cacheId, i],
                    title: candidate.title,
                    command: candidate.command && this._commands.toInternal(candidate.command, disposables),
                    diagnostics: candidate.diagnostics && candidate.diagnostics.map(Diagnostic$1.from),
                    edit: candidate.edit && WorkspaceEdit$1.from(candidate.edit),
                    kind: candidate.kind && candidate.kind.value,
                    isPreferred: candidate.isPreferred,
                    disabled: candidate.disabled?.reason
                });
            }
        }
        return { cacheId, actions };
    }
    async resolveCodeAction(id, token) {
        const [sessionId, itemId] = id;
        const item = this._cache.get(sessionId, itemId);
        if (!item || CodeActionAdapter._isCommand(item)) {
            return undefined;
        }
        if (!this._provider.resolveCodeAction) {
            return;
        }
        const resolvedItem = (await this._provider.resolveCodeAction(item, token)) ?? item;
        return resolvedItem?.edit
            ? WorkspaceEdit$1.from(resolvedItem.edit)
            : undefined;
    }
    releaseCodeActions(cachedId) {
        this._disposables.get(cachedId)?.dispose();
        this._disposables.delete(cachedId);
        this._cache.delete(cachedId);
    }
    static _isCommand(thing) {
        return typeof thing.command === 'string' && typeof thing.title === 'string';
    }
}
CodeActionAdapter._maxCodeActionsPerFile = 1000;
 class DocumentFormattingAdapter {
    constructor(_documents, _provider) {
        this._documents = _documents;
        this._provider = _provider;
    }
    async provideDocumentFormattingEdits(resource, options, token) {
        const document = this._documents.getDocument(resource);
        const value = await this._provider.provideDocumentFormattingEdits(document, options, token);
        if (Array.isArray(value)) {
            return value.map(TextEdit$1.from);
        }
        return undefined;
    }
}
 class RangeFormattingAdapter {
    constructor(_documents, _provider) {
        this._documents = _documents;
        this._provider = _provider;
    }
    async provideDocumentRangeFormattingEdits(resource, range, options, token) {
        const document = this._documents.getDocument(resource);
        const ran = Range$1.to(range);
        const value = await this._provider.provideDocumentRangeFormattingEdits(document, ran, options, token);
        if (Array.isArray(value)) {
            return value.map(TextEdit$1.from);
        }
        return undefined;
    }
}
 class OnTypeFormattingAdapter {
    constructor(_documents, _provider) {
        this._documents = _documents;
        this._provider = _provider;
        this.autoFormatTriggerCharacters = [];
    }
    async provideOnTypeFormattingEdits(resource, position, ch, options, token) {
        const document = this._documents.getDocument(resource);
        const pos = Position$2.to(position);
        const value = await this._provider.provideOnTypeFormattingEdits(document, pos, ch, options, token);
        if (Array.isArray(value)) {
            return value.map(TextEdit$1.from);
        }
        return undefined;
    }
}
 class NavigateTypeAdapter {
    constructor(_provider, _logService) {
        this._provider = _provider;
        this._logService = _logService;
        this._cache =  new Cache('WorkspaceSymbols');
    }
    async provideWorkspaceSymbols(search, token) {
        const value = await this._provider.provideWorkspaceSymbols(search, token);
        if (!isNonEmptyArray(value)) {
            return { symbols: [] };
        }
        const sid = this._cache.add(value);
        const result = {
            cacheId: sid,
            symbols: []
        };
        for (let i = 0; i < value.length; i++) {
            const item = value[i];
            if (!item || !item.name) {
                this._logService.warn('INVALID SymbolInformation', item);
                continue;
            }
            result.symbols.push({
                ...WorkspaceSymbol.from(item),
                cacheId: [sid, i]
            });
        }
        return result;
    }
    async resolveWorkspaceSymbol(symbol, token) {
        if (typeof this._provider.resolveWorkspaceSymbol !== 'function') {
            return symbol;
        }
        if (!symbol.cacheId) {
            return symbol;
        }
        const item = this._cache.get(...symbol.cacheId);
        if (item) {
            const value = await this._provider.resolveWorkspaceSymbol(item, token);
            return value && mixin(symbol, WorkspaceSymbol.from(value), true);
        }
        return undefined;
    }
    releaseWorkspaceSymbols(id) {
        this._cache.delete(id);
    }
}
 class RenameAdapter {
    constructor(_documents, _provider, _logService) {
        this._documents = _documents;
        this._provider = _provider;
        this._logService = _logService;
    }
    static supportsResolving(provider) {
        return typeof provider.prepareRename === 'function';
    }
    async provideRenameEdits(resource, position, newName, token) {
        const doc = this._documents.getDocument(resource);
        const pos = Position$2.to(position);
        try {
            const value = await this._provider.provideRenameEdits(doc, pos, newName, token);
            if (!value) {
                return undefined;
            }
            return WorkspaceEdit$1.from(value);
        }
        catch (err) {
            const rejectReason = RenameAdapter._asMessage(err);
            if (rejectReason) {
                return { rejectReason, edits: undefined };
            }
            else {
                return Promise.reject(err);
            }
        }
    }
    async resolveRenameLocation(resource, position, token) {
        if (typeof this._provider.prepareRename !== 'function') {
            return Promise.resolve(undefined);
        }
        const doc = this._documents.getDocument(resource);
        const pos = Position$2.to(position);
        try {
            const rangeOrLocation = await this._provider.prepareRename(doc, pos, token);
            let range;
            let text;
            if (Range$3.isRange(rangeOrLocation)) {
                range = rangeOrLocation;
                text = doc.getText(rangeOrLocation);
            }
            else if (isObject(rangeOrLocation)) {
                range = rangeOrLocation.range;
                text = rangeOrLocation.placeholder;
            }
            if (!range || !text) {
                return undefined;
            }
            if (range.start.line > pos.line || range.end.line < pos.line) {
                this._logService.warn('INVALID rename location: position line must be within range start/end lines');
                return undefined;
            }
            return { range: Range$1.from(range), text };
        }
        catch (err) {
            const rejectReason = RenameAdapter._asMessage(err);
            if (rejectReason) {
                return { rejectReason, range: undefined, text: undefined };
            }
            else {
                return Promise.reject(err);
            }
        }
    }
    static _asMessage(err) {
        if (typeof err === 'string') {
            return err;
        }
        else if (err instanceof Error && typeof err.message === 'string') {
            return err.message;
        }
        else {
            return undefined;
        }
    }
}
 class SemanticTokensPreviousResult {
    constructor(resultId, tokens) {
        this.resultId = resultId;
        this.tokens = tokens;
    }
}
class DocumentSemanticTokensAdapter {
    constructor(_documents, _provider) {
        this._documents = _documents;
        this._provider = _provider;
        this._nextResultId = 1;
        this._previousResults =  new Map();
    }
    async provideDocumentSemanticTokens(resource, previousResultId, token) {
        const doc = this._documents.getDocument(resource);
        const previousResult = (previousResultId !== 0 ? this._previousResults.get(previousResultId) : null);
        let value = typeof previousResult?.resultId === 'string' && typeof this._provider.provideDocumentSemanticTokensEdits === 'function'
            ? await this._provider.provideDocumentSemanticTokensEdits(doc, previousResult.resultId, token)
            : await this._provider.provideDocumentSemanticTokens(doc, token);
        if (previousResult) {
            this._previousResults.delete(previousResultId);
        }
        if (!value) {
            return null;
        }
        value = DocumentSemanticTokensAdapter._fixProvidedSemanticTokens(value);
        return this._send(DocumentSemanticTokensAdapter._convertToEdits(previousResult, value), value);
    }
    async releaseDocumentSemanticColoring(semanticColoringResultId) {
        this._previousResults.delete(semanticColoringResultId);
    }
    static _fixProvidedSemanticTokens(v) {
        if (DocumentSemanticTokensAdapter._isSemanticTokens(v)) {
            if (DocumentSemanticTokensAdapter._isCorrectSemanticTokens(v)) {
                return v;
            }
            return (
                 new SemanticTokens$1( new Uint32Array(v.data), v.resultId)
            );
        }
        else if (DocumentSemanticTokensAdapter._isSemanticTokensEdits(v)) {
            if (DocumentSemanticTokensAdapter._isCorrectSemanticTokensEdits(v)) {
                return v;
            }
            return (
                 new SemanticTokensEdits$1(v.edits.map(edit =>  new SemanticTokensEdit$1(edit.start, edit.deleteCount, edit.data ?  new Uint32Array(edit.data) : edit.data)), v.resultId)
            );
        }
        return v;
    }
    static _isSemanticTokens(v) {
        return v && !!(v.data);
    }
    static _isCorrectSemanticTokens(v) {
        return (v.data instanceof Uint32Array);
    }
    static _isSemanticTokensEdits(v) {
        return v && Array.isArray(v.edits);
    }
    static _isCorrectSemanticTokensEdits(v) {
        for (const edit of v.edits) {
            if (!(edit.data instanceof Uint32Array)) {
                return false;
            }
        }
        return true;
    }
    static _convertToEdits(previousResult, newResult) {
        if (!DocumentSemanticTokensAdapter._isSemanticTokens(newResult)) {
            return newResult;
        }
        if (!previousResult || !previousResult.tokens) {
            return newResult;
        }
        const oldData = previousResult.tokens;
        const oldLength = oldData.length;
        const newData = newResult.data;
        const newLength = newData.length;
        let commonPrefixLength = 0;
        const maxCommonPrefixLength = Math.min(oldLength, newLength);
        while (commonPrefixLength < maxCommonPrefixLength && oldData[commonPrefixLength] === newData[commonPrefixLength]) {
            commonPrefixLength++;
        }
        if (commonPrefixLength === oldLength && commonPrefixLength === newLength) {
            return (
                 new SemanticTokensEdits$1([], newResult.resultId)
            );
        }
        let commonSuffixLength = 0;
        const maxCommonSuffixLength = maxCommonPrefixLength - commonPrefixLength;
        while (commonSuffixLength < maxCommonSuffixLength && oldData[oldLength - commonSuffixLength - 1] === newData[newLength - commonSuffixLength - 1]) {
            commonSuffixLength++;
        }
        return (
             new SemanticTokensEdits$1([{
                    start: commonPrefixLength,
                    deleteCount: (oldLength - commonPrefixLength - commonSuffixLength),
                    data: newData.subarray(commonPrefixLength, newLength - commonSuffixLength)
                }], newResult.resultId)
        );
    }
    _send(value, original) {
        if (DocumentSemanticTokensAdapter._isSemanticTokens(value)) {
            const myId = this._nextResultId++;
            this._previousResults.set(myId,  new SemanticTokensPreviousResult(value.resultId, value.data));
            return encodeSemanticTokensDto({
                id: myId,
                type: 'full',
                data: value.data
            });
        }
        if (DocumentSemanticTokensAdapter._isSemanticTokensEdits(value)) {
            const myId = this._nextResultId++;
            if (DocumentSemanticTokensAdapter._isSemanticTokens(original)) {
                this._previousResults.set(myId,  new SemanticTokensPreviousResult(original.resultId, original.data));
            }
            else {
                this._previousResults.set(myId,  new SemanticTokensPreviousResult(value.resultId));
            }
            return encodeSemanticTokensDto({
                id: myId,
                type: 'delta',
                deltas: (value.edits || []).map(edit => ({ start: edit.start, deleteCount: edit.deleteCount, data: edit.data }))
            });
        }
        return null;
    }
}
class DocumentRangeSemanticTokensAdapter {
    constructor(_documents, _provider) {
        this._documents = _documents;
        this._provider = _provider;
    }
    async provideDocumentRangeSemanticTokens(resource, range, token) {
        const doc = this._documents.getDocument(resource);
        const value = await this._provider.provideDocumentRangeSemanticTokens(doc, Range$1.to(range), token);
        if (!value) {
            return null;
        }
        return this._send(value);
    }
    _send(value) {
        return encodeSemanticTokensDto({
            id: 0,
            type: 'full',
            data: value.data
        });
    }
}
 class CompletionsAdapter {
    constructor(_documents, _commands, _provider, _apiDeprecation, _extension) {
        this._documents = _documents;
        this._commands = _commands;
        this._provider = _provider;
        this._apiDeprecation = _apiDeprecation;
        this._extension = _extension;
        this._cache =  new Cache('CompletionItem');
        this._disposables =  new Map();
    }
    static supportsResolving(provider) {
        return typeof provider.resolveCompletionItem === 'function';
    }
    async provideCompletionItems(resource, position, context, token) {
        const doc = this._documents.getDocument(resource);
        const pos = Position$2.to(position);
        const replaceRange = doc.getWordRangeAtPosition(pos) ||  new Range$3(pos, pos);
        const insertRange = replaceRange.with({ end: pos });
        const sw =  new StopWatch(true);
        const itemsOrList = await this._provider.provideCompletionItems(doc, pos, token, CompletionContext.to(context));
        if (!itemsOrList) {
            return undefined;
        }
        if (token.isCancellationRequested) {
            return undefined;
        }
        const list = Array.isArray(itemsOrList) ?  new CompletionList$1(itemsOrList) : itemsOrList;
        const pid = CompletionsAdapter.supportsResolving(this._provider) ? this._cache.add(list.items) : this._cache.add([]);
        const disposables =  new DisposableStore();
        this._disposables.set(pid, disposables);
        const completions = [];
        const result = {
            x: pid,
            ["b" ]: completions,
            ["a" ]: { replace: Range$1.from(replaceRange), insert: Range$1.from(insertRange) },
            ["c" ]: list.isIncomplete || undefined,
            ["d" ]: sw.elapsed()
        };
        for (let i = 0; i < list.items.length; i++) {
            const item = list.items[i];
            const dto = this._convertCompletionItem(item, [pid, i], insertRange, replaceRange);
            completions.push(dto);
        }
        return result;
    }
    async resolveCompletionItem(id, token) {
        if (typeof this._provider.resolveCompletionItem !== 'function') {
            return undefined;
        }
        const item = this._cache.get(...id);
        if (!item) {
            return undefined;
        }
        const resolvedItem = await this._provider.resolveCompletionItem(item, token);
        if (!resolvedItem) {
            return undefined;
        }
        return this._convertCompletionItem(resolvedItem, id);
    }
    releaseCompletionItems(id) {
        this._disposables.get(id)?.dispose();
        this._disposables.delete(id);
        this._cache.delete(id);
    }
    _convertCompletionItem(item, id, defaultInsertRange, defaultReplaceRange) {
        const disposables = this._disposables.get(id[0]);
        if (!disposables) {
            throw Error('DisposableStore is missing...');
        }
        const result = {
            x: id,
            ["a" ]: item.label,
            ["b" ]: item.kind !== undefined ? CompletionItemKind$1.from(item.kind) : undefined,
            ["n" ]: item.tags && item.tags.map(CompletionItemTag$1.from),
            ["c" ]: item.detail,
            ["d" ]: typeof item.documentation === 'undefined' ? undefined : MarkdownString$1.fromStrict(item.documentation),
            ["e" ]: item.sortText !== item.label ? item.sortText : undefined,
            ["f" ]: item.filterText !== item.label ? item.filterText : undefined,
            ["g" ]: item.preselect || undefined,
            ["i" ]: item.keepWhitespace ? 1  : 0,
            ["k" ]: item.commitCharacters,
            ["l" ]: item.additionalTextEdits && item.additionalTextEdits.map(TextEdit$1.from),
            ["m" ]: this._commands.toInternal(item.command, disposables),
        };
        if (item.textEdit) {
            this._apiDeprecation.report('CompletionItem.textEdit', this._extension, `Use 'CompletionItem.insertText' and 'CompletionItem.range' instead.`);
            result["h" ] = item.textEdit.newText;
        }
        else if (typeof item.insertText === 'string') {
            result["h" ] = item.insertText;
        }
        else if (item.insertText instanceof SnippetString$1) {
            result["h" ] = item.insertText.value;
            result["i" ] |= 4 ;
        }
        let range;
        if (item.textEdit) {
            range = item.textEdit.range;
        }
        else if (item.range) {
            range = item.range;
        }
        if (Range$3.isRange(range)) {
            result["j" ] = Range$1.from(range);
        }
        else if (range && (!defaultInsertRange?.isEqual(range.inserting) || !defaultReplaceRange?.isEqual(range.replacing))) {
            result["j" ] = {
                insert: Range$1.from(range.inserting),
                replace: Range$1.from(range.replacing)
            };
        }
        return result;
    }
}
 class InlineCompletionAdapterBase {
    async provideInlineCompletions(resource, position, context, token) {
        return undefined;
    }
    disposeCompletions(pid) { }
    handleDidShowCompletionItem(pid, idx) { }
}
 class InlineCompletionAdapter extends InlineCompletionAdapterBase {
    constructor(_extension, _documents, _provider, _commands) {
        super();
        this._extension = _extension;
        this._documents = _documents;
        this._provider = _provider;
        this._commands = _commands;
        this._references =  new ReferenceMap();
        this._isAdditionsProposedApiEnabled = isProposedApiEnabled(this._extension, 'inlineCompletionsAdditions');
        this.languageTriggerKindToVSCodeTriggerKind = {
            [InlineCompletionTriggerKind$2.Automatic]: InlineCompletionTriggerKind$1.Automatic,
            [InlineCompletionTriggerKind$2.Explicit]: InlineCompletionTriggerKind$1.Invoke,
        };
    }
    get supportsHandleDidShowCompletionItem() {
        return isProposedApiEnabled(this._extension, 'inlineCompletionsAdditions') && typeof this._provider.handleDidShowCompletionItem === 'function';
    }
    async provideInlineCompletions(resource, position, context, token) {
        const doc = this._documents.getDocument(resource);
        const pos = Position$2.to(position);
        const result = await this._provider.provideInlineCompletionItems(doc, pos, {
            selectedCompletionInfo: context.selectedSuggestionInfo
                ? {
                    range: Range$1.to(context.selectedSuggestionInfo.range),
                    text: context.selectedSuggestionInfo.text
                }
                : undefined,
            triggerKind: this.languageTriggerKindToVSCodeTriggerKind[context.triggerKind]
        }, token);
        if (!result) {
            return undefined;
        }
        if (token.isCancellationRequested) {
            return undefined;
        }
        const normalizedResult = isArray(result) ? result : result.items;
        const commands = this._isAdditionsProposedApiEnabled ? isArray(result) ? [] : result.commands || [] : [];
        let disposableStore = undefined;
        const pid = this._references.createReferenceId({
            dispose() {
                if (disposableStore) {
                    disposableStore.dispose();
                }
            },
            items: normalizedResult
        });
        return {
            pid,
            items: normalizedResult.map((item, idx) => {
                let command = undefined;
                if (item.command) {
                    if (!disposableStore) {
                        disposableStore =  new DisposableStore();
                    }
                    command = this._commands.toInternal(item.command, disposableStore);
                }
                const insertText = item.insertText;
                return ({
                    insertText: typeof insertText === 'string' ? insertText : { snippet: insertText.value },
                    filterText: item.filterText,
                    range: item.range ? Range$1.from(item.range) : undefined,
                    command,
                    idx: idx,
                    completeBracketPairs: this._isAdditionsProposedApiEnabled ? item.completeBracketPairs : false
                });
            }),
            commands: commands.map(c => {
                if (!disposableStore) {
                    disposableStore =  new DisposableStore();
                }
                return this._commands.toInternal(c, disposableStore);
            })
        };
    }
    disposeCompletions(pid) {
        const data = this._references.disposeReferenceId(pid);
        data?.dispose();
    }
    handleDidShowCompletionItem(pid, idx) {
        const completionItem = this._references.get(pid)?.items[idx];
        if (completionItem) {
            if (this._provider.handleDidShowCompletionItem && this._isAdditionsProposedApiEnabled) {
                this._provider.handleDidShowCompletionItem(completionItem);
            }
        }
    }
}
 class ReferenceMap {
    constructor() {
        this._references =  new Map();
        this._idPool = 1;
    }
    createReferenceId(value) {
        const id = this._idPool++;
        this._references.set(id, value);
        return id;
    }
    disposeReferenceId(referenceId) {
        const value = this._references.get(referenceId);
        this._references.delete(referenceId);
        return value;
    }
    get(referenceId) {
        return this._references.get(referenceId);
    }
}
 class SignatureHelpAdapter {
    constructor(_documents, _provider) {
        this._documents = _documents;
        this._provider = _provider;
        this._cache =  new Cache('SignatureHelp');
    }
    async provideSignatureHelp(resource, position, context, token) {
        const doc = this._documents.getDocument(resource);
        const pos = Position$2.to(position);
        const vscodeContext = this.reviveContext(context);
        const value = await this._provider.provideSignatureHelp(doc, pos, token, vscodeContext);
        if (value) {
            const id = this._cache.add([value]);
            return { ...SignatureHelp$1.from(value), id };
        }
        return undefined;
    }
    reviveContext(context) {
        let activeSignatureHelp = undefined;
        if (context.activeSignatureHelp) {
            const revivedSignatureHelp = SignatureHelp$1.to(context.activeSignatureHelp);
            const saved = this._cache.get(context.activeSignatureHelp.id, 0);
            if (saved) {
                activeSignatureHelp = saved;
                activeSignatureHelp.activeSignature = revivedSignatureHelp.activeSignature;
                activeSignatureHelp.activeParameter = revivedSignatureHelp.activeParameter;
            }
            else {
                activeSignatureHelp = revivedSignatureHelp;
            }
        }
        return { ...context, activeSignatureHelp };
    }
    releaseSignatureHelp(id) {
        this._cache.delete(id);
    }
}
 class InlayHintsAdapter {
    constructor(_documents, _commands, _provider, _logService, _extension) {
        this._documents = _documents;
        this._commands = _commands;
        this._provider = _provider;
        this._logService = _logService;
        this._extension = _extension;
        this._cache =  new Cache('InlayHints');
        this._disposables =  new Map();
    }
    async provideInlayHints(resource, ran, token) {
        const doc = this._documents.getDocument(resource);
        const range = Range$1.to(ran);
        const hints = await this._provider.provideInlayHints(doc, range, token);
        if (!Array.isArray(hints) || hints.length === 0) {
            this._logService.trace(`[InlayHints] NO inlay hints from '${this._extension.identifier.value}' for ${ran}`);
            return undefined;
        }
        if (token.isCancellationRequested) {
            return undefined;
        }
        const pid = this._cache.add(hints);
        this._disposables.set(pid,  new DisposableStore());
        const result = { hints: [], cacheId: pid };
        for (let i = 0; i < hints.length; i++) {
            if (this._isValidInlayHint(hints[i], range)) {
                result.hints.push(this._convertInlayHint(hints[i], [pid, i]));
            }
        }
        this._logService.trace(`[InlayHints] ${result.hints.length} inlay hints from '${this._extension.identifier.value}' for ${ran}`);
        return result;
    }
    async resolveInlayHint(id, token) {
        if (typeof this._provider.resolveInlayHint !== 'function') {
            return undefined;
        }
        const item = this._cache.get(...id);
        if (!item) {
            return undefined;
        }
        const hint = await this._provider.resolveInlayHint(item, token);
        if (!hint) {
            return undefined;
        }
        if (!this._isValidInlayHint(hint)) {
            return undefined;
        }
        return this._convertInlayHint(hint, id);
    }
    releaseHints(id) {
        this._disposables.get(id)?.dispose();
        this._disposables.delete(id);
        this._cache.delete(id);
    }
    _isValidInlayHint(hint, range) {
        if (hint.label.length === 0 || Array.isArray(hint.label) && hint.label.every(part => part.value.length === 0)) {
            console.log('INVALID inlay hint, empty label', hint);
            return false;
        }
        if (range && !range.contains(hint.position)) {
            return false;
        }
        return true;
    }
    _convertInlayHint(hint, id) {
        const disposables = this._disposables.get(id[0]);
        if (!disposables) {
            throw Error('DisposableStore is missing...');
        }
        const result = {
            label: '',
            cacheId: id,
            tooltip: MarkdownString$1.fromStrict(hint.tooltip),
            position: Position$2.from(hint.position),
            textEdits: hint.textEdits && hint.textEdits.map(TextEdit$1.from),
            kind: hint.kind && InlayHintKind$1.from(hint.kind),
            paddingLeft: hint.paddingLeft,
            paddingRight: hint.paddingRight,
        };
        if (typeof hint.label === 'string') {
            result.label = hint.label;
        }
        else {
            result.label = hint.label.map(part => {
                let result = { label: part.value };
                result.tooltip = MarkdownString$1.fromStrict(part.tooltip);
                if (Location$1.isLocation(part.location)) {
                    result.location = location.from(part.location);
                }
                if (part.command) {
                    result.command = this._commands.toInternal(part.command, disposables);
                }
                return result;
            });
        }
        return result;
    }
}
 class LinkProviderAdapter {
    constructor(_documents, _provider) {
        this._documents = _documents;
        this._provider = _provider;
        this._cache =  new Cache('DocumentLink');
    }
    async provideLinks(resource, token) {
        const doc = this._documents.getDocument(resource);
        const links = await this._provider.provideDocumentLinks(doc, token);
        if (!Array.isArray(links) || links.length === 0) {
            return undefined;
        }
        if (token.isCancellationRequested) {
            return undefined;
        }
        if (typeof this._provider.resolveDocumentLink !== 'function') {
            return { links: links.filter(LinkProviderAdapter._validateLink).map(DocumentLink$1.from) };
        }
        else {
            const pid = this._cache.add(links);
            const result = { links: [], cacheId: pid };
            for (let i = 0; i < links.length; i++) {
                if (!LinkProviderAdapter._validateLink(links[i])) {
                    continue;
                }
                const dto = DocumentLink$1.from(links[i]);
                dto.cacheId = [pid, i];
                result.links.push(dto);
            }
            return result;
        }
    }
    static _validateLink(link) {
        if (link.target && link.target.path.length > 50000) {
            console.warn('DROPPING link because it is too long');
            return false;
        }
        return true;
    }
    async resolveLink(id, token) {
        if (typeof this._provider.resolveDocumentLink !== 'function') {
            return undefined;
        }
        const item = this._cache.get(...id);
        if (!item) {
            return undefined;
        }
        const link = await this._provider.resolveDocumentLink(item, token);
        if (!link || !LinkProviderAdapter._validateLink(link)) {
            return undefined;
        }
        return DocumentLink$1.from(link);
    }
    releaseLinks(id) {
        this._cache.delete(id);
    }
}
 class ColorProviderAdapter {
    constructor(_documents, _provider) {
        this._documents = _documents;
        this._provider = _provider;
    }
    async provideColors(resource, token) {
        const doc = this._documents.getDocument(resource);
        const colors = await this._provider.provideDocumentColors(doc, token);
        if (!Array.isArray(colors)) {
            return [];
        }
        const colorInfos = colors.map(ci => {
            return {
                color: Color$1.from(ci.color),
                range: Range$1.from(ci.range)
            };
        });
        return colorInfos;
    }
    async provideColorPresentations(resource, raw, token) {
        const document = this._documents.getDocument(resource);
        const range = Range$1.to(raw.range);
        const color = Color$1.to(raw.color);
        const value = await this._provider.provideColorPresentations(color, { document, range }, token);
        if (!Array.isArray(value)) {
            return undefined;
        }
        return value.map(ColorPresentation$1.from);
    }
}
 class FoldingProviderAdapter {
    constructor(_documents, _provider) {
        this._documents = _documents;
        this._provider = _provider;
    }
    async provideFoldingRanges(resource, context, token) {
        const doc = this._documents.getDocument(resource);
        const ranges = await this._provider.provideFoldingRanges(doc, context, token);
        if (!Array.isArray(ranges)) {
            return undefined;
        }
        return ranges.map(FoldingRange$1.from);
    }
}
 class SelectionRangeAdapter {
    constructor(_documents, _provider, _logService) {
        this._documents = _documents;
        this._provider = _provider;
        this._logService = _logService;
    }
    async provideSelectionRanges(resource, pos, token) {
        const document = this._documents.getDocument(resource);
        const positions = pos.map(Position$2.to);
        const allProviderRanges = await this._provider.provideSelectionRanges(document, positions, token);
        if (!isNonEmptyArray(allProviderRanges)) {
            return [];
        }
        if (allProviderRanges.length !== positions.length) {
            this._logService.warn('BAD selection ranges, provider must return ranges for each position');
            return [];
        }
        const allResults = [];
        for (let i = 0; i < positions.length; i++) {
            const oneResult = [];
            allResults.push(oneResult);
            let last = positions[i];
            let selectionRange = allProviderRanges[i];
            while (true) {
                if (!selectionRange.range.contains(last)) {
                    throw new Error('INVALID selection range, must contain the previous range');
                }
                oneResult.push(SelectionRange$1.from(selectionRange));
                if (!selectionRange.parent) {
                    break;
                }
                last = selectionRange.range;
                selectionRange = selectionRange.parent;
            }
        }
        return allResults;
    }
}
 class CallHierarchyAdapter {
    constructor(_documents, _provider) {
        this._documents = _documents;
        this._provider = _provider;
        this._idPool =  new IdGenerator('');
        this._cache =  new Map();
    }
    async prepareSession(uri, position, token) {
        const doc = this._documents.getDocument(uri);
        const pos = Position$2.to(position);
        const items = await this._provider.prepareCallHierarchy(doc, pos, token);
        if (!items) {
            return undefined;
        }
        const sessionId = this._idPool.nextId();
        this._cache.set(sessionId,  new Map());
        if (Array.isArray(items)) {
            return items.map(item => this._cacheAndConvertItem(sessionId, item));
        }
        else {
            return [this._cacheAndConvertItem(sessionId, items)];
        }
    }
    async provideCallsTo(sessionId, itemId, token) {
        const item = this._itemFromCache(sessionId, itemId);
        if (!item) {
            throw new Error('missing call hierarchy item');
        }
        const calls = await this._provider.provideCallHierarchyIncomingCalls(item, token);
        if (!calls) {
            return undefined;
        }
        return calls.map(call => {
            return {
                from: this._cacheAndConvertItem(sessionId, call.from),
                fromRanges: call.fromRanges.map(r => Range$1.from(r))
            };
        });
    }
    async provideCallsFrom(sessionId, itemId, token) {
        const item = this._itemFromCache(sessionId, itemId);
        if (!item) {
            throw new Error('missing call hierarchy item');
        }
        const calls = await this._provider.provideCallHierarchyOutgoingCalls(item, token);
        if (!calls) {
            return undefined;
        }
        return calls.map(call => {
            return {
                to: this._cacheAndConvertItem(sessionId, call.to),
                fromRanges: call.fromRanges.map(r => Range$1.from(r))
            };
        });
    }
    releaseSession(sessionId) {
        this._cache.delete(sessionId);
    }
    _cacheAndConvertItem(sessionId, item) {
        const map = this._cache.get(sessionId);
        const dto = CallHierarchyItem$1.from(item, sessionId, map.size.toString(36));
        map.set(dto._itemId, item);
        return dto;
    }
    _itemFromCache(sessionId, itemId) {
        const map = this._cache.get(sessionId);
        return map?.get(itemId);
    }
}
 class TypeHierarchyAdapter {
    constructor(_documents, _provider) {
        this._documents = _documents;
        this._provider = _provider;
        this._idPool =  new IdGenerator('');
        this._cache =  new Map();
    }
    async prepareSession(uri, position, token) {
        const doc = this._documents.getDocument(uri);
        const pos = Position$2.to(position);
        const items = await this._provider.prepareTypeHierarchy(doc, pos, token);
        if (!items) {
            return undefined;
        }
        const sessionId = this._idPool.nextId();
        this._cache.set(sessionId,  new Map());
        if (Array.isArray(items)) {
            return items.map(item => this._cacheAndConvertItem(sessionId, item));
        }
        else {
            return [this._cacheAndConvertItem(sessionId, items)];
        }
    }
    async provideSupertypes(sessionId, itemId, token) {
        const item = this._itemFromCache(sessionId, itemId);
        if (!item) {
            throw new Error('missing type hierarchy item');
        }
        const supertypes = await this._provider.provideTypeHierarchySupertypes(item, token);
        if (!supertypes) {
            return undefined;
        }
        return supertypes.map(supertype => {
            return this._cacheAndConvertItem(sessionId, supertype);
        });
    }
    async provideSubtypes(sessionId, itemId, token) {
        const item = this._itemFromCache(sessionId, itemId);
        if (!item) {
            throw new Error('missing type hierarchy item');
        }
        const subtypes = await this._provider.provideTypeHierarchySubtypes(item, token);
        if (!subtypes) {
            return undefined;
        }
        return subtypes.map(subtype => {
            return this._cacheAndConvertItem(sessionId, subtype);
        });
    }
    releaseSession(sessionId) {
        this._cache.delete(sessionId);
    }
    _cacheAndConvertItem(sessionId, item) {
        const map = this._cache.get(sessionId);
        const dto = TypeHierarchyItem$1.from(item, sessionId, map.size.toString(36));
        map.set(dto._itemId, item);
        return dto;
    }
    _itemFromCache(sessionId, itemId) {
        const map = this._cache.get(sessionId);
        return map?.get(itemId);
    }
}
class ExtHostLanguageFeatures {
    static _extLabel(ext) {
        return ext.displayName || ext.name;
    }
    static _serializeRegExp(regExp) {
        return {
            pattern: regExp.source,
            flags: regExpFlags(regExp),
        };
    }
    static _serializeIndentationRule(indentationRule) {
        return {
            decreaseIndentPattern: ExtHostLanguageFeatures._serializeRegExp(indentationRule.decreaseIndentPattern),
            increaseIndentPattern: ExtHostLanguageFeatures._serializeRegExp(indentationRule.increaseIndentPattern),
            indentNextLinePattern: indentationRule.indentNextLinePattern ? ExtHostLanguageFeatures._serializeRegExp(indentationRule.indentNextLinePattern) : undefined,
            unIndentedLinePattern: indentationRule.unIndentedLinePattern ? ExtHostLanguageFeatures._serializeRegExp(indentationRule.unIndentedLinePattern) : undefined,
        };
    }
    static _serializeOnEnterRule(onEnterRule) {
        return {
            beforeText: ExtHostLanguageFeatures._serializeRegExp(onEnterRule.beforeText),
            afterText: onEnterRule.afterText ? ExtHostLanguageFeatures._serializeRegExp(onEnterRule.afterText) : undefined,
            previousLineText: onEnterRule.previousLineText ? ExtHostLanguageFeatures._serializeRegExp(onEnterRule.previousLineText) : undefined,
            action: onEnterRule.action
        };
    }
    static _serializeOnEnterRules(onEnterRules) {
        return onEnterRules.map(ExtHostLanguageFeatures._serializeOnEnterRule);
    }
}
ExtHostLanguageFeatures._handlePool = 0;
var MainThreadLanguageFeatures_1;
let MainThreadLanguageFeatures = MainThreadLanguageFeatures_1 = class MainThreadLanguageFeatures extends Disposable$2 {
    static _reviveLocationDto(data) {
        if (!data) {
            return data;
        }
        else if (Array.isArray(data)) {
            data.forEach(l => MainThreadLanguageFeatures_1._reviveLocationDto(l));
            return data;
        }
        else {
            data.uri = URI.revive(data.uri);
            return data;
        }
    }
    static _reviveLocationLinkDto(data) {
        if (!data) {
            return data;
        }
        else if (Array.isArray(data)) {
            data.forEach(l => MainThreadLanguageFeatures_1._reviveLocationLinkDto(l));
            return data;
        }
        else {
            data.uri = URI.revive(data.uri);
            return data;
        }
    }
    static _reviveWorkspaceSymbolDto(data) {
        if (!data) {
            return data;
        }
        else if (Array.isArray(data)) {
            data.forEach(MainThreadLanguageFeatures_1._reviveWorkspaceSymbolDto);
            return data;
        }
        else {
            data.location = MainThreadLanguageFeatures_1._reviveLocationDto(data.location);
            return data;
        }
    }
    static _reviveCodeActionDto(data) {
        if (data) {
            data.forEach(code => reviveWorkspaceEditDto(code.edit));
        }
        return data;
    }
    static _reviveLinkDTO(data) {
        if (data.url && typeof data.url !== 'string') {
            data.url = URI.revive(data.url);
        }
        return data;
    }
    static _reviveCallHierarchyItemDto(data) {
        if (data) {
            data.uri = URI.revive(data.uri);
        }
        return data;
    }
    static _reviveTypeHierarchyItemDto(data) {
        if (data) {
            data.uri = URI.revive(data.uri);
        }
        return data;
    }
    static _inflateSuggestDto(defaultRange, data) {
        const label = data["a" ];
        return {
            label,
            kind: data["b" ] ?? 9 ,
            tags: data["n" ],
            detail: data["c" ],
            documentation: data["d" ],
            sortText: data["e" ],
            filterText: data["f" ],
            preselect: data["g" ],
            insertText: data["h" ] ?? (typeof label === 'string' ? label : label.label),
            range: data["j" ] ?? defaultRange,
            insertTextRules: data["i" ],
            commitCharacters: data["k" ],
            additionalTextEdits: data["l" ],
            command: data["m" ],
            _id: data.x,
        };
    }
    static _reviveRegExp(regExp) {
        return (
             new RegExp(regExp.pattern, regExp.flags)
        );
    }
    static _reviveIndentationRule(indentationRule) {
        return {
            decreaseIndentPattern: MainThreadLanguageFeatures_1._reviveRegExp(indentationRule.decreaseIndentPattern),
            increaseIndentPattern: MainThreadLanguageFeatures_1._reviveRegExp(indentationRule.increaseIndentPattern),
            indentNextLinePattern: indentationRule.indentNextLinePattern ? MainThreadLanguageFeatures_1._reviveRegExp(indentationRule.indentNextLinePattern) : undefined,
            unIndentedLinePattern: indentationRule.unIndentedLinePattern ? MainThreadLanguageFeatures_1._reviveRegExp(indentationRule.unIndentedLinePattern) : undefined,
        };
    }
    static _reviveOnEnterRule(onEnterRule) {
        return {
            beforeText: MainThreadLanguageFeatures_1._reviveRegExp(onEnterRule.beforeText),
            afterText: onEnterRule.afterText ? MainThreadLanguageFeatures_1._reviveRegExp(onEnterRule.afterText) : undefined,
            previousLineText: onEnterRule.previousLineText ? MainThreadLanguageFeatures_1._reviveRegExp(onEnterRule.previousLineText) : undefined,
            action: onEnterRule.action
        };
    }
    static _reviveOnEnterRules(onEnterRules) {
        return onEnterRules.map(MainThreadLanguageFeatures_1._reviveOnEnterRule);
    }
};
MainThreadLanguageFeatures = MainThreadLanguageFeatures_1 = MainThreadLanguageFeatures;
var _ExtHostCommands_proxy, _ExtHostCommands_telemetry;
let ExtHostCommands = class ExtHostCommands {
    constructor(extHostRpc, logService) {
        _ExtHostCommands_proxy.set(this, void 0);
        this._commands =  new Map();
        this._apiCommands =  new Map();
        _ExtHostCommands_telemetry.set(this, void 0);
        __classPrivateFieldSet(this, _ExtHostCommands_proxy, extHostRpc.getProxy(MainContext.MainThreadCommands), "f");
        this._logService = logService;
        __classPrivateFieldSet(this, _ExtHostCommands_telemetry, extHostRpc.getProxy(MainContext.MainThreadTelemetry), "f");
        this.converter =  new CommandsConverter(this, id => {
            const candidate = this._apiCommands.get(id);
            return candidate?.result === ApiCommandResult.Void
                ? candidate : undefined;
        }, logService);
        this._argumentProcessors = [
            {
                processArgument(a) {
                    return revive(a);
                }
            },
            {
                processArgument(arg) {
                    return cloneAndChange(arg, function (obj) {
                        if (Range$2.isIRange(obj)) {
                            return Range$1.to(obj);
                        }
                        if (Position$1.isIPosition(obj)) {
                            return Position$2.to(obj);
                        }
                        if (Range$2.isIRange(obj.range) && URI.isUri(obj.uri)) {
                            return location.to(obj);
                        }
                        if (obj instanceof VSBuffer) {
                            return obj.buffer.buffer;
                        }
                        if (!Array.isArray(obj)) {
                            return obj;
                        }
                    });
                }
            }
        ];
    }
    registerArgumentProcessor(processor) {
        this._argumentProcessors.push(processor);
    }
    registerApiCommand(apiCommand) {
        const registration = this.registerCommand(false, apiCommand.id, async (...apiArgs) => {
            const internalArgs = apiCommand.args.map((arg, i) => {
                if (!arg.validate(apiArgs[i])) {
                    throw new Error(`Invalid argument '${arg.name}' when running '${apiCommand.id}', received: ${apiArgs[i]}`);
                }
                return arg.convert(apiArgs[i]);
            });
            const internalResult = await this.executeCommand(apiCommand.internalId, ...internalArgs);
            return apiCommand.result.convert(internalResult, apiArgs, this.converter);
        }, undefined, {
            description: apiCommand.description,
            args: apiCommand.args,
            returns: apiCommand.result.description
        });
        this._apiCommands.set(apiCommand.id, apiCommand);
        return new Disposable$1(() => {
            registration.dispose();
            this._apiCommands.delete(apiCommand.id);
        });
    }
    registerCommand(global, id, callback, thisArg, description, extension) {
        this._logService.trace('ExtHostCommands#registerCommand', id);
        if (!id.trim().length) {
            throw new Error('invalid id');
        }
        if (this._commands.has(id)) {
            throw new Error(`command '${id}' already exists`);
        }
        this._commands.set(id, { callback, thisArg, description, extension });
        if (global) {
            __classPrivateFieldGet(this, _ExtHostCommands_proxy, "f").$registerCommand(id);
        }
        return new Disposable$1(() => {
            if (this._commands.delete(id)) {
                if (global) {
                    __classPrivateFieldGet(this, _ExtHostCommands_proxy, "f").$unregisterCommand(id);
                }
            }
        });
    }
    executeCommand(id, ...args) {
        this._logService.trace('ExtHostCommands#executeCommand', id);
        return this._doExecuteCommand(id, args, true);
    }
    async _doExecuteCommand(id, args, retry) {
        if (this._commands.has(id)) {
            return this._executeContributedCommand(id, args, false);
        }
        else {
            let hasBuffers = false;
            const toArgs = cloneAndChange(args, function (value) {
                if (value instanceof Position$3) {
                    return Position$2.from(value);
                }
                else if (value instanceof Range$3) {
                    return Range$1.from(value);
                }
                else if (value instanceof Location$1) {
                    return location.from(value);
                }
                else if (NotebookRange$2.isNotebookRange(value)) {
                    return NotebookRange$1.from(value);
                }
                else if (value instanceof ArrayBuffer) {
                    hasBuffers = true;
                    return VSBuffer.wrap( new Uint8Array(value));
                }
                else if (value instanceof Uint8Array) {
                    hasBuffers = true;
                    return VSBuffer.wrap(value);
                }
                else if (value instanceof VSBuffer) {
                    hasBuffers = true;
                    return value;
                }
                if (!Array.isArray(value)) {
                    return value;
                }
            });
            try {
                const result = await __classPrivateFieldGet(this, _ExtHostCommands_proxy, "f").$executeCommand(id, hasBuffers ?  new SerializableObjectWithBuffers(toArgs) : toArgs, retry);
                return revive(result);
            }
            catch (e) {
                if (e instanceof Error && e.message === '$executeCommand:retry') {
                    return this._doExecuteCommand(id, args, false);
                }
                else {
                    throw e;
                }
            }
        }
    }
    async _executeContributedCommand(id, args, annotateError) {
        const command = this._commands.get(id);
        if (!command) {
            throw new Error('Unknown command');
        }
        this._reportTelemetry(command, id);
        let { callback, thisArg, description } = command;
        if (description) {
            for (let i = 0; i < description.args.length; i++) {
                try {
                    validateConstraint(args[i], description.args[i].constraint);
                }
                catch (err) {
                    throw new Error(`Running the contributed command: '${id}' failed. Illegal argument '${description.args[i].name}' - ${description.args[i].description}`);
                }
            }
        }
        try {
            return await callback.apply(thisArg, args);
        }
        catch (err) {
            if (id === this.converter.delegatingCommandId) {
                const actual = this.converter.getActualCommand(...args);
                if (actual) {
                    id = actual.command;
                }
            }
            this._logService.error(err, id, command.extension?.identifier);
            if (!annotateError) {
                throw err;
            }
            throw new (class CommandError extends Error {
                constructor() {
                    super(toErrorMessage(err));
                    this.id = id;
                    this.source = command.extension?.displayName ?? command.extension?.name;
                }
            });
        }
    }
    _reportTelemetry(command, id) {
        if (!command.extension || command.extension.isBuiltin) {
            return;
        }
        __classPrivateFieldGet(this, _ExtHostCommands_telemetry, "f").$publicLog2('Extension:ActionExecuted', {
            extensionId: command.extension.identifier.value,
            id: id,
        });
    }
    $executeContributedCommand(id, ...args) {
        this._logService.trace('ExtHostCommands#$executeContributedCommand', id);
        if (!this._commands.has(id)) {
            return Promise.reject( new Error(`Contributed command '${id}' does not exist.`));
        }
        else {
            args = args.map(arg => this._argumentProcessors.reduce((r, p) => p.processArgument(r), arg));
            return this._executeContributedCommand(id, args, true);
        }
    }
    getCommands(filterUnderscoreCommands = false) {
        this._logService.trace('ExtHostCommands#getCommands', filterUnderscoreCommands);
        return __classPrivateFieldGet(this, _ExtHostCommands_proxy, "f").$getCommands().then(result => {
            if (filterUnderscoreCommands) {
                result = result.filter(command => command[0] !== '_');
            }
            return result;
        });
    }
    $getContributedCommandHandlerDescriptions() {
        const result = Object.create(null);
        for (let [id, command] of this._commands) {
            let { description } = command;
            if (description) {
                result[id] = description;
            }
        }
        return Promise.resolve(result);
    }
};
_ExtHostCommands_proxy =  new WeakMap(), _ExtHostCommands_telemetry =  new WeakMap();
ExtHostCommands = ExtHostCommands;
class CommandsConverter {
    constructor(_commands, _lookupApiCommand, _logService) {
        this._commands = _commands;
        this._lookupApiCommand = _lookupApiCommand;
        this._logService = _logService;
        this.delegatingCommandId = `_vscode_delegate_cmd_${Date.now().toString(36)}`;
        this._cache =  new Map();
        this._cachIdPool = 0;
        this._commands.registerCommand(true, this.delegatingCommandId, this._executeConvertedCommand, this);
    }
    toInternal(command, disposables) {
        if (!command) {
            return undefined;
        }
        const result = {
            $ident: undefined,
            id: command.command,
            title: command.title,
            tooltip: command.tooltip
        };
        if (!command.command) {
            return result;
        }
        const apiCommand = this._lookupApiCommand(command.command);
        if (apiCommand) {
            result.id = apiCommand.internalId;
            result.arguments = apiCommand.args.map((arg, i) => arg.convert(command.arguments && command.arguments[i]));
        }
        else if (isNonEmptyArray(command.arguments)) {
            const id = ++this._cachIdPool;
            this._cache.set(id, command);
            disposables.add(toDisposable(() => {
                this._cache.delete(id);
                this._logService.trace('CommandsConverter#DISPOSE', id);
            }));
            result.$ident = id;
            result.id = this.delegatingCommandId;
            result.arguments = [id];
            this._logService.trace('CommandsConverter#CREATE', command.command, id);
        }
        return result;
    }
    fromInternal(command) {
        if (typeof command.$ident === 'number') {
            return this._cache.get(command.$ident);
        }
        else {
            return {
                command: command.id,
                title: command.title,
                arguments: command.arguments
            };
        }
    }
    getActualCommand(...args) {
        return this._cache.get(args[0]);
    }
    _executeConvertedCommand(...args) {
        const actualCmd = this.getActualCommand(...args);
        this._logService.trace('CommandsConverter#EXECUTE', args[0], actualCmd ? actualCmd.command : 'MISSING');
        if (!actualCmd) {
            return Promise.reject('actual command NOT FOUND');
        }
        return this._commands.executeCommand(actualCmd.command, ...(actualCmd.arguments || []));
    }
}
class ApiCommandResult {
    constructor(description, convert) {
        this.description = description;
        this.convert = convert;
    }
}
ApiCommandResult.Void =  new ApiCommandResult('no result', v => v);
let MainThreadCommands = class MainThreadCommands {
    constructor(extHostContext, _commandService, _extensionService) {
        this._commandService = _commandService;
        this._extensionService = _extensionService;
        this._commandRegistrations =  new Map();
        this._proxy = extHostContext.getProxy(ExtHostContext.ExtHostCommands);
        this._generateCommandsDocumentationRegistration =  CommandsRegistry.registerCommand(
            '_generateCommandsDocumentation',
            () => this._generateCommandsDocumentation()
        );
    }
    dispose() {
        dispose(this._commandRegistrations.values());
        this._commandRegistrations.clear();
        this._generateCommandsDocumentationRegistration.dispose();
    }
    async _generateCommandsDocumentation() {
        const result = await this._proxy.$getContributedCommandHandlerDescriptions();
        const commands = CommandsRegistry.getCommands();
        for (const [id, command] of commands) {
            if (command.description) {
                result[id] = command.description;
            }
        }
        const all = [];
        for (let id in result) {
            all.push('`' + id + '` - ' + _generateMarkdown(result[id]));
        }
        console.log(all.join('\n'));
    }
    $registerCommand(id) {
        this._commandRegistrations.set(id,  CommandsRegistry.registerCommand(id, (accessor, ...args) => {
            return this._proxy.$executeContributedCommand(id, ...args).then(result => {
                return revive(result);
            });
        }));
    }
    $unregisterCommand(id) {
        const command = this._commandRegistrations.get(id);
        if (command) {
            command.dispose();
            this._commandRegistrations.delete(id);
        }
    }
    async $executeCommand(id, args, retry) {
        if (args instanceof SerializableObjectWithBuffers) {
            args = args.value;
        }
        for (let i = 0; i < args.length; i++) {
            args[i] = revive(args[i]);
        }
        if (retry && args.length > 0 && !CommandsRegistry.getCommand(id)) {
            await this._extensionService.activateByEvent(`onCommand:${id}`);
            throw new Error('$executeCommand:retry');
        }
        return this._commandService.executeCommand(id, ...args);
    }
    $getCommands() {
        return Promise.resolve([...CommandsRegistry.getCommands().keys()]);
    }
};
MainThreadCommands = MainThreadCommands;
function _generateMarkdown(description) {
    if (typeof description === 'string') {
        return description;
    }
    else {
        const parts = [description.description];
        parts.push('\n\n');
        if (description.args) {
            for (let arg of description.args) {
                parts.push(`* _${arg.name}_ - ${arg.description || ''}\n`);
            }
        }
        if (description.returns) {
            parts.push(`* _(returns)_ - ${description.returns}`);
        }
        parts.push('\n\n');
        return parts.join('');
    }
}
class ExtHostFileSystemInfo {
    constructor() {
        this._systemSchemes =  new Set(Object.keys(Schemas));
        this._providerInfo =  new Map();
        this.extUri =  new ExtUri(uri => {
            const capabilities = this._providerInfo.get(uri.scheme);
            if (capabilities === undefined) {
                return false;
            }
            if (capabilities & 1024 ) {
                return false;
            }
            return true;
        });
    }
    $acceptProviderInfos(uri, capabilities) {
        if (capabilities === null) {
            this._providerInfo.delete(uri.scheme);
        }
        else {
            this._providerInfo.set(uri.scheme, capabilities);
        }
    }
    isFreeScheme(scheme) {
        return !this._providerInfo.has(scheme) && !this._systemSchemes.has(scheme);
    }
    getCapabilities(scheme) {
        return this._providerInfo.get(scheme);
    }
}
var _DiagnosticCollection_proxy, _DiagnosticCollection_onDidChangeDiagnostics, _DiagnosticCollection_data;
class DiagnosticCollection {
    constructor(_name, _owner, _maxDiagnosticsPerFile, extUri, proxy, onDidChangeDiagnostics) {
        this._name = _name;
        this._owner = _owner;
        this._maxDiagnosticsPerFile = _maxDiagnosticsPerFile;
        _DiagnosticCollection_proxy.set(this, void 0);
        _DiagnosticCollection_onDidChangeDiagnostics.set(this, void 0);
        _DiagnosticCollection_data.set(this, void 0);
        this._isDisposed = false;
        __classPrivateFieldSet(this, _DiagnosticCollection_data,  new ResourceMap$1(uri => extUri.getComparisonKey(uri)), "f");
        __classPrivateFieldSet(this, _DiagnosticCollection_proxy, proxy, "f");
        __classPrivateFieldSet(this, _DiagnosticCollection_onDidChangeDiagnostics, onDidChangeDiagnostics, "f");
    }
    dispose() {
        if (!this._isDisposed) {
            __classPrivateFieldGet(this, _DiagnosticCollection_onDidChangeDiagnostics, "f").fire([...__classPrivateFieldGet(this, _DiagnosticCollection_data, "f").keys()]);
            if (__classPrivateFieldGet(this, _DiagnosticCollection_proxy, "f")) {
                __classPrivateFieldGet(this, _DiagnosticCollection_proxy, "f").$clear(this._owner);
            }
            __classPrivateFieldGet(this, _DiagnosticCollection_data, "f").clear();
            this._isDisposed = true;
        }
    }
    get name() {
        this._checkDisposed();
        return this._name;
    }
    set(first, diagnostics) {
        if (!first) {
            this.clear();
            return;
        }
        this._checkDisposed();
        let toSync = [];
        if (URI.isUri(first)) {
            if (!diagnostics) {
                this.delete(first);
                return;
            }
            __classPrivateFieldGet(this, _DiagnosticCollection_data, "f").set(first, diagnostics.slice());
            toSync = [first];
        }
        else if (Array.isArray(first)) {
            toSync = [];
            let lastUri;
            first = [...first].sort(DiagnosticCollection._compareIndexedTuplesByUri);
            for (const tuple of first) {
                const [uri, diagnostics] = tuple;
                if (!lastUri || uri.toString() !== lastUri.toString()) {
                    if (lastUri && __classPrivateFieldGet(this, _DiagnosticCollection_data, "f").get(lastUri).length === 0) {
                        __classPrivateFieldGet(this, _DiagnosticCollection_data, "f").delete(lastUri);
                    }
                    lastUri = uri;
                    toSync.push(uri);
                    __classPrivateFieldGet(this, _DiagnosticCollection_data, "f").set(uri, []);
                }
                if (!diagnostics) {
                    const currentDiagnostics = __classPrivateFieldGet(this, _DiagnosticCollection_data, "f").get(uri);
                    if (currentDiagnostics) {
                        currentDiagnostics.length = 0;
                    }
                }
                else {
                    const currentDiagnostics = __classPrivateFieldGet(this, _DiagnosticCollection_data, "f").get(uri);
                    if (currentDiagnostics) {
                        currentDiagnostics.push(...diagnostics);
                    }
                }
            }
        }
        __classPrivateFieldGet(this, _DiagnosticCollection_onDidChangeDiagnostics, "f").fire(toSync);
        if (!__classPrivateFieldGet(this, _DiagnosticCollection_proxy, "f")) {
            return;
        }
        const entries = [];
        for (let uri of toSync) {
            let marker = [];
            const diagnostics = __classPrivateFieldGet(this, _DiagnosticCollection_data, "f").get(uri);
            if (diagnostics) {
                if (diagnostics.length > this._maxDiagnosticsPerFile) {
                    marker = [];
                    const order = [DiagnosticSeverity$2.Error, DiagnosticSeverity$2.Warning, DiagnosticSeverity$2.Information, DiagnosticSeverity$2.Hint];
                    orderLoop: for (let i = 0; i < 4; i++) {
                        for (let diagnostic of diagnostics) {
                            if (diagnostic.severity === order[i]) {
                                const len = marker.push(Diagnostic$1.from(diagnostic));
                                if (len === this._maxDiagnosticsPerFile) {
                                    break orderLoop;
                                }
                            }
                        }
                    }
                    marker.push({
                        severity: MarkerSeverity.Info,
                        message:  localize(
                            { key: 'limitHit', comment: ['amount of errors/warning skipped due to limits'] },
                            "Not showing {0} further errors and warnings.",
                            diagnostics.length - this._maxDiagnosticsPerFile
                        ),
                        startLineNumber: marker[marker.length - 1].startLineNumber,
                        startColumn: marker[marker.length - 1].startColumn,
                        endLineNumber: marker[marker.length - 1].endLineNumber,
                        endColumn: marker[marker.length - 1].endColumn
                    });
                }
                else {
                    marker = diagnostics.map(diag => Diagnostic$1.from(diag));
                }
            }
            entries.push([uri, marker]);
        }
        __classPrivateFieldGet(this, _DiagnosticCollection_proxy, "f").$changeMany(this._owner, entries);
    }
    delete(uri) {
        this._checkDisposed();
        __classPrivateFieldGet(this, _DiagnosticCollection_onDidChangeDiagnostics, "f").fire([uri]);
        __classPrivateFieldGet(this, _DiagnosticCollection_data, "f").delete(uri);
        if (__classPrivateFieldGet(this, _DiagnosticCollection_proxy, "f")) {
            __classPrivateFieldGet(this, _DiagnosticCollection_proxy, "f").$changeMany(this._owner, [[uri, undefined]]);
        }
    }
    clear() {
        this._checkDisposed();
        __classPrivateFieldGet(this, _DiagnosticCollection_onDidChangeDiagnostics, "f").fire([...__classPrivateFieldGet(this, _DiagnosticCollection_data, "f").keys()]);
        __classPrivateFieldGet(this, _DiagnosticCollection_data, "f").clear();
        if (__classPrivateFieldGet(this, _DiagnosticCollection_proxy, "f")) {
            __classPrivateFieldGet(this, _DiagnosticCollection_proxy, "f").$clear(this._owner);
        }
    }
    forEach(callback, thisArg) {
        this._checkDisposed();
        for (let uri of __classPrivateFieldGet(this, _DiagnosticCollection_data, "f").keys()) {
            callback.apply(thisArg, [uri, this.get(uri), this]);
        }
    }
    get(uri) {
        this._checkDisposed();
        const result = __classPrivateFieldGet(this, _DiagnosticCollection_data, "f").get(uri);
        if (Array.isArray(result)) {
            return Object.freeze(result.slice(0));
        }
        return [];
    }
    has(uri) {
        this._checkDisposed();
        return Array.isArray(__classPrivateFieldGet(this, _DiagnosticCollection_data, "f").get(uri));
    }
    _checkDisposed() {
        if (this._isDisposed) {
            throw new Error('illegal state - object is disposed');
        }
    }
    static _compareIndexedTuplesByUri(a, b) {
        if (a[0].toString() < b[0].toString()) {
            return -1;
        }
        else if (a[0].toString() > b[0].toString()) {
            return 1;
        }
        else {
            return 0;
        }
    }
}
_DiagnosticCollection_proxy =  new WeakMap(), _DiagnosticCollection_onDidChangeDiagnostics =  new WeakMap(), _DiagnosticCollection_data =  new WeakMap();
let ExtHostDiagnostics = class ExtHostDiagnostics {
    constructor(mainContext, _logService, _fileSystemInfoService) {
        this._logService = _logService;
        this._fileSystemInfoService = _fileSystemInfoService;
        this._collections =  new Map();
        this._onDidChangeDiagnostics =  new DebounceEmitter({ merge: all => all.flat(), delay: 50 });
        this.onDidChangeDiagnostics = Event.map(this._onDidChangeDiagnostics.event, ExtHostDiagnostics._mapper);
        this._proxy = mainContext.getProxy(MainContext.MainThreadDiagnostics);
    }
    static _mapper(last) {
        const map =  new ResourceMap$1();
        for (const uri of last) {
            map.set(uri, uri);
        }
        return { uris: Object.freeze(Array.from(map.values())) };
    }
    createDiagnosticCollection(extensionId, name) {
        const { _collections, _proxy, _onDidChangeDiagnostics, _logService, _fileSystemInfoService } = this;
        const loggingProxy = new (class {
            $changeMany(owner, entries) {
                _proxy.$changeMany(owner, entries);
                _logService.trace('[DiagnosticCollection] change many (extension, owner, uris)', extensionId.value, owner, entries.length === 0 ? 'CLEARING' : entries);
            }
            $clear(owner) {
                _proxy.$clear(owner);
                _logService.trace('[DiagnosticCollection] remove all (extension, owner)', extensionId.value, owner);
            }
            dispose() {
                _proxy.dispose();
            }
        });
        let owner;
        if (!name) {
            name = '_generated_diagnostic_collection_name_#' + ExtHostDiagnostics._idPool++;
            owner = name;
        }
        else if (!_collections.has(name)) {
            owner = name;
        }
        else {
            this._logService.warn(`DiagnosticCollection with name '${name}' does already exist.`);
            do {
                owner = name + ExtHostDiagnostics._idPool++;
            } while (_collections.has(owner));
        }
        const result = new (class extends DiagnosticCollection {
            constructor() {
                super(name, owner, ExtHostDiagnostics._maxDiagnosticsPerFile, _fileSystemInfoService.extUri, loggingProxy, _onDidChangeDiagnostics);
                _collections.set(owner, this);
            }
            dispose() {
                super.dispose();
                _collections.delete(owner);
            }
        });
        return result;
    }
    getDiagnostics(resource) {
        if (resource) {
            return this._getDiagnostics(resource);
        }
        else {
            const index =  new Map();
            const res = [];
            for (const collection of this._collections.values()) {
                collection.forEach((uri, diagnostics) => {
                    let idx = index.get(uri.toString());
                    if (typeof idx === 'undefined') {
                        idx = res.length;
                        index.set(uri.toString(), idx);
                        res.push([uri, []]);
                    }
                    res[idx][1] = res[idx][1].concat(...diagnostics);
                });
            }
            return res;
        }
    }
    _getDiagnostics(resource) {
        let res = [];
        for (let collection of this._collections.values()) {
            if (collection.has(resource)) {
                res = res.concat(collection.get(resource));
            }
        }
        return res;
    }
    $acceptMarkersChange(data) {
        if (!this._mirrorCollection) {
            const name = '_generated_mirror';
            const collection =  new DiagnosticCollection(
                name,
                name,
                ExtHostDiagnostics._maxDiagnosticsPerFile,
                this._fileSystemInfoService.extUri,
                undefined,
                this._onDidChangeDiagnostics
            );
            this._collections.set(name, collection);
            this._mirrorCollection = collection;
        }
        for (const [uri, markers] of data) {
            this._mirrorCollection.set(URI.revive(uri), markers.map(Diagnostic$1.to));
        }
    }
};
ExtHostDiagnostics._idPool = 0;
ExtHostDiagnostics._maxDiagnosticsPerFile = 1000;
ExtHostDiagnostics = ExtHostDiagnostics;
function _transformIncomingURIs(obj, transformer, revive, depth) {
    if (!obj || depth > 200) {
        return null;
    }
    if (typeof obj === 'object') {
        if (obj.$mid === 1 ) {
            return revive ? URI.revive(transformer.transformIncoming(obj)) : transformer.transformIncoming(obj);
        }
        for (let key in obj) {
            if (Object.hasOwnProperty.call(obj, key)) {
                const r = _transformIncomingURIs(obj[key], transformer, revive, depth + 1);
                if (r !== null) {
                    obj[key] = r;
                }
            }
        }
    }
    return null;
}
function transformIncomingURIs(obj, transformer) {
    const result = _transformIncomingURIs(obj, transformer, false, 0);
    if (result === null) {
        return obj;
    }
    return result;
}
class LazyPromise {
    constructor() {
        this._actual = null;
        this._actualOk = null;
        this._actualErr = null;
        this._hasValue = false;
        this._value = null;
        this._hasErr = false;
        this._err = null;
    }
    get [Symbol.toStringTag]() {
        return this.toString();
    }
    _ensureActual() {
        if (!this._actual) {
            this._actual =  new Promise((c, e) => {
                this._actualOk = c;
                this._actualErr = e;
                if (this._hasValue) {
                    this._actualOk(this._value);
                }
                if (this._hasErr) {
                    this._actualErr(this._err);
                }
            });
        }
        return this._actual;
    }
    resolveOk(value) {
        if (this._hasValue || this._hasErr) {
            return;
        }
        this._hasValue = true;
        this._value = value;
        if (this._actual) {
            this._actualOk(value);
        }
    }
    resolveErr(err) {
        if (this._hasValue || this._hasErr) {
            return;
        }
        this._hasErr = true;
        this._err = err;
        if (this._actual) {
            this._actualErr(err);
        }
        else {
            onUnexpectedError(err);
        }
    }
    then(success, error) {
        return this._ensureActual().then(success, error);
    }
    catch(error) {
        return this._ensureActual().then(undefined, error);
    }
    finally(callback) {
        return this._ensureActual().finally(callback);
    }
}
var _a;
function safeStringify(obj, replacer) {
    try {
        return JSON.stringify(obj, replacer);
    }
    catch (err) {
        return 'null';
    }
}
const refSymbolName = '$$ref$$';
const undefinedRef = { [refSymbolName]: -1 };
function stringifyJsonWithBufferRefs(obj, replacer = null, useSafeStringify = false) {
    const foundBuffers = [];
    const serialized = (useSafeStringify ? safeStringify : JSON.stringify)(obj, (key, value) => {
        if (typeof value === 'undefined') {
            return undefinedRef;
        }
        else if (typeof value === 'object') {
            if (value instanceof VSBuffer) {
                const bufferIndex = foundBuffers.push(value) - 1;
                return { [refSymbolName]: bufferIndex };
            }
            if (replacer) {
                return replacer(key, value);
            }
        }
        return value;
    });
    return {
        jsonString: serialized,
        referencedBuffers: foundBuffers
    };
}
function parseJsonAndRestoreBufferRefs(jsonString, buffers, uriTransformer) {
    return JSON.parse(jsonString, (_key, value) => {
        if (value) {
            const ref = value[refSymbolName];
            if (typeof ref === 'number') {
                return buffers[ref];
            }
            if (uriTransformer && value.$mid === 1 ) {
                return uriTransformer.transformIncoming(value);
            }
        }
        return value;
    });
}
function stringify(obj, replacer) {
    return JSON.stringify(obj, replacer);
}
function createURIReplacer(transformer) {
    if (!transformer) {
        return null;
    }
    return (key, value) => {
        if (value && value.$mid === 1 ) {
            return transformer.transformOutgoing(value);
        }
        return value;
    };
}
const noop$1 = () => { };
const _RPCProtocolSymbol = Symbol.for('rpcProtocol');
const _RPCProxySymbol = Symbol.for('rpcProxy');
class RPCProtocol extends Disposable$2 {
    constructor(protocol, logger = null, transformer = null) {
        super();
        this[_a] = true;
        this._onDidChangeResponsiveState = this._register( new Emitter());
        this.onDidChangeResponsiveState = this._onDidChangeResponsiveState.event;
        this._protocol = protocol;
        this._logger = logger;
        this._uriTransformer = transformer;
        this._uriReplacer = createURIReplacer(this._uriTransformer);
        this._isDisposed = false;
        this._locals = [];
        this._proxies = [];
        for (let i = 0, len = ProxyIdentifier.count; i < len; i++) {
            this._locals[i] = null;
            this._proxies[i] = null;
        }
        this._lastMessageId = 0;
        this._cancelInvokedHandlers = Object.create(null);
        this._pendingRPCReplies = {};
        this._responsiveState = 0 ;
        this._unacknowledgedCount = 0;
        this._unresponsiveTime = 0;
        this._asyncCheckUresponsive = this._register( new RunOnceScheduler(() => this._checkUnresponsive(), 1000));
        this._protocol.onMessage((msg) => this._receiveOneMessage(msg));
    }
    dispose() {
        this._isDisposed = true;
        Object.keys(this._pendingRPCReplies).forEach((msgId) => {
            const pending = this._pendingRPCReplies[msgId];
            pending.resolveErr(canceled());
        });
    }
    drain() {
        if (typeof this._protocol.drain === 'function') {
            return this._protocol.drain();
        }
        return Promise.resolve();
    }
    _onWillSendRequest(req) {
        if (this._unacknowledgedCount === 0) {
            this._unresponsiveTime = Date.now() + RPCProtocol.UNRESPONSIVE_TIME;
        }
        this._unacknowledgedCount++;
        if (!this._asyncCheckUresponsive.isScheduled()) {
            this._asyncCheckUresponsive.schedule();
        }
    }
    _onDidReceiveAcknowledge(req) {
        this._unresponsiveTime = Date.now() + RPCProtocol.UNRESPONSIVE_TIME;
        this._unacknowledgedCount--;
        if (this._unacknowledgedCount === 0) {
            this._asyncCheckUresponsive.cancel();
        }
        this._setResponsiveState(0 );
    }
    _checkUnresponsive() {
        if (this._unacknowledgedCount === 0) {
            return;
        }
        if (Date.now() > this._unresponsiveTime) {
            this._setResponsiveState(1 );
        }
        else {
            this._asyncCheckUresponsive.schedule();
        }
    }
    _setResponsiveState(newResponsiveState) {
        if (this._responsiveState === newResponsiveState) {
            return;
        }
        this._responsiveState = newResponsiveState;
        this._onDidChangeResponsiveState.fire(this._responsiveState);
    }
    get responsiveState() {
        return this._responsiveState;
    }
    transformIncomingURIs(obj) {
        if (!this._uriTransformer) {
            return obj;
        }
        return transformIncomingURIs(obj, this._uriTransformer);
    }
    getProxy(identifier) {
        const { nid: rpcId, sid } = identifier;
        if (!this._proxies[rpcId]) {
            this._proxies[rpcId] = this._createProxy(rpcId, sid);
        }
        return this._proxies[rpcId];
    }
    _createProxy(rpcId, debugName) {
        let handler = {
            get: (target, name) => {
                if (typeof name === 'string' && !target[name] && name.charCodeAt(0) === 36 ) {
                    target[name] = (...myArgs) => {
                        return this._remoteCall(rpcId, name, myArgs);
                    };
                }
                if (name === _RPCProxySymbol) {
                    return debugName;
                }
                return target[name];
            }
        };
        return (
             new Proxy(Object.create(null), handler)
        );
    }
    set(identifier, value) {
        this._locals[identifier.nid] = value;
        return value;
    }
    assertRegistered(identifiers) {
        for (let i = 0, len = identifiers.length; i < len; i++) {
            const identifier = identifiers[i];
            if (!this._locals[identifier.nid]) {
                throw new Error(`Missing proxy instance ${identifier.sid}`);
            }
        }
    }
    _receiveOneMessage(rawmsg) {
        if (this._isDisposed) {
            return;
        }
        const msgLength = rawmsg.byteLength;
        const buff = MessageBuffer.read(rawmsg, 0);
        const messageType = buff.readUInt8();
        const req = buff.readUInt32();
        switch (messageType) {
            case 1 :
            case 2 : {
                let { rpcId, method, args } = MessageIO.deserializeRequestJSONArgs(buff);
                if (this._uriTransformer) {
                    args = transformIncomingURIs(args, this._uriTransformer);
                }
                this._receiveRequest(msgLength, req, rpcId, method, args, ((messageType === 2) ));
                break;
            }
            case 3 :
            case 4 : {
                let { rpcId, method, args } = MessageIO.deserializeRequestMixedArgs(buff);
                if (this._uriTransformer) {
                    args = transformIncomingURIs(args, this._uriTransformer);
                }
                this._receiveRequest(msgLength, req, rpcId, method, args, ((messageType === 4) ));
                break;
            }
            case 5 : {
                if (this._logger) {
                    this._logger.logIncoming(msgLength, req, 0 , `ack`);
                }
                this._onDidReceiveAcknowledge(req);
                break;
            }
            case 6 : {
                this._receiveCancel(msgLength, req);
                break;
            }
            case 7 : {
                this._receiveReply(msgLength, req, undefined);
                break;
            }
            case 9 : {
                let value = MessageIO.deserializeReplyOKJSON(buff);
                if (this._uriTransformer) {
                    value = transformIncomingURIs(value, this._uriTransformer);
                }
                this._receiveReply(msgLength, req, value);
                break;
            }
            case 10 : {
                const value = MessageIO.deserializeReplyOKJSONWithBuffers(buff, this._uriTransformer);
                this._receiveReply(msgLength, req, value);
                break;
            }
            case 8 : {
                let value = MessageIO.deserializeReplyOKVSBuffer(buff);
                this._receiveReply(msgLength, req, value);
                break;
            }
            case 11 : {
                let err = MessageIO.deserializeReplyErrError(buff);
                if (this._uriTransformer) {
                    err = transformIncomingURIs(err, this._uriTransformer);
                }
                this._receiveReplyErr(msgLength, req, err);
                break;
            }
            case 12 : {
                this._receiveReplyErr(msgLength, req, undefined);
                break;
            }
            default:
                console.error(`received unexpected message`);
                console.error(rawmsg);
        }
    }
    _receiveRequest(msgLength, req, rpcId, method, args, usesCancellationToken) {
        if (this._logger) {
            this._logger.logIncoming(msgLength, req, 1 , `receiveRequest ${getStringIdentifierForProxy(rpcId)}.${method}(`, args);
        }
        const callId = String(req);
        let promise;
        let cancel;
        if (usesCancellationToken) {
            const cancellationTokenSource =  new CancellationTokenSource$1();
            args.push(cancellationTokenSource.token);
            promise = this._invokeHandler(rpcId, method, args);
            cancel = () => cancellationTokenSource.cancel();
        }
        else {
            promise = this._invokeHandler(rpcId, method, args);
            cancel = noop$1;
        }
        this._cancelInvokedHandlers[callId] = cancel;
        const msg = MessageIO.serializeAcknowledged(req);
        if (this._logger) {
            this._logger.logOutgoing(msg.byteLength, req, 1 , `ack`);
        }
        this._protocol.send(msg);
        promise.then((r) => {
            delete this._cancelInvokedHandlers[callId];
            const msg = MessageIO.serializeReplyOK(req, r, this._uriReplacer);
            if (this._logger) {
                this._logger.logOutgoing(msg.byteLength, req, 1 , `reply:`, r);
            }
            this._protocol.send(msg);
        }, (err) => {
            delete this._cancelInvokedHandlers[callId];
            const msg = MessageIO.serializeReplyErr(req, err);
            if (this._logger) {
                this._logger.logOutgoing(msg.byteLength, req, 1 , `replyErr:`, err);
            }
            this._protocol.send(msg);
        });
    }
    _receiveCancel(msgLength, req) {
        if (this._logger) {
            this._logger.logIncoming(msgLength, req, 1 , `receiveCancel`);
        }
        const callId = String(req);
        if (this._cancelInvokedHandlers[callId]) {
            this._cancelInvokedHandlers[callId]();
        }
    }
    _receiveReply(msgLength, req, value) {
        if (this._logger) {
            this._logger.logIncoming(msgLength, req, 0 , `receiveReply:`, value);
        }
        const callId = String(req);
        if (!this._pendingRPCReplies.hasOwnProperty(callId)) {
            return;
        }
        const pendingReply = this._pendingRPCReplies[callId];
        delete this._pendingRPCReplies[callId];
        pendingReply.resolveOk(value);
    }
    _receiveReplyErr(msgLength, req, value) {
        if (this._logger) {
            this._logger.logIncoming(msgLength, req, 0 , `receiveReplyErr:`, value);
        }
        const callId = String(req);
        if (!this._pendingRPCReplies.hasOwnProperty(callId)) {
            return;
        }
        const pendingReply = this._pendingRPCReplies[callId];
        delete this._pendingRPCReplies[callId];
        let err = undefined;
        if (value) {
            if (value.$isError) {
                err =  new Error();
                err.name = value.name;
                err.message = value.message;
                err.stack = value.stack;
            }
            else {
                err = value;
            }
        }
        pendingReply.resolveErr(err);
    }
    _invokeHandler(rpcId, methodName, args) {
        try {
            return Promise.resolve(this._doInvokeHandler(rpcId, methodName, args));
        }
        catch (err) {
            return Promise.reject(err);
        }
    }
    _doInvokeHandler(rpcId, methodName, args) {
        const actor = this._locals[rpcId];
        if (!actor) {
            throw new Error('Unknown actor ' + getStringIdentifierForProxy(rpcId));
        }
        let method = actor[methodName];
        if (typeof method !== 'function') {
            throw new Error('Unknown method ' + methodName + ' on actor ' + getStringIdentifierForProxy(rpcId));
        }
        return method.apply(actor, args);
    }
    _remoteCall(rpcId, methodName, args) {
        if (this._isDisposed) {
            return Promise.reject(canceled());
        }
        let cancellationToken = null;
        if (args.length > 0 && CancellationToken.isCancellationToken(args[args.length - 1])) {
            cancellationToken = args.pop();
        }
        if (cancellationToken && cancellationToken.isCancellationRequested) {
            return Promise.reject(canceled());
        }
        const serializedRequestArguments = MessageIO.serializeRequestArguments(args, this._uriReplacer);
        const req = ++this._lastMessageId;
        const callId = String(req);
        const result =  new LazyPromise();
        if (cancellationToken) {
            cancellationToken.onCancellationRequested(() => {
                const msg = MessageIO.serializeCancel(req);
                if (this._logger) {
                    this._logger.logOutgoing(msg.byteLength, req, 0 , `cancel`);
                }
                this._protocol.send(MessageIO.serializeCancel(req));
            });
        }
        this._pendingRPCReplies[callId] = result;
        this._onWillSendRequest(req);
        const msg = MessageIO.serializeRequest(req, rpcId, methodName, serializedRequestArguments, !!cancellationToken);
        if (this._logger) {
            this._logger.logOutgoing(msg.byteLength, req, 0 , `request: ${getStringIdentifierForProxy(rpcId)}.${methodName}(`, args);
        }
        this._protocol.send(msg);
        return result;
    }
}
_a = _RPCProtocolSymbol;
RPCProtocol.UNRESPONSIVE_TIME = 3 * 1000;
 class MessageBuffer {
    constructor(buff, offset) {
        this._buff = buff;
        this._offset = offset;
    }
    static alloc(type, req, messageSize) {
        let result =  new MessageBuffer(VSBuffer.alloc(messageSize + 1  + 4 ), 0);
        result.writeUInt8(type);
        result.writeUInt32(req);
        return result;
    }
    static read(buff, offset) {
        return (
             new MessageBuffer(buff, offset)
        );
    }
    get buffer() {
        return this._buff;
    }
    static sizeUInt8() {
        return 1;
    }
    writeUInt8(n) {
        this._buff.writeUInt8(n, this._offset);
        this._offset += 1;
    }
    readUInt8() {
        const n = this._buff.readUInt8(this._offset);
        this._offset += 1;
        return n;
    }
    writeUInt32(n) {
        this._buff.writeUInt32BE(n, this._offset);
        this._offset += 4;
    }
    readUInt32() {
        const n = this._buff.readUInt32BE(this._offset);
        this._offset += 4;
        return n;
    }
    static sizeShortString(str) {
        return 1  + str.byteLength ;
    }
    writeShortString(str) {
        this._buff.writeUInt8(str.byteLength, this._offset);
        this._offset += 1;
        this._buff.set(str, this._offset);
        this._offset += str.byteLength;
    }
    readShortString() {
        const strByteLength = this._buff.readUInt8(this._offset);
        this._offset += 1;
        const strBuff = this._buff.slice(this._offset, this._offset + strByteLength);
        const str = strBuff.toString();
        this._offset += strByteLength;
        return str;
    }
    static sizeLongString(str) {
        return 4  + str.byteLength ;
    }
    writeLongString(str) {
        this._buff.writeUInt32BE(str.byteLength, this._offset);
        this._offset += 4;
        this._buff.set(str, this._offset);
        this._offset += str.byteLength;
    }
    readLongString() {
        const strByteLength = this._buff.readUInt32BE(this._offset);
        this._offset += 4;
        const strBuff = this._buff.slice(this._offset, this._offset + strByteLength);
        const str = strBuff.toString();
        this._offset += strByteLength;
        return str;
    }
    writeBuffer(buff) {
        this._buff.writeUInt32BE(buff.byteLength, this._offset);
        this._offset += 4;
        this._buff.set(buff, this._offset);
        this._offset += buff.byteLength;
    }
    static sizeVSBuffer(buff) {
        return 4  + buff.byteLength ;
    }
    writeVSBuffer(buff) {
        this._buff.writeUInt32BE(buff.byteLength, this._offset);
        this._offset += 4;
        this._buff.set(buff, this._offset);
        this._offset += buff.byteLength;
    }
    readVSBuffer() {
        const buffLength = this._buff.readUInt32BE(this._offset);
        this._offset += 4;
        const buff = this._buff.slice(this._offset, this._offset + buffLength);
        this._offset += buffLength;
        return buff;
    }
    static sizeMixedArray(arr) {
        let size = 0;
        size += 1;
        for (let i = 0, len = arr.length; i < len; i++) {
            const el = arr[i];
            size += 1;
            switch (el.type) {
                case 1 :
                    size += this.sizeLongString(el.value);
                    break;
                case 2 :
                    size += this.sizeVSBuffer(el.value);
                    break;
                case 3 :
                    size += this.sizeUInt32;
                    size += this.sizeLongString(el.value);
                    for (let i = 0; i < el.buffers.length; ++i) {
                        size += this.sizeVSBuffer(el.buffers[i]);
                    }
                    break;
            }
        }
        return size;
    }
    writeMixedArray(arr) {
        this._buff.writeUInt8(arr.length, this._offset);
        this._offset += 1;
        for (let i = 0, len = arr.length; i < len; i++) {
            const el = arr[i];
            switch (el.type) {
                case 1 :
                    this.writeUInt8(1 );
                    this.writeLongString(el.value);
                    break;
                case 2 :
                    this.writeUInt8(2 );
                    this.writeVSBuffer(el.value);
                    break;
                case 3 :
                    this.writeUInt8(3 );
                    this.writeUInt32(el.buffers.length);
                    this.writeLongString(el.value);
                    for (let i = 0; i < el.buffers.length; ++i) {
                        this.writeBuffer(el.buffers[i]);
                    }
                    break;
                case 4 :
                    this.writeUInt8(4 );
                    break;
            }
        }
    }
    readMixedArray() {
        const arrLen = this._buff.readUInt8(this._offset);
        this._offset += 1;
        let arr =  new Array(arrLen);
        for (let i = 0; i < arrLen; i++) {
            const argType = this.readUInt8();
            switch (argType) {
                case 1 :
                    arr[i] = this.readLongString();
                    break;
                case 2 :
                    arr[i] = this.readVSBuffer();
                    break;
                case 3 : {
                    const bufferCount = this.readUInt32();
                    const jsonString = this.readLongString();
                    const buffers = [];
                    for (let i = 0; i < bufferCount; ++i) {
                        buffers.push(this.readVSBuffer());
                    }
                    arr[i] =  new SerializableObjectWithBuffers(parseJsonAndRestoreBufferRefs(jsonString, buffers, null));
                    break;
                }
                case 4 :
                    arr[i] = undefined;
                    break;
            }
        }
        return arr;
    }
}
MessageBuffer.sizeUInt32 = 4;
 class MessageIO {
    static _useMixedArgSerialization(arr) {
        for (let i = 0, len = arr.length; i < len; i++) {
            if (arr[i] instanceof VSBuffer) {
                return true;
            }
            if (arr[i] instanceof SerializableObjectWithBuffers) {
                return true;
            }
            if (typeof arr[i] === 'undefined') {
                return true;
            }
        }
        return false;
    }
    static serializeRequestArguments(args, replacer) {
        if (this._useMixedArgSerialization(args)) {
            const massagedArgs = [];
            for (let i = 0, len = args.length; i < len; i++) {
                const arg = args[i];
                if (arg instanceof VSBuffer) {
                    massagedArgs[i] = { type: 2 , value: arg };
                }
                else if (typeof arg === 'undefined') {
                    massagedArgs[i] = { type: 4  };
                }
                else if (arg instanceof SerializableObjectWithBuffers) {
                    const { jsonString, referencedBuffers } = stringifyJsonWithBufferRefs(arg.value, replacer);
                    massagedArgs[i] = { type: 3 , value: VSBuffer.fromString(jsonString), buffers: referencedBuffers };
                }
                else {
                    massagedArgs[i] = { type: 1 , value: VSBuffer.fromString(stringify(arg, replacer)) };
                }
            }
            return {
                type: 1 ,
                args: massagedArgs,
            };
        }
        return {
            type: 0 ,
            args: stringify(args, replacer)
        };
    }
    static serializeRequest(req, rpcId, method, serializedArgs, usesCancellationToken) {
        switch (serializedArgs.type) {
            case 0 :
                return this._requestJSONArgs(req, rpcId, method, serializedArgs.args, usesCancellationToken);
            case 1 :
                return this._requestMixedArgs(req, rpcId, method, serializedArgs.args, usesCancellationToken);
        }
    }
    static _requestJSONArgs(req, rpcId, method, args, usesCancellationToken) {
        const methodBuff = VSBuffer.fromString(method);
        const argsBuff = VSBuffer.fromString(args);
        let len = 0;
        len += MessageBuffer.sizeUInt8();
        len += MessageBuffer.sizeShortString(methodBuff);
        len += MessageBuffer.sizeLongString(argsBuff);
        let result = MessageBuffer.alloc(usesCancellationToken ? 2  : 1 , req, len);
        result.writeUInt8(rpcId);
        result.writeShortString(methodBuff);
        result.writeLongString(argsBuff);
        return result.buffer;
    }
    static deserializeRequestJSONArgs(buff) {
        const rpcId = buff.readUInt8();
        const method = buff.readShortString();
        const args = buff.readLongString();
        return {
            rpcId: rpcId,
            method: method,
            args: JSON.parse(args)
        };
    }
    static _requestMixedArgs(req, rpcId, method, args, usesCancellationToken) {
        const methodBuff = VSBuffer.fromString(method);
        let len = 0;
        len += MessageBuffer.sizeUInt8();
        len += MessageBuffer.sizeShortString(methodBuff);
        len += MessageBuffer.sizeMixedArray(args);
        let result = MessageBuffer.alloc(usesCancellationToken ? 4  : 3 , req, len);
        result.writeUInt8(rpcId);
        result.writeShortString(methodBuff);
        result.writeMixedArray(args);
        return result.buffer;
    }
    static deserializeRequestMixedArgs(buff) {
        const rpcId = buff.readUInt8();
        const method = buff.readShortString();
        const rawargs = buff.readMixedArray();
        const args =  new Array(rawargs.length);
        for (let i = 0, len = rawargs.length; i < len; i++) {
            const rawarg = rawargs[i];
            if (typeof rawarg === 'string') {
                args[i] = JSON.parse(rawarg);
            }
            else {
                args[i] = rawarg;
            }
        }
        return {
            rpcId: rpcId,
            method: method,
            args: args
        };
    }
    static serializeAcknowledged(req) {
        return MessageBuffer.alloc(5 , req, 0).buffer;
    }
    static serializeCancel(req) {
        return MessageBuffer.alloc(6 , req, 0).buffer;
    }
    static serializeReplyOK(req, res, replacer) {
        if (typeof res === 'undefined') {
            return this._serializeReplyOKEmpty(req);
        }
        else if (res instanceof VSBuffer) {
            return this._serializeReplyOKVSBuffer(req, res);
        }
        else if (res instanceof SerializableObjectWithBuffers) {
            const { jsonString, referencedBuffers } = stringifyJsonWithBufferRefs(res.value, replacer, true);
            return this._serializeReplyOKJSONWithBuffers(req, jsonString, referencedBuffers);
        }
        else {
            return this._serializeReplyOKJSON(req, safeStringify(res, replacer));
        }
    }
    static _serializeReplyOKEmpty(req) {
        return MessageBuffer.alloc(7 , req, 0).buffer;
    }
    static _serializeReplyOKVSBuffer(req, res) {
        let len = 0;
        len += MessageBuffer.sizeVSBuffer(res);
        let result = MessageBuffer.alloc(8 , req, len);
        result.writeVSBuffer(res);
        return result.buffer;
    }
    static deserializeReplyOKVSBuffer(buff) {
        return buff.readVSBuffer();
    }
    static _serializeReplyOKJSON(req, res) {
        const resBuff = VSBuffer.fromString(res);
        let len = 0;
        len += MessageBuffer.sizeLongString(resBuff);
        let result = MessageBuffer.alloc(9 , req, len);
        result.writeLongString(resBuff);
        return result.buffer;
    }
    static _serializeReplyOKJSONWithBuffers(req, res, buffers) {
        const resBuff = VSBuffer.fromString(res);
        let len = 0;
        len += MessageBuffer.sizeUInt32;
        len += MessageBuffer.sizeLongString(resBuff);
        for (const buffer of buffers) {
            len += MessageBuffer.sizeVSBuffer(buffer);
        }
        let result = MessageBuffer.alloc(10 , req, len);
        result.writeUInt32(buffers.length);
        result.writeLongString(resBuff);
        for (const buffer of buffers) {
            result.writeBuffer(buffer);
        }
        return result.buffer;
    }
    static deserializeReplyOKJSON(buff) {
        const res = buff.readLongString();
        return JSON.parse(res);
    }
    static deserializeReplyOKJSONWithBuffers(buff, uriTransformer) {
        const bufferCount = buff.readUInt32();
        const res = buff.readLongString();
        const buffers = [];
        for (let i = 0; i < bufferCount; ++i) {
            buffers.push(buff.readVSBuffer());
        }
        return (
             new SerializableObjectWithBuffers(parseJsonAndRestoreBufferRefs(res, buffers, uriTransformer))
        );
    }
    static serializeReplyErr(req, err) {
        const errStr = (err ? safeStringify(transformErrorForSerialization(err), null) : undefined);
        if (typeof errStr !== 'string') {
            return this._serializeReplyErrEmpty(req);
        }
        const errBuff = VSBuffer.fromString(errStr);
        let len = 0;
        len += MessageBuffer.sizeLongString(errBuff);
        let result = MessageBuffer.alloc(11 , req, len);
        result.writeLongString(errBuff);
        return result.buffer;
    }
    static deserializeReplyErrError(buff) {
        const err = buff.readLongString();
        return JSON.parse(err);
    }
    static _serializeReplyErrEmpty(req) {
        return MessageBuffer.alloc(12 , req, 0).buffer;
    }
}
function requestTypeToStr(type) {
    switch (type) {
        case 100 :
            return 'req';
        case 101 :
            return 'cancel';
        case 102 :
            return 'subscribe';
        case 103 :
            return 'unsubscribe';
    }
}
function responseTypeToStr(type) {
    switch (type) {
        case 200 :
            return `init`;
        case 201 :
            return `reply:`;
        case 202 :
        case 203 :
            return `replyErr:`;
        case 204 :
            return `event:`;
    }
}
var State;
 (function(State) {
    State[State["Uninitialized"] = 0] = "Uninitialized";
    State[State["Idle"] = 1] = "Idle";
})(State || (State = {}));
 class BufferReader {
    constructor(buffer) {
        this.buffer = buffer;
        this.pos = 0;
    }
    read(bytes) {
        const result = this.buffer.slice(this.pos, this.pos + bytes);
        this.pos += result.byteLength;
        return result;
    }
}
 class BufferWriter {
    constructor() {
        this.buffers = [];
    }
    get buffer() {
        return VSBuffer.concat(this.buffers);
    }
    write(buffer) {
        this.buffers.push(buffer);
    }
}
var DataType;
 (function(DataType) {
    DataType[DataType["Undefined"] = 0] = "Undefined";
    DataType[DataType["String"] = 1] = "String";
    DataType[DataType["Buffer"] = 2] = "Buffer";
    DataType[DataType["VSBuffer"] = 3] = "VSBuffer";
    DataType[DataType["Array"] = 4] = "Array";
    DataType[DataType["Object"] = 5] = "Object";
})(DataType || (DataType = {}));
function createSizeBuffer(size) {
    const result = VSBuffer.alloc(4);
    result.writeUInt32BE(size, 0);
    return result;
}
function readSizeBuffer(reader) {
    return reader.read(4).readUInt32BE(0);
}
function createOneByteBuffer(value) {
    const result = VSBuffer.alloc(1);
    result.writeUInt8(value, 0);
    return result;
}
const BufferPresets = {
    Undefined: createOneByteBuffer(DataType.Undefined),
    String: createOneByteBuffer(DataType.String),
    Buffer: createOneByteBuffer(DataType.Buffer),
    VSBuffer: createOneByteBuffer(DataType.VSBuffer),
    Array: createOneByteBuffer(DataType.Array),
    Object: createOneByteBuffer(DataType.Object),
};
const hasBuffer = (typeof Buffer !== 'undefined');
function serialize(writer, data) {
    if (typeof data === 'undefined') {
        writer.write(BufferPresets.Undefined);
    }
    else if (typeof data === 'string') {
        const buffer = VSBuffer.fromString(data);
        writer.write(BufferPresets.String);
        writer.write(createSizeBuffer(buffer.byteLength));
        writer.write(buffer);
    }
    else if (hasBuffer && Buffer.isBuffer(data)) {
        const buffer = VSBuffer.wrap(data);
        writer.write(BufferPresets.Buffer);
        writer.write(createSizeBuffer(buffer.byteLength));
        writer.write(buffer);
    }
    else if (data instanceof VSBuffer) {
        writer.write(BufferPresets.VSBuffer);
        writer.write(createSizeBuffer(data.byteLength));
        writer.write(data);
    }
    else if (Array.isArray(data)) {
        writer.write(BufferPresets.Array);
        writer.write(createSizeBuffer(data.length));
        for (const el of data) {
            serialize(writer, el);
        }
    }
    else {
        const buffer = VSBuffer.fromString(JSON.stringify(data));
        writer.write(BufferPresets.Object);
        writer.write(createSizeBuffer(buffer.byteLength));
        writer.write(buffer);
    }
}
function deserialize(reader) {
    const type = reader.read(1).readUInt8(0);
    switch (type) {
        case DataType.Undefined: return undefined;
        case DataType.String: return reader.read(readSizeBuffer(reader)).toString();
        case DataType.Buffer: return reader.read(readSizeBuffer(reader)).buffer;
        case DataType.VSBuffer: return reader.read(readSizeBuffer(reader));
        case DataType.Array: {
            const length = readSizeBuffer(reader);
            const result = [];
            for (let i = 0; i < length; i++) {
                result.push(deserialize(reader));
            }
            return result;
        }
        case DataType.Object: return JSON.parse(reader.read(readSizeBuffer(reader)).toString());
    }
}
class ChannelServer {
    constructor(protocol, ctx, logger = null, timeoutDelay = 1000) {
        this.protocol = protocol;
        this.ctx = ctx;
        this.logger = logger;
        this.timeoutDelay = timeoutDelay;
        this.channels =  new Map();
        this.activeRequests =  new Map();
        this.pendingRequests =  new Map();
        this.protocolListener = this.protocol.onMessage(msg => this.onRawMessage(msg));
        this.sendResponse({ type: 200  });
    }
    registerChannel(channelName, channel) {
        this.channels.set(channelName, channel);
        setTimeout(() => this.flushPendingRequests(channelName), 0);
    }
    sendResponse(response) {
        switch (response.type) {
            case 200 : {
                const msgLength = this.send([response.type]);
                this.logger?.logOutgoing(msgLength, 0, 1 , responseTypeToStr(response.type));
                return;
            }
            case 201 :
            case 202 :
            case 204 :
            case 203 : {
                const msgLength = this.send([response.type, response.id], response.data);
                this.logger?.logOutgoing(msgLength, response.id, 1 , responseTypeToStr(response.type), response.data);
                return;
            }
        }
    }
    send(header, body = undefined) {
        const writer =  new BufferWriter();
        serialize(writer, header);
        serialize(writer, body);
        return this.sendBuffer(writer.buffer);
    }
    sendBuffer(message) {
        try {
            this.protocol.send(message);
            return message.byteLength;
        }
        catch (err) {
            return 0;
        }
    }
    onRawMessage(message) {
        const reader =  new BufferReader(message);
        const header = deserialize(reader);
        const body = deserialize(reader);
        const type = header[0];
        switch (type) {
            case 100 :
                this.logger?.logIncoming(message.byteLength, header[1], 1 , `${requestTypeToStr(type)}: ${header[2]}.${header[3]}`, body);
                return this.onPromise({ type, id: header[1], channelName: header[2], name: header[3], arg: body });
            case 102 :
                this.logger?.logIncoming(message.byteLength, header[1], 1 , `${requestTypeToStr(type)}: ${header[2]}.${header[3]}`, body);
                return this.onEventListen({ type, id: header[1], channelName: header[2], name: header[3], arg: body });
            case 101 :
                this.logger?.logIncoming(message.byteLength, header[1], 1 , `${requestTypeToStr(type)}`);
                return this.disposeActiveRequest({ type, id: header[1] });
            case 103 :
                this.logger?.logIncoming(message.byteLength, header[1], 1 , `${requestTypeToStr(type)}`);
                return this.disposeActiveRequest({ type, id: header[1] });
        }
    }
    onPromise(request) {
        const channel = this.channels.get(request.channelName);
        if (!channel) {
            this.collectPendingRequest(request);
            return;
        }
        const cancellationTokenSource =  new CancellationTokenSource$1();
        let promise;
        try {
            promise = channel.call(this.ctx, request.name, request.arg, cancellationTokenSource.token);
        }
        catch (err) {
            promise = Promise.reject(err);
        }
        const id = request.id;
        promise.then(data => {
            this.sendResponse({ id, data, type: 201  });
            this.activeRequests.delete(request.id);
        }, err => {
            if (err instanceof Error) {
                this.sendResponse({
                    id, data: {
                        message: err.message,
                        name: err.name,
                        stack: err.stack ? (err.stack.split ? err.stack.split('\n') : err.stack) : undefined
                    }, type: 202
                });
            }
            else {
                this.sendResponse({ id, data: err, type: 203  });
            }
            this.activeRequests.delete(request.id);
        });
        const disposable = toDisposable(() => cancellationTokenSource.cancel());
        this.activeRequests.set(request.id, disposable);
    }
    onEventListen(request) {
        const channel = this.channels.get(request.channelName);
        if (!channel) {
            this.collectPendingRequest(request);
            return;
        }
        const id = request.id;
        const event = channel.listen(this.ctx, request.name, request.arg);
        const disposable = event(data => this.sendResponse({ id, data, type: 204  }));
        this.activeRequests.set(request.id, disposable);
    }
    disposeActiveRequest(request) {
        const disposable = this.activeRequests.get(request.id);
        if (disposable) {
            disposable.dispose();
            this.activeRequests.delete(request.id);
        }
    }
    collectPendingRequest(request) {
        let pendingRequests = this.pendingRequests.get(request.channelName);
        if (!pendingRequests) {
            pendingRequests = [];
            this.pendingRequests.set(request.channelName, pendingRequests);
        }
        const timer = setTimeout(() => {
            console.error(`Unknown channel: ${request.channelName}`);
            if (request.type === 100 ) {
                this.sendResponse({
                    id: request.id,
                    data: { name: 'Unknown channel', message: `Channel name '${request.channelName}' timed out after ${this.timeoutDelay}ms`, stack: undefined },
                    type: 202
                });
            }
        }, this.timeoutDelay);
        pendingRequests.push({ request, timeoutTimer: timer });
    }
    flushPendingRequests(channelName) {
        const requests = this.pendingRequests.get(channelName);
        if (requests) {
            for (const request of requests) {
                clearTimeout(request.timeoutTimer);
                switch (request.request.type) {
                    case 100 :
                        this.onPromise(request.request);
                        break;
                    case 102 :
                        this.onEventListen(request.request);
                        break;
                }
            }
            this.pendingRequests.delete(channelName);
        }
    }
    dispose() {
        if (this.protocolListener) {
            this.protocolListener.dispose();
            this.protocolListener = null;
        }
        dispose(this.activeRequests.values());
        this.activeRequests.clear();
    }
}
class ChannelClient {
    constructor(protocol, logger = null) {
        this.protocol = protocol;
        this.isDisposed = false;
        this.state = State.Uninitialized;
        this.activeRequests =  new Set();
        this.handlers =  new Map();
        this.lastRequestId = 0;
        this._onDidInitialize =  new Emitter();
        this.onDidInitialize = this._onDidInitialize.event;
        this.protocolListener = this.protocol.onMessage(msg => this.onBuffer(msg));
        this.logger = logger;
    }
    getChannel(channelName) {
        const that = this;
        return {
            call(command, arg, cancellationToken) {
                if (that.isDisposed) {
                    return Promise.reject(canceled());
                }
                return that.requestPromise(channelName, command, arg, cancellationToken);
            },
            listen(event, arg) {
                if (that.isDisposed) {
                    return Event.None;
                }
                return that.requestEvent(channelName, event, arg);
            }
        };
    }
    requestPromise(channelName, name, arg, cancellationToken = CancellationToken.None) {
        const id = this.lastRequestId++;
        const type = 100 ;
        const request = { id, type, channelName, name, arg };
        if (cancellationToken.isCancellationRequested) {
            return Promise.reject(canceled());
        }
        let disposable;
        const result =  new Promise((c, e) => {
            if (cancellationToken.isCancellationRequested) {
                return e(canceled());
            }
            const doRequest = () => {
                const handler = response => {
                    switch (response.type) {
                        case 201 :
                            this.handlers.delete(id);
                            c(response.data);
                            break;
                        case 202 : {
                            this.handlers.delete(id);
                            const error =  new Error(response.data.message);
                            error.stack = response.data.stack;
                            error.name = response.data.name;
                            e(error);
                            break;
                        }
                        case 203 :
                            this.handlers.delete(id);
                            e(response.data);
                            break;
                    }
                };
                this.handlers.set(id, handler);
                this.sendRequest(request);
            };
            let uninitializedPromise = null;
            if (this.state === State.Idle) {
                doRequest();
            }
            else {
                uninitializedPromise = createCancelablePromise(_ => this.whenInitialized());
                uninitializedPromise.then(() => {
                    uninitializedPromise = null;
                    doRequest();
                });
            }
            const cancel = () => {
                if (uninitializedPromise) {
                    uninitializedPromise.cancel();
                    uninitializedPromise = null;
                }
                else {
                    this.sendRequest({ id, type: 101  });
                }
                e(canceled());
            };
            const cancellationTokenListener = cancellationToken.onCancellationRequested(cancel);
            disposable = combinedDisposable(toDisposable(cancel), cancellationTokenListener);
            this.activeRequests.add(disposable);
        });
        return result.finally(() => { this.activeRequests.delete(disposable); });
    }
    requestEvent(channelName, name, arg) {
        const id = this.lastRequestId++;
        const type = 102 ;
        const request = { id, type, channelName, name, arg };
        let uninitializedPromise = null;
        const emitter =  new Emitter({
            onFirstListenerAdd: () => {
                uninitializedPromise = createCancelablePromise(_ => this.whenInitialized());
                uninitializedPromise.then(() => {
                    uninitializedPromise = null;
                    this.activeRequests.add(emitter);
                    this.sendRequest(request);
                });
            },
            onLastListenerRemove: () => {
                if (uninitializedPromise) {
                    uninitializedPromise.cancel();
                    uninitializedPromise = null;
                }
                else {
                    this.activeRequests.delete(emitter);
                    this.sendRequest({ id, type: 103  });
                }
            }
        });
        const handler = (res) => emitter.fire(res.data);
        this.handlers.set(id, handler);
        return emitter.event;
    }
    sendRequest(request) {
        switch (request.type) {
            case 100 :
            case 102 : {
                const msgLength = this.send([request.type, request.id, request.channelName, request.name], request.arg);
                if (this.logger) {
                    this.logger.logOutgoing(msgLength, request.id, 0 , `${requestTypeToStr(request.type)}: ${request.channelName}.${request.name}`, request.arg);
                }
                return;
            }
            case 101 :
            case 103 : {
                const msgLength = this.send([request.type, request.id]);
                if (this.logger) {
                    this.logger.logOutgoing(msgLength, request.id, 0 , requestTypeToStr(request.type));
                }
                return;
            }
        }
    }
    send(header, body = undefined) {
        const writer =  new BufferWriter();
        serialize(writer, header);
        serialize(writer, body);
        return this.sendBuffer(writer.buffer);
    }
    sendBuffer(message) {
        try {
            this.protocol.send(message);
            return message.byteLength;
        }
        catch (err) {
            return 0;
        }
    }
    onBuffer(message) {
        const reader =  new BufferReader(message);
        const header = deserialize(reader);
        const body = deserialize(reader);
        const type = header[0];
        switch (type) {
            case 200 :
                if (this.logger) {
                    this.logger.logIncoming(message.byteLength, 0, 0 , responseTypeToStr(type));
                }
                return this.onResponse({ type: header[0] });
            case 201 :
            case 202 :
            case 204 :
            case 203 :
                if (this.logger) {
                    this.logger.logIncoming(message.byteLength, header[1], 0 , responseTypeToStr(type), body);
                }
                return this.onResponse({ type: header[0], id: header[1], data: body });
        }
    }
    onResponse(response) {
        if (response.type === 200 ) {
            this.state = State.Idle;
            this._onDidInitialize.fire();
            return;
        }
        const handler = this.handlers.get(response.id);
        if (handler) {
            handler(response);
        }
    }
    get onDidInitializePromise() {
        return Event.toPromise(this.onDidInitialize);
    }
    whenInitialized() {
        if (this.state === State.Idle) {
            return Promise.resolve();
        }
        else {
            return this.onDidInitializePromise;
        }
    }
    dispose() {
        this.isDisposed = true;
        if (this.protocolListener) {
            this.protocolListener.dispose();
            this.protocolListener = null;
        }
        dispose(this.activeRequests.values());
        this.activeRequests.clear();
    }
}
class IPCClient {
    constructor(protocol, ctx, ipcLogger = null) {
        const writer =  new BufferWriter();
        serialize(writer, ctx);
        protocol.send(writer.buffer);
        this.channelClient =  new ChannelClient(protocol, ipcLogger);
        this.channelServer =  new ChannelServer(protocol, ctx, ipcLogger);
    }
    getChannel(channelName) {
        return this.channelClient.getChannel(channelName);
    }
    registerChannel(channelName, channel) {
        this.channelServer.registerChannel(channelName, channel);
    }
    dispose() {
        this.channelClient.dispose();
        this.channelServer.dispose();
    }
}
let emptyBuffer = null;
function getEmptyBuffer() {
    if (!emptyBuffer) {
        emptyBuffer = VSBuffer.alloc(0);
    }
    return emptyBuffer;
}
class ChunkStream {
    constructor() {
        this._chunks = [];
        this._totalLength = 0;
    }
    get byteLength() {
        return this._totalLength;
    }
    acceptChunk(buff) {
        this._chunks.push(buff);
        this._totalLength += buff.byteLength;
    }
    read(byteCount) {
        return this._read(byteCount, true);
    }
    peek(byteCount) {
        return this._read(byteCount, false);
    }
    _read(byteCount, advance) {
        if (byteCount === 0) {
            return getEmptyBuffer();
        }
        if (byteCount > this._totalLength) {
            throw new Error(`Cannot read so many bytes!`);
        }
        if (this._chunks[0].byteLength === byteCount) {
            const result = this._chunks[0];
            if (advance) {
                this._chunks.shift();
                this._totalLength -= byteCount;
            }
            return result;
        }
        if (this._chunks[0].byteLength > byteCount) {
            const result = this._chunks[0].slice(0, byteCount);
            if (advance) {
                this._chunks[0] = this._chunks[0].slice(byteCount);
                this._totalLength -= byteCount;
            }
            return result;
        }
        let result = VSBuffer.alloc(byteCount);
        let resultOffset = 0;
        let chunkIndex = 0;
        while (byteCount > 0) {
            const chunk = this._chunks[chunkIndex];
            if (chunk.byteLength > byteCount) {
                const chunkPart = chunk.slice(0, byteCount);
                result.set(chunkPart, resultOffset);
                resultOffset += byteCount;
                if (advance) {
                    this._chunks[chunkIndex] = chunk.slice(byteCount);
                    this._totalLength -= byteCount;
                }
                byteCount -= byteCount;
            }
            else {
                result.set(chunk, resultOffset);
                resultOffset += chunk.byteLength;
                if (advance) {
                    this._chunks.shift();
                    this._totalLength -= chunk.byteLength;
                }
                else {
                    chunkIndex++;
                }
                byteCount -= chunk.byteLength;
            }
        }
        return result;
    }
}
function protocolMessageTypeToString(messageType) {
    switch (messageType) {
        case 0 : return 'None';
        case 1 : return 'Regular';
        case 2 : return 'Control';
        case 3 : return 'Ack';
        case 5 : return 'Disconnect';
        case 6 : return 'ReplayRequest';
        case 7 : return 'PauseWriting';
        case 8 : return 'ResumeWriting';
    }
}
 class ProtocolMessage {
    constructor(type, id, ack, data) {
        this.type = type;
        this.id = id;
        this.ack = ack;
        this.data = data;
        this.writtenTime = 0;
    }
    get size() {
        return this.data.byteLength;
    }
}
 class ProtocolReader extends Disposable$2 {
    constructor(socket) {
        super();
        this._onMessage = this._register( new Emitter());
        this.onMessage = this._onMessage.event;
        this._state = {
            readHead: true,
            readLen: 13 ,
            messageType: 0 ,
            id: 0,
            ack: 0
        };
        this._socket = socket;
        this._isDisposed = false;
        this._incomingData =  new ChunkStream();
        this._register(this._socket.onData(data => this.acceptChunk(data)));
        this.lastReadTime = Date.now();
    }
    acceptChunk(data) {
        if (!data || data.byteLength === 0) {
            return;
        }
        this.lastReadTime = Date.now();
        this._incomingData.acceptChunk(data);
        while (this._incomingData.byteLength >= this._state.readLen) {
            const buff = this._incomingData.read(this._state.readLen);
            if (this._state.readHead) {
                this._state.readHead = false;
                this._state.readLen = buff.readUInt32BE(9);
                this._state.messageType = buff.readUInt8(0);
                this._state.id = buff.readUInt32BE(1);
                this._state.ack = buff.readUInt32BE(5);
                this._socket.traceSocketEvent("protocolHeaderRead" , { messageType: protocolMessageTypeToString(this._state.messageType), id: this._state.id, ack: this._state.ack, messageSize: this._state.readLen });
            }
            else {
                const messageType = this._state.messageType;
                const id = this._state.id;
                const ack = this._state.ack;
                this._state.readHead = true;
                this._state.readLen = 13 ;
                this._state.messageType = 0 ;
                this._state.id = 0;
                this._state.ack = 0;
                this._socket.traceSocketEvent("protocolMessageRead" , buff);
                this._onMessage.fire( new ProtocolMessage(messageType, id, ack, buff));
                if (this._isDisposed) {
                    break;
                }
            }
        }
    }
    readEntireBuffer() {
        return this._incomingData.read(this._incomingData.byteLength);
    }
    dispose() {
        this._isDisposed = true;
        super.dispose();
    }
}
 class ProtocolWriter {
    constructor(socket) {
        this._writeNowTimeout = null;
        this._isDisposed = false;
        this._isPaused = false;
        this._socket = socket;
        this._data = [];
        this._totalLength = 0;
        this.lastWriteTime = 0;
    }
    dispose() {
        try {
            this.flush();
        }
        catch (err) {
        }
        this._isDisposed = true;
    }
    drain() {
        this.flush();
        return this._socket.drain();
    }
    flush() {
        this._writeNow();
    }
    pause() {
        this._isPaused = true;
    }
    resume() {
        this._isPaused = false;
        this._scheduleWriting();
    }
    write(msg) {
        if (this._isDisposed) {
            return;
        }
        msg.writtenTime = Date.now();
        this.lastWriteTime = Date.now();
        const header = VSBuffer.alloc(13 );
        header.writeUInt8(msg.type, 0);
        header.writeUInt32BE(msg.id, 1);
        header.writeUInt32BE(msg.ack, 5);
        header.writeUInt32BE(msg.data.byteLength, 9);
        this._socket.traceSocketEvent("protocolHeaderWrite" , { messageType: protocolMessageTypeToString(msg.type), id: msg.id, ack: msg.ack, messageSize: msg.data.byteLength });
        this._socket.traceSocketEvent("protocolMessageWrite" , msg.data);
        this._writeSoon(header, msg.data);
    }
    _bufferAdd(head, body) {
        const wasEmpty = this._totalLength === 0;
        this._data.push(head, body);
        this._totalLength += head.byteLength + body.byteLength;
        return wasEmpty;
    }
    _bufferTake() {
        const ret = VSBuffer.concat(this._data, this._totalLength);
        this._data.length = 0;
        this._totalLength = 0;
        return ret;
    }
    _writeSoon(header, data) {
        if (this._bufferAdd(header, data)) {
            this._scheduleWriting();
        }
    }
    _scheduleWriting() {
        if (this._writeNowTimeout) {
            return;
        }
        this._writeNowTimeout = setTimeout(() => {
            this._writeNowTimeout = null;
            this._writeNow();
        });
    }
    _writeNow() {
        if (this._totalLength === 0) {
            return;
        }
        if (this._isPaused) {
            return;
        }
        const data = this._bufferTake();
        this._socket.traceSocketEvent("protocolWrite" , { byteLength: data.byteLength });
        this._socket.write(data);
    }
}
class Protocol extends Disposable$2 {
    constructor(socket) {
        super();
        this._onMessage =  new Emitter();
        this.onMessage = this._onMessage.event;
        this._onDidDispose =  new Emitter();
        this.onDidDispose = this._onDidDispose.event;
        this._socket = socket;
        this._socketWriter = this._register( new ProtocolWriter(this._socket));
        this._socketReader = this._register( new ProtocolReader(this._socket));
        this._register(this._socketReader.onMessage((msg) => {
            if (msg.type === 1 ) {
                this._onMessage.fire(msg.data);
            }
        }));
        this._register(this._socket.onClose(() => this._onDidDispose.fire()));
    }
    drain() {
        return this._socketWriter.drain();
    }
    getSocket() {
        return this._socket;
    }
    sendDisconnect() {
    }
    send(buffer) {
        this._socketWriter.write( new ProtocolMessage(1 , 0, 0, buffer));
    }
}
class Client extends IPCClient {
    constructor(protocol, id, ipcLogger = null) {
        super(protocol, id, ipcLogger);
        this.protocol = protocol;
    }
    static fromSocket(socket, id) {
        return (
             new Client( new Protocol(socket), id)
        );
    }
    get onDidDispose() { return this.protocol.onDidDispose; }
    dispose() {
        super.dispose();
        const socket = this.protocol.getSocket();
        this.protocol.sendDisconnect();
        this.protocol.dispose();
        socket.end();
    }
}
class BufferedEmitter {
    constructor() {
        this._hasListeners = false;
        this._isDeliveringMessages = false;
        this._bufferedMessages = [];
        this._emitter =  new Emitter({
            onFirstListenerAdd: () => {
                this._hasListeners = true;
                queueMicrotask(() => this._deliverMessages());
            },
            onLastListenerRemove: () => {
                this._hasListeners = false;
            }
        });
        this.event = this._emitter.event;
    }
    _deliverMessages() {
        if (this._isDeliveringMessages) {
            return;
        }
        this._isDeliveringMessages = true;
        while (this._hasListeners && this._bufferedMessages.length > 0) {
            this._emitter.fire(this._bufferedMessages.shift());
        }
        this._isDeliveringMessages = false;
    }
    fire(event) {
        if (this._hasListeners) {
            if (this._bufferedMessages.length > 0) {
                this._bufferedMessages.push(event);
            }
            else {
                this._emitter.fire(event);
            }
        }
        else {
            this._bufferedMessages.push(event);
        }
    }
    flushBuffer() {
        this._bufferedMessages = [];
    }
}
const _languageId2WordDefinition =  new Map();
function getWordDefinitionFor(languageId) {
    return _languageId2WordDefinition.get(languageId);
}
class ExtHostDocumentData extends MirrorTextModel {
    constructor(_proxy, uri, lines, eol, versionId, _languageId, _isDirty, notebook) {
        super(uri, lines, eol, versionId);
        this._proxy = _proxy;
        this._languageId = _languageId;
        this._isDirty = _isDirty;
        this.notebook = notebook;
        this._isDisposed = false;
    }
    dispose() {
        ok(!this._isDisposed);
        this._isDisposed = true;
        this._isDirty = false;
    }
    equalLines(lines) {
        return equals(this._lines, lines);
    }
    get document() {
        if (!this._document) {
            const that = this;
            this._document = {
                get uri() { return that._uri; },
                get fileName() { return that._uri.fsPath; },
                get isUntitled() { return that._uri.scheme === Schemas.untitled; },
                get languageId() { return that._languageId; },
                get version() { return that._versionId; },
                get isClosed() { return that._isDisposed; },
                get isDirty() { return that._isDirty; },
                save() { return that._save(); },
                getText(range) { return range ? that._getTextInRange(range) : that.getText(); },
                get eol() { return that._eol === '\n' ? EndOfLine$2.LF : EndOfLine$2.CRLF; },
                get lineCount() { return that._lines.length; },
                lineAt(lineOrPos) { return that._lineAt(lineOrPos); },
                offsetAt(pos) { return that._offsetAt(pos); },
                positionAt(offset) { return that._positionAt(offset); },
                validateRange(ran) { return that._validateRange(ran); },
                validatePosition(pos) { return that._validatePosition(pos); },
                getWordRangeAtPosition(pos, regexp) { return that._getWordRangeAtPosition(pos, regexp); },
            };
        }
        return Object.freeze(this._document);
    }
    _acceptLanguageId(newLanguageId) {
        ok(!this._isDisposed);
        this._languageId = newLanguageId;
    }
    _acceptIsDirty(isDirty) {
        ok(!this._isDisposed);
        this._isDirty = isDirty;
    }
    _save() {
        if (this._isDisposed) {
            return Promise.reject( new Error('Document has been closed'));
        }
        return this._proxy.$trySaveDocument(this._uri);
    }
    _getTextInRange(_range) {
        const range = this._validateRange(_range);
        if (range.isEmpty) {
            return '';
        }
        if (range.isSingleLine) {
            return this._lines[range.start.line].substring(range.start.character, range.end.character);
        }
        const lineEnding = this._eol, startLineIndex = range.start.line, endLineIndex = range.end.line, resultLines = [];
        resultLines.push(this._lines[startLineIndex].substring(range.start.character));
        for (let i = startLineIndex + 1; i < endLineIndex; i++) {
            resultLines.push(this._lines[i]);
        }
        resultLines.push(this._lines[endLineIndex].substring(0, range.end.character));
        return resultLines.join(lineEnding);
    }
    _lineAt(lineOrPosition) {
        let line;
        if (lineOrPosition instanceof Position$3) {
            line = lineOrPosition.line;
        }
        else if (typeof lineOrPosition === 'number') {
            line = lineOrPosition;
        }
        if (typeof line !== 'number' || line < 0 || line >= this._lines.length || Math.floor(line) !== line) {
            throw new Error('Illegal value for `line`');
        }
        return (
             new ExtHostDocumentLine(line, this._lines[line], line === this._lines.length - 1)
        );
    }
    _offsetAt(position) {
        position = this._validatePosition(position);
        this._ensureLineStarts();
        return this._lineStarts.getPrefixSum(position.line - 1) + position.character;
    }
    _positionAt(offset) {
        offset = Math.floor(offset);
        offset = Math.max(0, offset);
        this._ensureLineStarts();
        const out = this._lineStarts.getIndexOf(offset);
        const lineLength = this._lines[out.index].length;
        return (
             new Position$3(out.index, Math.min(out.remainder, lineLength))
        );
    }
    _validateRange(range) {
        if (!(range instanceof Range$3)) {
            throw new Error('Invalid argument');
        }
        const start = this._validatePosition(range.start);
        const end = this._validatePosition(range.end);
        if (start === range.start && end === range.end) {
            return range;
        }
        return (
             new Range$3(start.line, start.character, end.line, end.character)
        );
    }
    _validatePosition(position) {
        if (!(position instanceof Position$3)) {
            throw new Error('Invalid argument');
        }
        if (this._lines.length === 0) {
            return position.with(0, 0);
        }
        let { line, character } = position;
        let hasChanged = false;
        if (line < 0) {
            line = 0;
            character = 0;
            hasChanged = true;
        }
        else if (line >= this._lines.length) {
            line = this._lines.length - 1;
            character = this._lines[line].length;
            hasChanged = true;
        }
        else {
            const maxCharacter = this._lines[line].length;
            if (character < 0) {
                character = 0;
                hasChanged = true;
            }
            else if (character > maxCharacter) {
                character = maxCharacter;
                hasChanged = true;
            }
        }
        if (!hasChanged) {
            return position;
        }
        return (
             new Position$3(line, character)
        );
    }
    _getWordRangeAtPosition(_position, regexp) {
        const position = this._validatePosition(_position);
        if (!regexp) {
            regexp = getWordDefinitionFor(this._languageId);
        }
        else if (regExpLeadsToEndlessLoop(regexp)) {
            throw new Error(`[getWordRangeAtPosition]: ignoring custom regexp '${regexp.source}' because it matches the empty string.`);
        }
        const wordAtText = getWordAtText(position.character + 1, ensureValidWordDefinition(regexp), this._lines[position.line], 0);
        if (wordAtText) {
            return (
                 new Range$3(
                    position.line,
                    wordAtText.startColumn - 1,
                    position.line,
                    wordAtText.endColumn - 1
                )
            );
        }
        return undefined;
    }
}
class ExtHostDocumentLine {
    constructor(line, text, isLastLine) {
        this._line = line;
        this._text = text;
        this._isLastLine = isLastLine;
    }
    get lineNumber() {
        return this._line;
    }
    get text() {
        return this._text;
    }
    get range() {
        return (
             new Range$3(this._line, 0, this._line, this._text.length)
        );
    }
    get rangeIncludingLineBreak() {
        if (this._isLastLine) {
            return this.range;
        }
        return (
             new Range$3(this._line, 0, this._line + 1, 0)
        );
    }
    get firstNonWhitespaceCharacterIndex() {
        return /^(\s*)/.exec(this._text)[1].length;
    }
    get isEmptyOrWhitespace() {
        return this.firstNonWhitespaceCharacterIndex === this._text.length;
    }
}
function unsupported$1() {
    throw new Error('unsupported');
}
const noop = () => { };
const extensionDescription = {
    identifier: new ExtensionIdentifier('monaco'),
    targetPlatform: "web" ,
    isBuiltin: true,
    isUserBuiltin: true,
    isUnderDevelopment: false,
    extensionLocation: URI.file('extension'),
    name: 'monaco',
    publisher: 'microsoft',
    version: '1.0.0',
    engines: {
        vscode: '1.67.2'
    }
};
class SimpleMessagePassingProtocol {
    constructor() {
        this._onMessage = new BufferedEmitter();
        this.onMessage = this._onMessage.event;
    }
    send(buffer) {
        this._onMessage.fire(buffer);
    }
}
const imessagePassingProtocol = new SimpleMessagePassingProtocol();
const rpcProtocol = new RPCProtocol(imessagePassingProtocol);
const extHostFileSystemInfo = new ExtHostFileSystemInfo();
const mainContext = {
    getProxy: function (identifier) {
        return rpcProtocol.getProxy(identifier);
    },
    set: function (identifier, instance) {
        return rpcProtocol.set(identifier, instance);
    },
    assertRegistered: function (identifiers) {
        rpcProtocol.assertRegistered(identifiers);
    },
    drain: function () {
        return rpcProtocol.drain();
    },
    dispose: function () {
        rpcProtocol.dispose();
    }
};
const extHostRpcService = {
    _serviceBrand: undefined,
    getProxy: function (identifier) {
        return rpcProtocol.getProxy(identifier);
    },
    set: function (identifier, instance) {
        return rpcProtocol.set(identifier, instance);
    },
    assertRegistered: function (identifiers) {
        rpcProtocol.assertRegistered(identifiers);
    },
    drain: function () {
        return rpcProtocol.drain();
    },
    dispose: function () {
        rpcProtocol.dispose();
    }
};
const extHostContext = {
    remoteAuthority: null,
    extensionHostKind: 1 ,
    getProxy: function (identifier) {
        return rpcProtocol.getProxy(identifier);
    },
    set: function (identifier, instance) {
        return rpcProtocol.set(identifier, instance);
    },
    assertRegistered: function (identifiers) {
        rpcProtocol.assertRegistered(identifiers);
    },
    drain: function () {
        return rpcProtocol.drain();
    },
    dispose: function () {
        rpcProtocol.dispose();
    }
};
const extHostLogService = {
    _serviceBrand: undefined,
    onDidChangeLogLevel: Event.None,
    getLevel: function () {
        return LogLevel.Off;
    },
    setLevel: noop,
    trace: noop,
    debug: noop,
    info: noop,
    warn: noop,
    error: noop,
    critical: noop,
    flush: noop,
    dispose: noop
};
const extensionService = {
    activateByEvent: async function () {
    }
};
const commandsService = StandaloneServices.get(ICommandService);
rpcProtocol.set(MainContext.MainThreadCommands, new MainThreadCommands(extHostContext, commandsService, extensionService));
const extHostCommands = new ExtHostCommands(extHostRpcService, extHostLogService);
rpcProtocol.set(ExtHostContext.ExtHostCommands, extHostCommands);
const extHostApiDeprecationService = {
    _serviceBrand: undefined,
    report: function () {
    }
};
class MainThreadDiagnostics {
    constructor() {
        this._activeOwners = new Set();
    }
    $changeMany(owner, entries) {
        for (const entry of entries) {
            const [uri, markers] = entry;
            if (markers != null) {
                for (const marker of markers) {
                    if (marker.relatedInformation != null) {
                        for (const relatedInformation of marker.relatedInformation) {
                            relatedInformation.resource = URI.revive(relatedInformation.resource);
                        }
                    }
                    if (marker.code != null && typeof marker.code !== 'string') {
                        marker.code.target = URI.revive(marker.code.target);
                    }
                }
            }
            monaco.editor.setModelMarkers(monaco.editor.getModel(URI.revive(uri)), owner, markers);
        }
        this._activeOwners.add(owner);
    }
    $clear(owner) {
        const markers = monaco.editor.getModelMarkers({
            owner
        });
        const models = new Set();
        for (const marker of markers) {
            models.add(monaco.editor.getModel(marker.resource));
        }
        for (const model of models) {
            monaco.editor.setModelMarkers(model, owner, []);
        }
        this._activeOwners.delete(owner);
    }
    dispose() {
        this._activeOwners.forEach(owner => this.$clear(owner));
        this._activeOwners.clear();
    }
}
rpcProtocol.set(MainContext.MainThreadDiagnostics, new MainThreadDiagnostics());
const extHostDiagnostics = new ExtHostDiagnostics(mainContext, extHostLogService, extHostFileSystemInfo);
const unsupportedMainThreadDocumentsShape = {
    $tryCreateDocument: unsupported$1,
    $tryOpenDocument: unsupported$1,
    $trySaveDocument: unsupported$1,
    dispose() { }
};
function createDocumentDataFromModel(model) {
    return new ExtHostDocumentData(unsupportedMainThreadDocumentsShape, model.uri, model.getLinesContent(), model.getEOL(), model.getVersionId(), model.getLanguageId(), false);
}
class MonacoExtHostDocuments {
    constructor() {
        this.disposableStore = new DisposableStore();
        this.documentsData = new Map();
        this.documentDisposables = new Map();
        this._onDidAddDocument = new Emitter();
        this._onDidRemoveDocument = new Emitter();
        this._onDidChangeDocument = new Emitter();
        this.onDidSaveDocument = Event.None;
        this.ensureDocumentData = unsupported$1;
        this.createDocumentData = unsupported$1;
        this.$acceptModelLanguageChanged = unsupported$1;
        this.$acceptModelSaved = unsupported$1;
        this.$acceptDirtyStateChanged = unsupported$1;
        this.$acceptModelChanged = unsupported$1;
        this.setWordDefinitionFor = unsupported$1;
        for (const model of monaco.editor.getModels()) {
            this.addModel(model);
        }
        this.disposableStore.add(monaco.editor.onDidCreateModel(model => this.addModel(model)));
        this.disposableStore.add(monaco.editor.onWillDisposeModel(model => this.removeModel(model)));
        this.disposableStore.add(monaco.editor.onDidChangeModelLanguage((event) => {
            this.removeModel(event.model);
            this.addModel(event.model);
        }));
    }
    addModel(model) {
        const uri = model.uri.toString();
        const documentData = this.setModel(uri, model);
        this._onDidAddDocument.fire(documentData.document);
        this.documentDisposables.set(uri, model.onDidChangeContent(event => this.onDidChangeContent(uri, event)));
    }
    removeModel(model) {
        const uri = model.uri.toString();
        const documentData = this.documentsData.get(uri);
        if (documentData != null) {
            this.documentsData.delete(uri);
            this._onDidRemoveDocument.fire(documentData.document);
        }
        const disposable = this.documentDisposables.get(uri);
        if (disposable != null) {
            disposable.dispose();
            this.documentDisposables.delete(uri);
        }
    }
    onDidChangeContent(uri, event) {
        const textDocumentData = this.documentsData.get(uri);
        textDocumentData.onEvents(event);
        this._onDidChangeDocument.fire({
            document: textDocumentData.document,
            contentChanges: event.changes.map(change => ({
                range: Range$1.to(change.range),
                rangeLength: change.rangeLength,
                rangeOffset: change.rangeOffset,
                text: change.text
            })),
            reason: event.isUndoing ? TextDocumentChangeReason$1.Undo : event.isRedoing ? TextDocumentChangeReason$1.Redo : undefined
        });
    }
    setModel(uri, model) {
        const documentData = createDocumentDataFromModel(model);
        this.documentsData.set(uri, documentData);
        return documentData;
    }
    getDocument(resource) {
        const data = this.getDocumentData(resource);
        if ((data?.document) == null) {
            throw new Error(`Unable to retrieve document from URI '${resource}'`);
        }
        return data.document;
    }
    getDocumentData(resource) {
        return this.documentsData.get(resource.toString());
    }
    get onDidAddDocument() { return this._onDidAddDocument.event; }
    get onDidRemoveDocument() { return this._onDidRemoveDocument.event; }
    get onDidChangeDocument() { return this._onDidChangeDocument.event; }
    getAllDocumentData() {
        return Array.from(this.documentsData.values());
    }
    dispose() {
        this.disposableStore.dispose();
    }
}
const extHostDocuments = new MonacoExtHostDocuments();
const workspace$2 = {
    match(selector, document) {
        return score(LanguageSelector.from(selector), document.uri, document.languageId, true, undefined, undefined);
    },
    createDiagnosticCollection(name) {
        return extHostDiagnostics.createDiagnosticCollection(extensionDescription.identifier, name);
    },
    get onDidChangeDiagnostics() {
        return extHostDiagnostics.onDidChangeDiagnostics;
    },
    getDiagnostics: (resource) => {
        return extHostDiagnostics.getDiagnostics(resource);
    },
    registerCompletionItemProvider(documentSelector, provider, ...triggerCharacters) {
        const adapter = new CompletionsAdapter(extHostDocuments, extHostCommands.converter, provider, extHostApiDeprecationService, extensionDescription);
        return monaco.languages.registerCompletionItemProvider(DocumentSelector.from(documentSelector), {
            triggerCharacters,
            async provideCompletionItems(model, position, context, token) {
                const result = await adapter.provideCompletionItems(model.uri, position, context, token);
                if (result == null) {
                    return result;
                }
                return {
                    suggestions: result["b" ].map(d => MainThreadLanguageFeatures._inflateSuggestDto(result["a" ], d)),
                    incomplete: result["c" ] || false,
                    dispose: () => {
                        if (typeof result.x === 'number') {
                            adapter.releaseCompletionItems(result.x);
                        }
                    }
                };
            },
            resolveCompletionItem: CompletionsAdapter.supportsResolving(provider)
                ? async (_suggestion, token) => {
                    const suggestion = _suggestion;
                    const result = await adapter.resolveCompletionItem(suggestion._id, token);
                    if (result == null) {
                        return suggestion;
                    }
                    const newSuggestion = MainThreadLanguageFeatures._inflateSuggestDto(suggestion.range, result);
                    return mixin(suggestion, newSuggestion, true);
                }
                : undefined
        });
    },
    registerCodeActionsProvider(documentSelector, provider, metadata) {
        const adapter = new CodeActionAdapter(extHostDocuments, extHostCommands.converter, extHostDiagnostics, provider, extHostLogService, extensionDescription, extHostApiDeprecationService);
        return monaco.languages.registerCodeActionProvider(documentSelector, {
            async provideCodeActions(model, range, context, token) {
                const listDto = await adapter.provideCodeActions(model.uri, range, {
                    ...context,
                    trigger: 1
                }, token);
                if (listDto == null) {
                    return undefined;
                }
                return {
                    actions: MainThreadLanguageFeatures._reviveCodeActionDto(listDto.actions),
                    dispose: () => {
                        if (typeof listDto.cacheId === 'number') {
                            adapter.releaseCodeActions(listDto.cacheId);
                        }
                    }
                };
            },
            resolveCodeAction: provider.resolveCodeAction != null
                ? async (_codeAction, token) => {
                    const codeAction = _codeAction;
                    const data = await adapter.resolveCodeAction(codeAction.cacheId, token);
                    codeAction.edit = reviveWorkspaceEditDto(data);
                    return _codeAction;
                }
                : undefined
        }, {
            providedCodeActionKinds: metadata?.providedCodeActionKinds?.map(kind => kind.value)
        });
    },
    registerCodeLensProvider(documentSelector, provider) {
        const adapter = new CodeLensAdapter(extHostDocuments, extHostCommands.converter, provider);
        const onDidChangeCodeLenses = provider.onDidChangeCodeLenses;
        const monacoProvider = {
            onDidChange: onDidChangeCodeLenses != null ? listener => onDidChangeCodeLenses(() => listener(monacoProvider)) : undefined,
            provideCodeLenses: async (model, token) => {
                const listDto = await adapter.provideCodeLenses(model.uri, token);
                if (listDto == null) {
                    return undefined;
                }
                return {
                    lenses: listDto.lenses,
                    dispose: () => listDto.cacheId != null && adapter.releaseCodeLenses(listDto.cacheId)
                };
            },
            resolveCodeLens: (_model, codeLens, token) => {
                return adapter.resolveCodeLens(codeLens, token);
            }
        };
        return monaco.languages.registerCodeLensProvider(documentSelector, monacoProvider);
    },
    registerDefinitionProvider(documentSelector, provider) {
        const adapter = new DefinitionAdapter(extHostDocuments, provider);
        return monaco.languages.registerDefinitionProvider(documentSelector, {
            provideDefinition: (model, position, token) => {
                return adapter.provideDefinition(model.uri, position, token).then(MainThreadLanguageFeatures._reviveLocationLinkDto);
            }
        });
    },
    registerImplementationProvider(documentSelector, provider) {
        const adapter = new ImplementationAdapter(extHostDocuments, provider);
        return monaco.languages.registerImplementationProvider(documentSelector, {
            provideImplementation: (model, position, token) => {
                return adapter.provideImplementation(model.uri, position, token).then(MainThreadLanguageFeatures._reviveLocationLinkDto);
            }
        });
    },
    registerTypeDefinitionProvider(documentSelector, provider) {
        const adapter = new TypeDefinitionAdapter(extHostDocuments, provider);
        return monaco.languages.registerTypeDefinitionProvider(documentSelector, {
            provideTypeDefinition: (model, position, token) => {
                return adapter.provideTypeDefinition(model.uri, position, token).then(MainThreadLanguageFeatures._reviveLocationLinkDto);
            }
        });
    },
    registerDeclarationProvider(documentSelector, provider) {
        const adapter = new DeclarationAdapter(extHostDocuments, provider);
        return monaco.languages.registerDeclarationProvider(documentSelector, {
            provideDeclaration: (model, position, token) => {
                return adapter.provideDeclaration(model.uri, position, token).then(MainThreadLanguageFeatures._reviveLocationLinkDto);
            }
        });
    },
    registerHoverProvider(documentSelector, provider) {
        const adapter = new HoverAdapter(extHostDocuments, provider);
        return monaco.languages.registerHoverProvider(documentSelector, {
            provideHover: (model, position, token) => {
                return adapter.provideHover(model.uri, position, token);
            }
        });
    },
    registerDocumentHighlightProvider(documentSelector, provider) {
        const adapter = new DocumentHighlightAdapter(extHostDocuments, provider);
        return monaco.languages.registerDocumentHighlightProvider(documentSelector, {
            provideDocumentHighlights: (model, position, token) => {
                return adapter.provideDocumentHighlights(model.uri, position, token);
            }
        });
    },
    registerDocumentSymbolProvider(documentSelector, provider, metadata) {
        const adapter = new DocumentSymbolAdapter(extHostDocuments, provider);
        const displayName = metadata?.label ?? ExtHostLanguageFeatures._extLabel(extensionDescription);
        return monaco.languages.registerDocumentSymbolProvider(documentSelector, {
            displayName,
            provideDocumentSymbols: (model, token) => {
                return adapter.provideDocumentSymbols(model.uri, token);
            }
        });
    },
    registerReferenceProvider(documentSelector, provider) {
        const adapter = new ReferenceAdapter(extHostDocuments, provider);
        return monaco.languages.registerReferenceProvider(documentSelector, {
            provideReferences: (model, position, context, token) => {
                return adapter.provideReferences(model.uri, position, context, token).then(MainThreadLanguageFeatures._reviveLocationDto);
            }
        });
    },
    registerRenameProvider(documentSelector, provider) {
        const adapter = new RenameAdapter(extHostDocuments, provider, extHostLogService);
        return monaco.languages.registerRenameProvider(documentSelector, {
            provideRenameEdits: (model, position, newName, token) => {
                return adapter.provideRenameEdits(model.uri, position, newName, token).then(reviveWorkspaceEditDto);
            },
            resolveRenameLocation: RenameAdapter.supportsResolving(provider)
                ? (model, position, token) => adapter.resolveRenameLocation(model.uri, position, token)
                : undefined
        });
    },
    registerDocumentFormattingEditProvider(documentSelector, provider) {
        const adapter = new DocumentFormattingAdapter(extHostDocuments, provider);
        return monaco.languages.registerDocumentFormattingEditProvider(documentSelector, {
            displayName: extensionDescription.displayName ?? extensionDescription.name,
            provideDocumentFormattingEdits: (model, options, token) => {
                return adapter.provideDocumentFormattingEdits(model.uri, options, token);
            }
        });
    },
    registerDocumentRangeFormattingEditProvider(documentSelector, provider) {
        const adapter = new RangeFormattingAdapter(extHostDocuments, provider);
        return monaco.languages.registerDocumentRangeFormattingEditProvider(documentSelector, {
            displayName: extensionDescription.displayName ?? extensionDescription.name,
            provideDocumentRangeFormattingEdits: (model, range, options, token) => {
                return adapter.provideDocumentRangeFormattingEdits(model.uri, range, options, token);
            }
        });
    },
    registerOnTypeFormattingEditProvider(documentSelector, provider, firstTriggerCharacter, ...moreTriggerCharacter) {
        const adapter = new OnTypeFormattingAdapter(extHostDocuments, provider);
        return monaco.languages.registerOnTypeFormattingEditProvider(documentSelector, {
            autoFormatTriggerCharacters: [firstTriggerCharacter].concat(moreTriggerCharacter),
            provideOnTypeFormattingEdits: (model, position, ch, options, token) => {
                return adapter.provideOnTypeFormattingEdits(model.uri, position, ch, options, token);
            }
        });
    },
    registerSignatureHelpProvider(selector, provider, firstItem, ...remaining) {
        const adapter = new SignatureHelpAdapter(extHostDocuments, provider);
        let metadataOrTriggerChars;
        if (typeof firstItem === 'object') {
            metadataOrTriggerChars = firstItem;
        }
        else {
            metadataOrTriggerChars = typeof firstItem === 'undefined' ? [] : [firstItem, ...remaining];
        }
        const metadata = Array.isArray(metadataOrTriggerChars)
            ? { triggerCharacters: metadataOrTriggerChars, retriggerCharacters: [] }
            : metadataOrTriggerChars;
        return monaco.languages.registerSignatureHelpProvider(selector, {
            signatureHelpTriggerCharacters: metadata.triggerCharacters,
            signatureHelpRetriggerCharacters: metadata.retriggerCharacters,
            provideSignatureHelp: async (model, position, token, context) => {
                const result = await adapter.provideSignatureHelp(model.uri, position, context, token);
                if (result == null) {
                    return undefined;
                }
                return {
                    value: result,
                    dispose: () => {
                        adapter.releaseSignatureHelp(result.id);
                    }
                };
            }
        });
    },
    registerDocumentLinkProvider(documentSelector, provider) {
        const adapter = new LinkProviderAdapter(extHostDocuments, provider);
        return monaco.languages.registerLinkProvider(documentSelector, {
            provideLinks: (model, token) => {
                return adapter.provideLinks(model.uri, token).then(dto => {
                    if (dto == null) {
                        return undefined;
                    }
                    return {
                        links: dto.links.map(MainThreadLanguageFeatures._reviveLinkDTO),
                        dispose: () => {
                            if (typeof dto.cacheId === 'number') {
                                adapter.releaseLinks(dto.cacheId);
                            }
                        }
                    };
                });
            },
            resolveLink: provider.resolveDocumentLink != null
                ? (link, token) => {
                    const dto = link;
                    if (dto.cacheId == null) {
                        return link;
                    }
                    return adapter.resolveLink(dto.cacheId, token).then(obj => {
                        return obj != null ? MainThreadLanguageFeatures._reviveLinkDTO(obj) : undefined;
                    });
                }
                : undefined
        });
    },
    registerColorProvider(documentSelector, provider) {
        const adapter = new ColorProviderAdapter(extHostDocuments, provider);
        return monaco.languages.registerColorProvider(documentSelector, {
            provideDocumentColors: (model, token) => {
                return adapter.provideColors(model.uri, token)
                    .then(documentColors => {
                    return documentColors.map(documentColor => {
                        const [red, green, blue, alpha] = documentColor.color;
                        const color = {
                            red,
                            green,
                            blue,
                            alpha
                        };
                        return {
                            color,
                            range: documentColor.range
                        };
                    });
                });
            },
            provideColorPresentations: (model, colorInfo, token) => {
                return adapter.provideColorPresentations(model.uri, {
                    color: [colorInfo.color.red, colorInfo.color.green, colorInfo.color.blue, colorInfo.color.alpha],
                    range: colorInfo.range
                }, token);
            }
        });
    },
    registerFoldingRangeProvider(documentSelector, provider) {
        const adapter = new FoldingProviderAdapter(extHostDocuments, provider);
        return monaco.languages.registerFoldingRangeProvider(documentSelector, {
            provideFoldingRanges: (model, context, token) => {
                return adapter.provideFoldingRanges(model.uri, context, token);
            }
        });
    },
    registerSelectionRangeProvider(documentSelector, provider) {
        const adapter = new SelectionRangeAdapter(extHostDocuments, provider, extHostLogService);
        return monaco.languages.registerSelectionRangeProvider(documentSelector, {
            provideSelectionRanges: (model, positions, token) => {
                return adapter.provideSelectionRanges(model.uri, positions, token);
            }
        });
    },
    registerDocumentSemanticTokensProvider(documentSelector, provider, legend) {
        const adapter = new DocumentSemanticTokensAdapter(extHostDocuments, provider);
        return monaco.languages.registerDocumentSemanticTokensProvider(documentSelector, {
            getLegend: () => legend,
            onDidChange: provider.onDidChangeSemanticTokens,
            provideDocumentSemanticTokens: async (model, lastResultId, token) => {
                const nLastResultId = lastResultId != null ? parseInt(lastResultId, 10) : 0;
                const encodedDto = await adapter.provideDocumentSemanticTokens(model.uri, nLastResultId, token);
                if (encodedDto == null) {
                    return null;
                }
                if (token.isCancellationRequested) {
                    return null;
                }
                const dto = decodeSemanticTokensDto(encodedDto);
                if (dto.type === 'full') {
                    return {
                        resultId: String(dto.id),
                        data: dto.data
                    };
                }
                return {
                    resultId: String(dto.id),
                    edits: dto.deltas
                };
            },
            releaseDocumentSemanticTokens: (resultId) => {
                if (resultId != null) {
                    void adapter.releaseDocumentSemanticColoring(parseInt(resultId, 10));
                }
            }
        });
    },
    registerDocumentRangeSemanticTokensProvider(documentSelector, provider, legend) {
        const adapter = new DocumentRangeSemanticTokensAdapter(extHostDocuments, provider);
        return monaco.languages.registerDocumentRangeSemanticTokensProvider(documentSelector, {
            getLegend: () => legend,
            provideDocumentRangeSemanticTokens: async (model, range, token) => {
                const encodedDto = await adapter.provideDocumentRangeSemanticTokens(model.uri, range, token);
                if (encodedDto == null) {
                    return null;
                }
                if (token.isCancellationRequested) {
                    return null;
                }
                const dto = decodeSemanticTokensDto(encodedDto);
                if (dto.type === 'full') {
                    return {
                        resultId: String(dto.id),
                        data: dto.data
                    };
                }
                throw new Error('Unexpected');
            }
        });
    },
    registerInlayHintsProvider(documentSelector, provider) {
        const adapter = new InlayHintsAdapter(extHostDocuments, extHostCommands.converter, provider, extHostLogService, extensionDescription);
        return monaco.languages.registerInlayHintsProvider(documentSelector, {
            displayName: ExtHostLanguageFeatures._extLabel(extensionDescription),
            onDidChangeInlayHints: provider.onDidChangeInlayHints,
            provideInlayHints: async (model, range, token) => {
                const result = await adapter.provideInlayHints(model.uri, range, token);
                if (result == null) {
                    return;
                }
                return {
                    hints: revive(result.hints),
                    dispose: () => {
                        if (result.cacheId != null) {
                            adapter.releaseHints(result.cacheId);
                        }
                    }
                };
            },
            resolveInlayHint: provider.resolveInlayHint != null
                ? async (hint, token) => {
                    const dto = hint;
                    if (dto.cacheId == null) {
                        return hint;
                    }
                    const result = await adapter.resolveInlayHint(dto.cacheId, token);
                    if (token.isCancellationRequested) {
                        throw new CancellationError$1();
                    }
                    if (result == null) {
                        return hint;
                    }
                    return {
                        ...hint,
                        tooltip: result.tooltip,
                        label: revive(result.label)
                    };
                }
                : undefined
        });
    },
    async getLanguages() {
        return monaco.languages.getLanguages().map(language => language.id);
    },
    async setTextDocumentLanguage(document, languageId) {
        const model = monaco.editor.getModel(document.uri);
        if (model == null) {
            throw new Error(`document '${document.uri.toString()}' NOT found`);
        }
        monaco.editor.setModelLanguage(model, languageId);
        return extHostDocuments.getDocument(document.uri);
    },
    setLanguageConfiguration: monaco.languages.setLanguageConfiguration,
    registerEvaluatableExpressionProvider: (documentSelector, provider) => {
        const adapter = new EvaluatableExpressionAdapter(extHostDocuments, provider);
        return Services.get().languages?.registerEvaluatableExpressionProvider?.(documentSelector, {
            provideEvaluatableExpression: (model, position, token) => {
                return adapter.provideEvaluatableExpression(model.uri, position, token);
            }
        }) ?? {
            dispose: () => { }
        };
    },
    registerLinkedEditingRangeProvider: (documentSelector, provider) => {
        const adapter = new LinkedEditingRangeAdapter(extHostDocuments, provider);
        return monaco.languages.registerLinkedEditingRangeProvider(documentSelector, {
            provideLinkedEditingRanges: async (model, position, token) => {
                const res = await adapter.provideLinkedEditingRanges(model.uri, position, token);
                if (res != null) {
                    return {
                        ranges: res.ranges,
                        wordPattern: res.wordPattern
                    };
                }
                return undefined;
            }
        });
    },
    registerInlineCompletionItemProvider: (documentSelector, provider) => {
        const adapter = new InlineCompletionAdapter(extensionDescription, extHostDocuments, provider, extHostCommands.converter);
        const _provider = {
            provideInlineCompletions: async (model, position, context, token) => {
                const result = await adapter.provideInlineCompletions(model.uri, position, context, token);
                if (result == null) {
                    return undefined;
                }
                return {
                    ...result,
                    items: result.items.map(({ insertText, ...item }) => ({
                        ...item,
                        text: typeof insertText === 'string' ? insertText : new SnippetParser().parse(insertText.snippet).toString()
                    }))
                };
            },
            handleItemDidShow: async (completions, item) => {
                if (adapter.supportsHandleDidShowCompletionItem) {
                    adapter.handleDidShowCompletionItem(completions.pid, item.idx);
                }
            },
            freeInlineCompletions: function (completions) {
                adapter.disposeCompletions(completions.pid);
            }
        };
        return monaco.languages.registerInlineCompletionsProvider(documentSelector, _provider);
    },
    registerTypeHierarchyProvider: (documentSelector, provider) => {
        const adapter = new TypeHierarchyAdapter(extHostDocuments, provider);
        return Services.get().languages?.registerTypeHierarchyProvider?.(documentSelector, {
            prepareTypeHierarchy: async (model, position, token) => {
                const items = await adapter.prepareSession(model.uri, position, token);
                if (items == null) {
                    return undefined;
                }
                return {
                    dispose: () => {
                        for (const item of items) {
                            adapter.releaseSession(item._sessionId);
                        }
                    },
                    roots: items.map(MainThreadLanguageFeatures._reviveTypeHierarchyItemDto)
                };
            },
            provideSupertypes: async (item, token) => {
                const supertypes = await adapter.provideSupertypes(item._sessionId, item._itemId, token);
                if (supertypes == null) {
                    return supertypes;
                }
                return supertypes.map(MainThreadLanguageFeatures._reviveTypeHierarchyItemDto);
            },
            provideSubtypes: async (item, token) => {
                const subtypes = await adapter.provideSubtypes(item._sessionId, item._itemId, token);
                if (subtypes == null) {
                    return subtypes;
                }
                return subtypes.map(MainThreadLanguageFeatures._reviveTypeHierarchyItemDto);
            }
        }) ?? {
            dispose: () => { }
        };
    },
    registerCallHierarchyProvider: (documentSelector, provider) => {
        const adapter = new CallHierarchyAdapter(extHostDocuments, provider);
        return Services.get().languages?.registerCallHierarchyProvider?.(documentSelector, {
            prepareCallHierarchy: async (model, position, token) => {
                const items = await adapter.prepareSession(model.uri, position, token);
                if ((items == null) || items.length === 0) {
                    return undefined;
                }
                return {
                    dispose: () => {
                        for (const item of items) {
                            adapter.releaseSession(item._sessionId);
                        }
                    },
                    roots: items.map(MainThreadLanguageFeatures._reviveCallHierarchyItemDto)
                };
            },
            provideOutgoingCalls: async (item, token) => {
                const outgoing = await adapter.provideCallsFrom(item._sessionId, item._itemId, token);
                if (outgoing == null) {
                    return outgoing;
                }
                outgoing.forEach(value => {
                    value.to = MainThreadLanguageFeatures._reviveCallHierarchyItemDto(value.to);
                });
                return outgoing;
            },
            provideIncomingCalls: async (item, token) => {
                const incoming = await adapter.provideCallsTo(item._sessionId, item._itemId, token);
                if (incoming == null) {
                    return incoming;
                }
                incoming.forEach(value => {
                    value.from = MainThreadLanguageFeatures._reviveCallHierarchyItemDto(value.from);
                });
                return incoming;
            }
        }) ?? {
            dispose: () => { }
        };
    },
    registerWorkspaceSymbolProvider: (provider) => {
        const adapter = new NavigateTypeAdapter(provider, extHostLogService);
        let lastResultId;
        return Services.get().languages?.registerNavigateTypeSupport?.({
            provideWorkspaceSymbols: async (search, token) => {
                const result = await adapter.provideWorkspaceSymbols(search, token);
                if (lastResultId !== undefined) {
                    adapter.releaseWorkspaceSymbols(lastResultId);
                }
                lastResultId = result.cacheId;
                return MainThreadLanguageFeatures._reviveWorkspaceSymbolDto(result.symbols);
            },
            resolveWorkspaceSymbol: provider.resolveWorkspaceSymbol != null
                ? async (item, token) => {
                    const resolvedItem = await adapter.resolveWorkspaceSymbol(item, token);
                    return resolvedItem != null ? MainThreadLanguageFeatures._reviveWorkspaceSymbolDto(resolvedItem) : undefined;
                }
                : undefined
        }) ?? {
            dispose: () => { }
        };
    },
    registerInlineValuesProvider: unsupported$1,
    createLanguageStatusItem: unsupported$1
};
var customLanguages = workspace$2;
const commands$1 = {
    registerCommand(id, command, thisArgs) {
        return extHostCommands.registerCommand(true, id, command, thisArgs, undefined, extensionDescription);
    },
    registerTextEditorCommand: unsupported$1,
    executeCommand(id, ...args) {
        return extHostCommands.executeCommand(id, ...args);
    },
    getCommands(filterInternal = false) {
        return extHostCommands.getCommands(filterInternal);
    }
};
var customCommands = commands$1;
class ResourceNotebookCellEdit extends ResourceEdit {
    constructor(resource, cellEdit, versionId, metadata) {
        super(metadata);
        this.resource = resource;
        this.cellEdit = cellEdit;
        this.versionId = versionId;
    }
}
var CellExecutionUpdateType;
 (function(CellExecutionUpdateType) {
    CellExecutionUpdateType[CellExecutionUpdateType["Output"] = 1] = "Output";
    CellExecutionUpdateType[CellExecutionUpdateType["OutputItems"] = 2] = "OutputItems";
    CellExecutionUpdateType[CellExecutionUpdateType["ExecutionState"] = 3] = "ExecutionState";
})(CellExecutionUpdateType || (CellExecutionUpdateType = {}));
var NotebookDto;
 (function(NotebookDto) {
    function toNotebookOutputItemDto(item) {
        return {
            mime: item.mime,
            valueBytes: item.data
        };
    }
    NotebookDto.toNotebookOutputItemDto = toNotebookOutputItemDto;
    function toNotebookOutputDto(output) {
        return {
            outputId: output.outputId,
            metadata: output.metadata,
            items: output.outputs.map(toNotebookOutputItemDto)
        };
    }
    NotebookDto.toNotebookOutputDto = toNotebookOutputDto;
    function toNotebookCellDataDto(cell) {
        return {
            cellKind: cell.cellKind,
            language: cell.language,
            mime: cell.mime,
            source: cell.source,
            internalMetadata: cell.internalMetadata,
            metadata: cell.metadata,
            outputs: cell.outputs.map(toNotebookOutputDto)
        };
    }
    NotebookDto.toNotebookCellDataDto = toNotebookCellDataDto;
    function toNotebookDataDto(data) {
        return {
            metadata: data.metadata,
            cells: data.cells.map(toNotebookCellDataDto)
        };
    }
    NotebookDto.toNotebookDataDto = toNotebookDataDto;
    function fromNotebookOutputItemDto(item) {
        return {
            mime: item.mime,
            data: item.valueBytes
        };
    }
    NotebookDto.fromNotebookOutputItemDto = fromNotebookOutputItemDto;
    function fromNotebookOutputDto(output) {
        return {
            outputId: output.outputId,
            metadata: output.metadata,
            outputs: output.items.map(fromNotebookOutputItemDto)
        };
    }
    NotebookDto.fromNotebookOutputDto = fromNotebookOutputDto;
    function fromNotebookCellDataDto(cell) {
        return {
            cellKind: cell.cellKind,
            language: cell.language,
            mime: cell.mime,
            source: cell.source,
            outputs: cell.outputs.map(fromNotebookOutputDto),
            metadata: cell.metadata,
            internalMetadata: cell.internalMetadata
        };
    }
    NotebookDto.fromNotebookCellDataDto = fromNotebookCellDataDto;
    function fromNotebookDataDto(data) {
        return {
            metadata: data.metadata,
            cells: data.cells.map(fromNotebookCellDataDto)
        };
    }
    NotebookDto.fromNotebookDataDto = fromNotebookDataDto;
    function toNotebookCellDto(cell) {
        return {
            handle: cell.handle,
            uri: cell.uri,
            source: cell.textBuffer.getLinesContent(),
            eol: cell.textBuffer.getEOL(),
            language: cell.language,
            cellKind: cell.cellKind,
            outputs: cell.outputs.map(toNotebookOutputDto),
            metadata: cell.metadata,
            internalMetadata: cell.internalMetadata,
        };
    }
    NotebookDto.toNotebookCellDto = toNotebookCellDto;
    function fromCellExecuteUpdateDto(data) {
        if (data.editType === CellExecutionUpdateType.Output) {
            return {
                editType: data.editType,
                append: data.append,
                outputs: data.outputs.map(fromNotebookOutputDto)
            };
        }
        else if (data.editType === CellExecutionUpdateType.OutputItems) {
            return {
                editType: data.editType,
                append: data.append,
                outputId: data.outputId,
                items: data.items.map(fromNotebookOutputItemDto)
            };
        }
        else {
            return data;
        }
    }
    NotebookDto.fromCellExecuteUpdateDto = fromCellExecuteUpdateDto;
    function fromCellExecuteCompleteDto(data) {
        return data;
    }
    NotebookDto.fromCellExecuteCompleteDto = fromCellExecuteCompleteDto;
    function fromCellEditOperationDto(edit) {
        if (edit.editType === 1 ) {
            return {
                editType: edit.editType,
                index: edit.index,
                count: edit.count,
                cells: edit.cells.map(fromNotebookCellDataDto)
            };
        }
        else {
            return edit;
        }
    }
    NotebookDto.fromCellEditOperationDto = fromCellEditOperationDto;
})(NotebookDto || (NotebookDto = {}));
function reviveWorkspaceEditDto2(data) {
    if (!data?.edits) {
        return [];
    }
    const result = [];
    for (let edit of revive(data).edits) {
        if (edit._type === 1 ) {
            result.push( new ResourceFileEdit(edit.oldUri, edit.newUri, edit.options, edit.metadata));
        }
        else if (edit._type === 2 ) {
            result.push( new ResourceTextEdit(edit.resource, edit.edit, edit.modelVersionId, edit.metadata));
        }
        else if (edit._type === 3 ) {
            result.push( new ResourceNotebookCellEdit(
                edit.resource,
                NotebookDto.fromCellEditOperationDto(edit.edit),
                edit.notebookVersionId,
                edit.metadata
            ));
        }
    }
    return result;
}
class EmptyFileSystem {
    constructor() {
        this.stat = unsupported$1;
    }
    isWritableFileSystem() {
        return false;
    }
    readDirectory() {
        return Promise.resolve([]);
    }
    createDirectory() {
        return Promise.resolve();
    }
    readFile() {
        return Promise.resolve(new Uint8Array(0));
    }
    writeFile() {
        return Promise.resolve();
    }
    delete() {
        return Promise.resolve();
    }
    rename() {
        return Promise.resolve();
    }
    copy() {
        return Promise.resolve();
    }
}
const workspace$1 = {
    fs: new EmptyFileSystem(),
    workspaceFile: undefined,
    createFileSystemWatcher(globPattern, ignoreCreateEvents, ignoreChangeEvents, ignoreDeleteEvents) {
        const services = Services.get();
        if (services.workspace?.createFileSystemWatcher != null) {
            return services.workspace.createFileSystemWatcher(globPattern, ignoreCreateEvents, ignoreChangeEvents, ignoreDeleteEvents);
        }
        return {
            ignoreCreateEvents: ignoreCreateEvents ?? false,
            ignoreChangeEvents: ignoreChangeEvents ?? false,
            ignoreDeleteEvents: ignoreDeleteEvents ?? false,
            onDidCreate: Event.None,
            onDidChange: Event.None,
            onDidDelete: Event.None,
            dispose: () => { }
        };
    },
    applyEdit: async (edit) => {
        const test = WorkspaceEdit$1.from(edit);
        const resourceEdits = reviveWorkspaceEditDto2(test);
        await StandaloneServices.get(IBulkEditService).apply(resourceEdits);
        return true;
    },
    getConfiguration: (section, scope) => {
        const { workspace } = Services.get();
        if (workspace?.getConfiguration != null) {
            return workspace.getConfiguration(section, scope);
        }
        return {
            get: (section, defaultValue) => {
                return defaultValue;
            },
            has: () => {
                return false;
            },
            inspect: unsupported$1,
            update: unsupported$1
        };
    },
    get onDidChangeConfiguration() {
        const services = Services.get();
        return services.workspace?.onDidChangeConfiguration ?? Event.None;
    },
    get rootPath() {
        const services = Services.get();
        return services.workspace?.rootPath;
    },
    get workspaceFolders() {
        const services = Services.get();
        if (services.workspace == null) {
            return undefined;
        }
        if ('workspaceFolders' in services.workspace) {
            return services.workspace.workspaceFolders;
        }
        const rootPath = services.workspace.rootPath;
        if (rootPath == null) {
            return undefined;
        }
        const uri = URI.file(rootPath);
        return [{
                uri,
                index: 0,
                name: uri.toString()
            }];
    },
    getWorkspaceFolder(uri) {
        return this.workspaceFolders?.find(folder => {
            return uri.path.startsWith(folder.uri.path);
        });
    },
    get onDidChangeWorkspaceFolders() {
        const services = Services.get();
        return services.workspace?.onDidChangeWorkspaceFolders ?? Event.None;
    },
    get textDocuments() {
        return Array.from(extHostDocuments.getAllDocumentData().map(data => data.document));
    },
    get onDidOpenTextDocument() {
        return extHostDocuments.onDidAddDocument;
    },
    get onDidCloseTextDocument() {
        return extHostDocuments.onDidRemoveDocument;
    },
    get onDidChangeTextDocument() {
        return extHostDocuments.onDidChangeDocument;
    },
    get onWillSaveTextDocument() {
        const services = Services.get();
        return services.workspace?.onWillSaveTextDocument ?? Event.None;
    },
    get onDidSaveTextDocument() {
        const services = Services.get();
        return services.workspace?.onDidSaveTextDocument ?? Event.None;
    },
    get onWillCreateFiles() {
        return Event.None;
    },
    get onDidCreateFiles() {
        return Event.None;
    },
    get onWillDeleteFiles() {
        return Event.None;
    },
    get onDidDeleteFiles() {
        return Event.None;
    },
    get onWillRenameFiles() {
        return Event.None;
    },
    get onDidRenameFiles() {
        return Event.None;
    },
    get onDidGrantWorkspaceTrust() {
        return Event.None;
    },
    asRelativePath: unsupported$1,
    updateWorkspaceFolders: unsupported$1,
    findFiles: unsupported$1,
    saveAll: unsupported$1,
    openTextDocument: unsupported$1,
    registerTextDocumentContentProvider: unsupported$1,
    registerTaskProvider: unsupported$1,
    registerFileSystemProvider: unsupported$1,
    openNotebookDocument: unsupported$1,
    registerNotebookSerializer: unsupported$1,
    notebookDocuments: [],
    onDidOpenNotebookDocument: unsupported$1,
    onDidCloseNotebookDocument: unsupported$1,
    isTrusted: true,
    name: undefined,
    onDidChangeNotebookDocument: unsupported$1,
    onDidSaveNotebookDocument: unsupported$1
};
var customWorkspace = workspace$1;
function showMessage(type, message, ...rest) {
    const { window } = Services.get();
    if (window == null) {
        return Promise.resolve(undefined);
    }
    return window.showMessage(type, message, ...rest);
}
const window$2 = {
    showInformationMessage: showMessage.bind(undefined, Severity.Info),
    showWarningMessage: showMessage.bind(undefined, Severity.Warning),
    showErrorMessage: showMessage.bind(undefined, Severity.Error),
    createOutputChannel(name) {
        const { window } = Services.get();
        const createOutputChannel = (window != null) ? window.createOutputChannel : undefined;
        const channel = (createOutputChannel != null) ? createOutputChannel.bind(window)(name) : undefined;
        return channel ?? {
            name,
            append: () => { },
            appendLine: () => { },
            clear: unsupported$1,
            show: () => { },
            hide: unsupported$1,
            replace: unsupported$1,
            dispose: () => { }
        };
    },
    withProgress: (options, task) => {
        const { window } = Services.get();
        if ((window != null) && (window.withProgress != null)) {
            return window.withProgress(options, task);
        }
        return task({ report: () => { } }, new CancellationTokenSource$1().token);
    },
    showTextDocument: async (textDocumentOrUri, columnOrOptions, preserveFocus) => {
        const { window } = Services.get();
        let options;
        if (typeof columnOrOptions === 'number') {
            options = {
                viewColumn: columnOrOptions,
                preserveFocus
            };
        }
        else {
            options = columnOrOptions;
        }
        if ((window != null) && (window.showTextDocument != null)) {
            await window.showTextDocument(URI.isUri(textDocumentOrUri) ? textDocumentOrUri : textDocumentOrUri.uri, options);
        }
        return undefined;
    },
    createTextEditorDecorationType: unsupported$1,
    showQuickPick: unsupported$1,
    showWorkspaceFolderPick: unsupported$1,
    showOpenDialog: unsupported$1,
    showSaveDialog: unsupported$1,
    showInputBox: unsupported$1,
    createWebviewPanel: unsupported$1,
    setStatusBarMessage: unsupported$1,
    withScmProgress: unsupported$1,
    createStatusBarItem: unsupported$1,
    createTerminal: unsupported$1,
    registerTreeDataProvider: unsupported$1,
    createTreeView: unsupported$1,
    registerWebviewPanelSerializer: unsupported$1,
    get activeTextEditor() {
        return unsupported$1();
    },
    get visibleTextEditors() {
        return unsupported$1();
    },
    onDidChangeActiveTextEditor: Event.None,
    onDidChangeVisibleTextEditors: Event.None,
    onDidChangeTextEditorSelection: Event.None,
    onDidChangeTextEditorVisibleRanges: Event.None,
    onDidChangeTextEditorOptions: Event.None,
    onDidChangeTextEditorViewColumn: Event.None,
    get terminals() {
        return unsupported$1();
    },
    get activeTerminal() {
        return unsupported$1();
    },
    onDidChangeActiveTerminal: Event.None,
    onDidOpenTerminal: Event.None,
    onDidCloseTerminal: Event.None,
    get state() {
        return unsupported$1();
    },
    onDidChangeWindowState: Event.None,
    createQuickPick: unsupported$1,
    createInputBox: unsupported$1,
    registerUriHandler: unsupported$1,
    registerWebviewViewProvider: unsupported$1,
    registerCustomEditorProvider: unsupported$1,
    registerTerminalLinkProvider: unsupported$1,
    get activeColorTheme() {
        return unsupported$1();
    },
    onDidChangeActiveColorTheme: Event.None,
    registerFileDecorationProvider: unsupported$1,
    registerTerminalProfileProvider: unsupported$1,
    onDidChangeTerminalState: Event.None,
    get tabGroups() {
        return unsupported$1();
    },
    showNotebookDocument: unsupported$1,
    visibleNotebookEditors: [],
    onDidChangeVisibleNotebookEditors: Event.None,
    activeNotebookEditor: undefined,
    onDidChangeActiveNotebookEditor: Event.None,
    onDidChangeNotebookEditorSelection: Event.None,
    onDidChangeNotebookEditorVisibleRanges: Event.None
};
var customWindow = window$2;
const env$1 = {
    appName: 'Monaco',
    appRoot: '',
    language: window.navigator.language ?? 'en-US',
    get uriScheme() {
        return unsupported$1();
    },
    get clipboard() {
        return unsupported$1();
    },
    get machineId() {
        return unsupported$1();
    },
    get sessionId() {
        return unsupported$1();
    },
    remoteName: undefined,
    shell: '',
    uiKind: UIKind$1.Web,
    asExternalUri: unsupported$1,
    openExternal: async (uri) => {
        const { env } = Services.get();
        if ((env != null) && (env.openExternal != null)) {
            return env.openExternal(uri);
        }
        return false;
    },
    appHost: 'web',
    isNewAppInstall: false,
    isTelemetryEnabled: false,
    onDidChangeTelemetryEnabled: Event.None
};
var customEnv = env$1;
const unsupported = undefined;
const api = {
    version: '1.67',
    tasks: unsupported,
    notebooks: unsupported,
    scm: unsupported,
    debug: unsupported,
    extensions: unsupported,
    comments: unsupported,
    authentication: unsupported,
    tests: unsupported,
    env: customEnv,
    commands: customCommands,
    window: customWindow,
    workspace: customWorkspace,
    languages: customLanguages,
    Breakpoint: Breakpoint$1,
    CallHierarchyIncomingCall: CallHierarchyIncomingCall$1,
    CallHierarchyItem: CallHierarchyItem$2,
    CallHierarchyOutgoingCall: CallHierarchyOutgoingCall$1,
    CancellationError: CancellationError$1,
    CancellationTokenSource: CancellationTokenSource$1,
    CodeAction: CodeAction$1,
    CodeActionKind: CodeActionKind$1,
    CodeActionTriggerKind: CodeActionTriggerKind$2,
    CodeLens: CodeLens$1,
    Color: Color$2,
    ColorInformation: ColorInformation$1,
    ColorPresentation: ColorPresentation$2,
    ColorThemeKind: ColorThemeKind$1,
    CommentMode: CommentMode$1,
    CommentThreadCollapsibleState: CommentThreadCollapsibleState$1,
    CompletionItem: CompletionItem$1,
    CompletionItemKind: CompletionItemKind$2,
    CompletionItemTag: CompletionItemTag$2,
    CompletionList: CompletionList$1,
    CompletionTriggerKind: CompletionTriggerKind$2,
    ConfigurationTarget: ConfigurationTarget$1,
    CustomExecution: CustomExecution$1,
    DebugAdapterExecutable: DebugAdapterExecutable$1,
    DebugAdapterInlineImplementation: DebugAdapterInlineImplementation$1,
    DebugAdapterNamedPipeServer: DebugAdapterNamedPipeServer$1,
    DebugAdapterServer: DebugAdapterServer$1,
    DebugConfigurationProviderTriggerKind: DebugConfigurationProviderTriggerKind$1,
    DebugConsoleMode: DebugConsoleMode$1,
    DecorationRangeBehavior: DecorationRangeBehavior$1,
    Diagnostic: Diagnostic$2,
    DiagnosticRelatedInformation: DiagnosticRelatedInformation$2,
    DiagnosticSeverity: DiagnosticSeverity$2,
    DiagnosticTag: DiagnosticTag$2,
    Disposable: Disposable$1,
    DocumentHighlight: DocumentHighlight$2,
    DocumentHighlightKind: DocumentHighlightKind$1,
    DocumentLink: DocumentLink$2,
    DocumentSymbol: DocumentSymbol$2,
    EndOfLine: EndOfLine$2,
    EnvironmentVariableMutatorType: EnvironmentVariableMutatorType$1,
    EvaluatableExpression: EvaluatableExpression$2,
    InlineValueText: InlineValueText$1,
    InlineValueVariableLookup: InlineValueVariableLookup$1,
    InlineValueEvaluatableExpression: InlineValueEvaluatableExpression$1,
    EventEmitter: Emitter,
    ExtensionKind: ExtensionKind$1,
    ExtensionMode: ExtensionMode$1,
    FileChangeType: FileChangeType$1,
    FileDecoration: FileDecoration$1,
    FileSystemError: FileSystemError$1,
    FileType: FileType$1,
    FilePermission: FilePermission$1,
    FoldingRange: FoldingRange$2,
    FoldingRangeKind: FoldingRangeKind$3,
    FunctionBreakpoint: FunctionBreakpoint$1,
    Hover: Hover$2,
    IndentAction: IndentAction$1,
    Location: Location$1,
    MarkdownString: MarkdownString$2,
    OverviewRulerLane: OverviewRulerLane$1,
    ParameterInformation: ParameterInformation$2,
    Position: Position$3,
    ProcessExecution: ProcessExecution$1,
    ProgressLocation: ProgressLocation$1,
    QuickInputButtons: QuickInputButtons$1,
    Range: Range$3,
    RelativePattern: RelativePattern$1,
    Selection: Selection$3,
    SelectionRange: SelectionRange$2,
    SemanticTokens: SemanticTokens$1,
    SemanticTokensBuilder: SemanticTokensBuilder$1,
    SemanticTokensEdit: SemanticTokensEdit$1,
    SemanticTokensEdits: SemanticTokensEdits$1,
    SemanticTokensLegend: SemanticTokensLegend$1,
    ShellExecution: ShellExecution$1,
    ShellQuoting: ShellQuoting$1,
    SignatureHelp: SignatureHelp$2,
    SignatureHelpTriggerKind: SignatureHelpTriggerKind$1,
    SignatureInformation: SignatureInformation$2,
    SnippetString: SnippetString$1,
    SourceBreakpoint: SourceBreakpoint$1,
    StatusBarAlignment: StatusBarAlignment$1,
    SymbolInformation: SymbolInformation$1,
    SymbolKind: SymbolKind$2,
    SymbolTag: SymbolTag$2,
    Task: Task$1,
    TaskGroup: TaskGroup$1,
    TaskPanelKind: TaskPanelKind$1,
    TaskRevealKind: TaskRevealKind$1,
    TaskScope: TaskScope$1,
    TerminalLink: TerminalLink$1,
    TerminalLocation: TerminalLocation$1,
    TerminalProfile: TerminalProfile$1,
    TextDocumentSaveReason: TextDocumentSaveReason$1,
    TextEdit: TextEdit$2,
    TextEditorCursorStyle: TextEditorCursorStyle$1,
    TextEditorLineNumbersStyle: TextEditorLineNumbersStyle$1,
    TextEditorRevealType: TextEditorRevealType$1,
    TextEditorSelectionChangeKind: TextEditorSelectionChangeKind$1,
    TextDocumentChangeReason: TextDocumentChangeReason$1,
    ThemeColor: ThemeColor$1,
    ThemeIcon: ThemeIcon$1,
    TreeItem: TreeItem$1,
    TreeItemCollapsibleState: TreeItemCollapsibleState$1,
    TypeHierarchyItem: TypeHierarchyItem$2,
    UIKind: UIKind$1,
    Uri: URI,
    ViewColumn: ViewColumn$1,
    WorkspaceEdit: WorkspaceEdit$2,
    InlayHint: InlayHint$1,
    InlayHintLabelPart: InlayHintLabelPart$1,
    InlayHintKind: InlayHintKind$2,
    NotebookRange: NotebookRange$2,
    NotebookCellKind: NotebookCellKind$2,
    NotebookCellData: NotebookCellData$2,
    NotebookData: NotebookData$1,
    NotebookCellStatusBarAlignment: NotebookCellStatusBarAlignment$1,
    NotebookCellOutput: NotebookCellOutput$2,
    NotebookCellOutputItem: NotebookCellOutputItem$2,
    NotebookCellStatusBarItem: NotebookCellStatusBarItem$1,
    NotebookControllerAffinity: NotebookControllerAffinity$1,
    LinkedEditingRanges: LinkedEditingRanges$1,
    TestRunRequest: TestRunRequest$1,
    TestMessage: TestMessage$1,
    TestTag: TestTag$1,
    TestRunProfileKind: TestRunProfileKind$1,
    DataTransfer: DataTransfer$1,
    DataTransferItem: DataTransferItem$1,
    LanguageStatusSeverity: LanguageStatusSeverity$1,
    QuickPickItemKind: QuickPickItemKind$1,
    TabInputText: TextTabInput,
    TabInputTextDiff: TextDiffTabInput,
    TabInputCustom: CustomEditorTabInput,
    TabInputNotebook: NotebookEditorTabInput,
    TabInputNotebookDiff: NotebookDiffEditorTabInput,
    TabInputWebview: WebviewEditorTabInput,
    TabInputTerminal: TerminalEditorTabInput,
    InputBoxValidationSeverity: InputBoxValidationSeverity$1,
    InlineCompletionList: InlineSuggestionList,
    InlineCompletionTriggerKind: InlineCompletionTriggerKind$1,
    InlineCompletionItem: InlineSuggestion,
    NotebookEditorRevealType: NotebookEditorRevealType$1
};
const { version, tasks, notebooks, scm, debug, extensions, comments, authentication, tests, env, commands, window: window$1, workspace, languages, Breakpoint, CallHierarchyIncomingCall, CallHierarchyItem, CallHierarchyOutgoingCall, CancellationError, CancellationTokenSource, CodeAction, CodeActionKind, CodeActionTriggerKind, CodeLens, Color, ColorInformation, ColorPresentation, ColorThemeKind, CommentMode, CommentThreadCollapsibleState, CompletionItem, CompletionItemKind, CompletionItemTag, CompletionList, CompletionTriggerKind, ConfigurationTarget, CustomExecution, DebugAdapterExecutable, DebugAdapterInlineImplementation, DebugAdapterNamedPipeServer, DebugAdapterServer, DebugConfigurationProviderTriggerKind, DebugConsoleMode, DecorationRangeBehavior, Diagnostic, DiagnosticRelatedInformation, DiagnosticSeverity, DiagnosticTag, Disposable, DocumentHighlight, DocumentHighlightKind, DocumentLink, DocumentSymbol, EndOfLine, EnvironmentVariableMutatorType, EvaluatableExpression, InlineValueText, InlineValueVariableLookup, InlineValueEvaluatableExpression, EventEmitter, ExtensionKind, ExtensionMode, FileChangeType, FileDecoration, FileSystemError, FileType, FilePermission, FoldingRange, FoldingRangeKind, FunctionBreakpoint, Hover, IndentAction, Location, MarkdownString, OverviewRulerLane, ParameterInformation, Position, ProcessExecution, ProgressLocation, QuickInputButtons, Range, RelativePattern, Selection, SelectionRange, SemanticTokens, SemanticTokensBuilder, SemanticTokensEdit, SemanticTokensEdits, SemanticTokensLegend, ShellExecution, ShellQuoting, SignatureHelp, SignatureHelpTriggerKind, SignatureInformation, SnippetString, SourceBreakpoint, StatusBarAlignment, SymbolInformation, SymbolKind, SymbolTag, Task, TaskGroup, TaskPanelKind, TaskRevealKind, TaskScope, TerminalLink, TerminalLocation, TerminalProfile, TextDocumentSaveReason, TextEdit, TextEditorCursorStyle, TextEditorLineNumbersStyle, TextEditorRevealType, TextEditorSelectionChangeKind, TextDocumentChangeReason, ThemeColor, ThemeIcon, TreeItem, TreeItemCollapsibleState, TypeHierarchyItem, UIKind, Uri, ViewColumn, WorkspaceEdit, InlayHint, InlayHintLabelPart, InlayHintKind, NotebookRange, NotebookCellKind, NotebookCellData, NotebookData, NotebookCellStatusBarAlignment, NotebookCellOutput, NotebookCellOutputItem, NotebookCellStatusBarItem, NotebookControllerAffinity, LinkedEditingRanges, TestRunRequest, TestMessage, TestTag, TestRunProfileKind, DataTransfer, DataTransferItem, LanguageStatusSeverity, QuickPickItemKind, TabInputText, TabInputTextDiff, TabInputCustom, TabInputNotebook, TabInputNotebookDiff, TabInputWebview, TabInputTerminal, InputBoxValidationSeverity, InlineCompletionList, InlineCompletionTriggerKind, InlineCompletionItem, NotebookEditorRevealType } = api;
export { Breakpoint, CallHierarchyIncomingCall, CallHierarchyItem, CallHierarchyOutgoingCall, CancellationError, CancellationTokenSource, CodeAction, CodeActionKind, CodeActionTriggerKind, CodeLens, Color, ColorInformation, ColorPresentation, ColorThemeKind, CommentMode, CommentThreadCollapsibleState, CompletionItem, CompletionItemKind, CompletionItemTag, CompletionList, CompletionTriggerKind, ConfigurationTarget, CustomExecution, DataTransfer, DataTransferItem, DebugAdapterExecutable, DebugAdapterInlineImplementation, DebugAdapterNamedPipeServer, DebugAdapterServer, DebugConfigurationProviderTriggerKind, DebugConsoleMode, DecorationRangeBehavior, Diagnostic, DiagnosticRelatedInformation, DiagnosticSeverity, DiagnosticTag, Disposable, DocumentHighlight, DocumentHighlightKind, DocumentLink, DocumentSymbol, EndOfLine, EnvironmentVariableMutatorType, EvaluatableExpression, EventEmitter, ExtensionKind, ExtensionMode, FileChangeType, FileDecoration, FilePermission, FileSystemError, FileType, FoldingRange, FoldingRangeKind, FunctionBreakpoint, Hover, IndentAction, InlayHint, InlayHintKind, InlayHintLabelPart, InlineCompletionItem, InlineCompletionList, InlineCompletionTriggerKind, InlineValueEvaluatableExpression, InlineValueText, InlineValueVariableLookup, InputBoxValidationSeverity, LanguageStatusSeverity, LinkedEditingRanges, Location, MarkdownString, NotebookCellData, NotebookCellKind, NotebookCellOutput, NotebookCellOutputItem, NotebookCellStatusBarAlignment, NotebookCellStatusBarItem, NotebookControllerAffinity, NotebookData, NotebookEditorRevealType, NotebookRange, OverviewRulerLane, ParameterInformation, Position, ProcessExecution, ProgressLocation, QuickInputButtons, QuickPickItemKind, Range, RelativePattern, Selection, SelectionRange, SemanticTokens, SemanticTokensBuilder, SemanticTokensEdit, SemanticTokensEdits, SemanticTokensLegend, ShellExecution, ShellQuoting, SignatureHelp, SignatureHelpTriggerKind, SignatureInformation, SnippetString, SourceBreakpoint, StatusBarAlignment, SymbolInformation, SymbolKind, SymbolTag, TabInputCustom, TabInputNotebook, TabInputNotebookDiff, TabInputTerminal, TabInputText, TabInputTextDiff, TabInputWebview, Task, TaskGroup, TaskPanelKind, TaskRevealKind, TaskScope, TerminalLink, TerminalLocation, TerminalProfile, TestMessage, TestRunProfileKind, TestRunRequest, TestTag, TextDocumentChangeReason, TextDocumentSaveReason, TextEdit, TextEditorCursorStyle, TextEditorLineNumbersStyle, TextEditorRevealType, TextEditorSelectionChangeKind, ThemeColor, ThemeIcon, TreeItem, TreeItemCollapsibleState, TypeHierarchyItem, UIKind, Uri, ViewColumn, WorkspaceEdit, authentication, commands, comments, debug, env, extensions, languages, notebooks, scm, tasks, tests, version, window$1 as window, workspace };
